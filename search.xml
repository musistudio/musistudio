<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP协议初探</title>
    <url>/code/HTTP%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2.html</url>
    <content><![CDATA[<h2 id="HTTP协议初探"><a href="#HTTP协议初探" class="headerlink" title="HTTP协议初探"></a>HTTP协议初探</h2><ul>
<li><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>HTTP(Hyper Text Transfer Protocol)即超文本传输协议，它的发展是万维网协会(World Wide Web Consortium)和Internet小组IETF(Internet Engineering Task Force)合作的结果，最终发布了一系列的RFC。RFC 1945定义了HTTP/1.0版本，其中最著名的就是RFC 2616，其定义了普遍使用的一个版本——HTTP 1.1         </p>
</blockquote>
<p>HTTP协议是用于从www服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。</p>
<p>HTTP是一个应用层协议，由请求和相应构成，是一个标准的C/S(客户端/服务器)模型。<strong>HTTP是一个无状态的协议</strong></p>
<a id="more"></a></li>
<li><h4 id="在TCP-IP协议栈中的位置"><a href="#在TCP-IP协议栈中的位置" class="headerlink" title="在TCP/IP协议栈中的位置"></a>在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上(HTTPS)</p>
</li>
<li><h4 id="HTTP的请求相应模型"><a href="#HTTP的请求相应模型" class="headerlink" title="HTTP的请求相应模型"></a>HTTP的请求相应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器返回相应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p>
<p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有关系的。</p>
</li>
<li><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程课分为四部：</p>
<ol>
<li>首先客户机与服务器建立连接，只要单击某个超级链接，HTTP的工作开始</li>
<li>建立链接后，客户机发送一个请求给服务器，请求方式的格式为:统一资源标识符(URL)、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容</li>
<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容</li>
<li>客户端接收服务器所返回的信息通过浏览器显示出来，然后客户端与服务器断开链接</li>
</ol>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回给客户端</p>
</li>
<li><h4 id="头域"><a href="#头域" class="headerlink" title="头域"></a>头域</h4><p>每个头域由一个域名，冒号(:)和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处使用至少一个空格或制表符</p>
<ol>
<li><p>Host头域</p>
<p>Host头域指定请求资源的Internet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</p>
</li>
<li><p>Referer头域</p>
<p> Referer头域允许客户端指定请求URI的源资源地址，这可以允许服务器生成回退链表，可用来登录、优化cache等。它也允许废除的或错误的连接由于维护的目的被追踪。如果请求的URI没有自己的URI地址，Referer不能被发送。如果指定的是部分URI地址，则此地址应该是一个相对地址。</p>
</li>
<li><p>User-Agent头域</p>
<p>User-Agent头域的内容包含发出请求的用户信息</p>
</li>
<li><p>Cache-Control头域</p>
<p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程。请求时的缓存指令包括<strong>no-cache</strong>、<strong>no-store</strong>、<strong>max-age</strong>、<strong>max-stale</strong>、<strong>min-fresh</strong>、<strong>only-if-cached</strong>，响应消息中的指令包括<strong>public</strong>、<strong>private</strong>、<strong>no-cache</strong>、<strong>no-store</strong>、<strong>no-transform</strong>、<strong>must-revalidate</strong>、<strong>proxy-revalidate</strong>、<strong>max-age</strong>。</p>
</li>
<li><p>Date头域</p>
<p>Date头域表示消息发送的时间，时间的描述格式由<strong>rfc822</strong>定义。</p>
</li>
</ol>
</li>
<li><h4 id="HTTP协议中的几个重要概念"><a href="#HTTP协议中的几个重要概念" class="headerlink" title="HTTP协议中的几个重要概念"></a>HTTP协议中的几个重要概念</h4><ol>
<li><p>连接：Connection</p>
<p>一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p>
<p>在HTTP/1.1中，request和response头中都有可能出现一个connection的头，此header的含义是client和server通信时对于长连接如何进行处理</p>
<p>在HTTP/1.1中，client和server都是默认支持长连接的，如果client使用HTTP/1.1协议，但又不希望使用长连接，则需要在header中指明Connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp连接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp连接了</p>
</li>
<li><p>消息：Message</p>
<p>HTTP通讯的基本单位，包括一个结构化的八元祖序列并通过连接传输</p>
</li>
<li><p>请求：Request</p>
<p>一个从客户端到服务器的请求信息包括应用于资源的方法，资源的标识符和协议的版本号</p>
</li>
<li><p>响应：Response</p>
<p>一个从服务器返回的信息包括HTTP协议的版本号，请求的状态和文档的MIME类型。</p>
</li>
<li><p>资源：Resource</p>
<p>由URI标识的网络数据对象或服务</p>
</li>
<li><p>实体：Entity</p>
<p>数据资源或来自服务资源的回应的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p>
</li>
<li><p>客户机：Client</p>
<p>一个为发送请求目的而建立连接的应用程序</p>
</li>
<li><p>用户代理：UserAgent</p>
<p>初始化一个请求的客户机。它们是浏览器、编辑器或者是其它用户工具。</p>
</li>
<li><p>服务器：Server</p>
<p>一个接受连接并对请求返回信息的应用程序。</p>
</li>
<li><p>源服务器：Originserver</p>
<p>是一个给定资源可以在其上驻留或被创建的服务器。</p>
</li>
<li><p>代理：Proxy</p>
<p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求前，必须解释如果可能并重写它。</p>
<p>代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p>
</li>
<li><p>网关：Gateway</p>
<p>一个作为其它服务器中介媒介的服务器。与代理不同的是，网关接受请求对被请求的资源来说它就是源服务器。发出请求的客户机并没有意识到它在同网关打交道。</p>
<p>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p>
</li>
<li><p>通道：Tunnel</p>
<p>通道是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通信，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
</li>
<li><p>缓存：Cache</p>
<p>反应信息的局域存储。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议补充</title>
    <url>/code/HTTP%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85.html</url>
    <content><![CDATA[<blockquote>
<p>上次我们对HTTP协议已经有了初步的了解，今天我们就来继续学习一下HTTP协议</p>
</blockquote>
<ol>
<li><p>HTTP协议格式</p>
<p>HTTP协议的格式大致可划分成一下几个部分</p>
<ul>
<li>Request<ul>
<li>Request line<ul>
<li>method</li>
<li>path</li>
<li>Version</li>
</ul>
</li>
<li>head</li>
<li>body</li>
</ul>
</li>
<li>Response<ul>
<li>Response line<ul>
<li>version</li>
<li>Status code</li>
<li>Statis text</li>
</ul>
</li>
<li>head</li>
<li>body<a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP Method(方法)</p>
<p>HTTP Method是HTTP请求中Request部分，大概有以下几种定义:</p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ul>
<p>在这几种方法中，比较常用的是<strong>GET</strong>和<strong>POST</strong>方法，HEAD和GET类似，只返回请求头</p>
<p>PUT和DELETE分别表示添加资源和删除资源，这只是一种语义上的约定，并没有强约束</p>
<p>CONNECT多用于HTTPS和WebSocket</p>
<p>OPTIONS和TRACE一般用于调试，多数线上服务器不支持</p>
</li>
<li><p>HTTP Status code(状态码)和HTTP status text(状态文本)</p>
<p>常见的状态码有以下几种:</p>
<ul>
<li>1xx: 临时回应，表示客户端请继续</li>
<li>2xx: 请求成功<ul>
<li>200: 请求成功</li>
</ul>
</li>
<li>3xx: 表示请求的目的有变化，希望客户端进一步处理<ul>
<li>301&amp;302：永久性与临时性跳转</li>
<li>304：客户端缓存没有更新</li>
</ul>
</li>
<li>4xx: 客户端请求错误<ul>
<li>403：无权限</li>
<li>404：表示请求的页面不存在</li>
<li>418：这是一个彩蛋</li>
</ul>
</li>
<li>5xx: 服务端请求错误<ul>
<li>500: 服务端错误</li>
<li>503: 服务端暂时性错误，可以稍后再试</li>
</ul>
</li>
</ul>
<p>在前端开发的过程中，1xx系列的状态码被浏览器http库直接处理掉了，不会让上层知晓</p>
<p>2xx系列的状态码通常是网页请求成功的标志</p>
<p>3xx系列比较复杂，301和302两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上301更接近于一种报错，提示客户端下次别来了</p>
<p>产生304状态的前提是客户端本地已经有缓存的版本，并且在Request中告诉了服务端，当服务端通过时间或者tag发现没有更新的时候，就会返回一个不含body的304状态</p>
</li>
<li><p>HTTP Head(HTTP头)</p>
<p>HTTP头可以看作一个键值对。原则上，HTTP头也是一种数据，我们可以自由定义HTTP头和值。在HTTP规范中规定了一些特殊的HTTP头。</p>
<p>Request Header              </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Request Header</th>
<th align="center">规定</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">浏览器端接收的格式</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">浏览器接收的编码方式</td>
</tr>
<tr>
<td align="center">Accept_Language</td>
<td align="center">浏览器接受的语言，用于服务端判断多语言</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中的那些事儿</title>
    <url>/code/HTML%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html</url>
    <content><![CDATA[<blockquote>
<p><strong>超文本标记语言</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，简称：<strong>HTML</strong>）是一种用于创建网页的标准标记语言。HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。</p>
</blockquote>
<a id="more"></a>

<h2 id="HTML简史"><a href="#HTML简史" class="headerlink" title="HTML简史"></a>HTML简史</h2><ul>
<li><p>1993年中期<a href="https://zh.wikipedia.org/wiki/互联网工程任务组" target="_blank" rel="noopener">互联网工程任务组</a>（IETF）发布首个HTML规范提案。</p>
</li>
<li><p>1995年11月24日  HTML 2.0作为IETF RFC 1866发布，追加RFC的附加功能：</p>
<ul>
<li>1995年11月25日：<a href="https://tools.ietf.org/html/rfc1867" target="_blank" rel="noopener">RFC 1867</a>（基于表单的文件上传）</li>
<li>1996年5月：<a href="https://tools.ietf.org/html/rfc1942" target="_blank" rel="noopener">RFC 1942</a>（表格）</li>
<li>1996年8月：<a href="https://tools.ietf.org/html/rfc1980" target="_blank" rel="noopener">RFC 1980</a>（客户端图像映射）</li>
</ul>
</li>
<li><p>1997年1月：<a href="https://tools.ietf.org/html/rfc2070" target="_blank" rel="noopener">RFC 2070</a>（<a href="https://zh.wikipedia.org/wiki/国际化与本地化" target="_blank" rel="noopener">国际化</a>）</p>
</li>
<li><p>1997年1月14日  HTML 3.2作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭它的HTML工作组。</p>
</li>
<li><p>1997年12月18日 HTML 4.0作为W3C推荐标准发布。它提供三种变化：</p>
<ul>
<li>严格(Strict)，过时的元素被禁止。</li>
<li>过渡(Transitional)，过时的元素被允许。</li>
<li>框架集(Frameset)，大多只与框架相关的元素被允许。</li>
</ul>
</li>
<li><p>1998年4月24日 HTML 4.0进行微调，不增加版本号。</p>
</li>
<li><p>1999年12月24日  HTML 4.01作为W3C推荐标准发布。它同样提供三种变化，最终勘误版于2001年5月12日发布。</p>
</li>
<li><p>2000年5月  ISO/IEC 15445:2000（”ISO HTML”，基于HTML 4.01严格版）作为ISO/IEC国际标准发布。在ISO中这一标准位于[ISO/IEC JTC 1/SC 34]域（ISO/IEC联合技术委员会1、小组委员会34 – 文档描述与处理语言）。</p>
</li>
<li><p>2014年10月28日  HTML 5作为W3C推荐标准发布。</p>
</li>
</ul>
<h2 id="语义类标签"><a href="#语义类标签" class="headerlink" title="语义类标签"></a>语义类标签</h2><h4 id="什么是语义类标签"><a href="#什么是语义类标签" class="headerlink" title="什么是语义类标签"></a>什么是语义类标签</h4><p>超文本标记语言是由一个个标签组成，其中语义类标签是会经常出现的一类标签，它们的特点是视觉表现上都差不多，主要的区别在于它们表示了不同的语义，比如<code>section</code>、<code>nav</code>、<code>p</code>这些都是语义类的标签。</p>
<p>语义是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是对文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，我们需要依靠语义标签代为表达。</p>
<h3 id="为什么要用语义类标签"><a href="#为什么要用语义类标签" class="headerlink" title="为什么要用语义类标签"></a>为什么要用语义类标签</h3><ul>
<li>语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有 CSS 的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。</li>
<li>除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。</li>
</ul>
<h3 id="怎么合理使用语义类标签"><a href="#怎么合理使用语义类标签" class="headerlink" title="怎么合理使用语义类标签"></a>怎么合理使用语义类标签</h3><ul>
<li><p>场景一：作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。例：</p>
<p><code>&lt;em&gt;</code> 标签标记出需要用户着重阅读的内容， <code>&lt;em&gt;</code> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。通常该元素会被浏览器展示为斜体文本， 但是它不应该仅仅用于应用斜体样式，如果仅需要斜体样式应使用css样式实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 现有两句话 --&gt;</span></span><br><span class="line">今天我吃了一个苹果。</span><br><span class="line">今天我吃了一个苹果。</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果着重标签的位置不一样所表达的含义就完全不一样 --&gt;</span></span><br><span class="line">今天我吃了一个<span class="tag">&lt;<span class="name">em</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">em</span>&gt;</span>。</span><br><span class="line">今天我吃了<span class="tag">&lt;<span class="name">em</span>&gt;</span>一个<span class="tag">&lt;/<span class="name">em</span>&gt;</span>苹果。</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 前一句的侧重点在于种类上，侧重表达我吃的是苹果而不是香蕉橙子。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 前二句的侧重点在于数量上，侧重表达我吃的是一个不是两个三个。 --&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>场景二：文章标题摘要。例：</p>
<p>h1-h6 是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用 hgroup 标签。在 hgroup 中的 h1-h6 被视为同一标题的不同组成部分。</p>
<p>未使用group标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML中的那些事儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>HTML简史<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>balah balah<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成以下标题结构：</p>
<ul>
<li>HTML中的那些事儿<ul>
<li>HTML简史</li>
<li>…</li>
</ul>
</li>
</ul>
<p>使用hgroup标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML中的那些事儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>HTML简史<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>balah balah<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成以下标题结构：</p>
<ul>
<li>HTML中的那些事儿——HTML简史</li>
<li>…</li>
</ul>
<p>从 HTML 5 开始，我们有了 section 标签，这个标签可不仅仅是一个“有语义的 div”，它会改变 h1-h6 的语义。section 的嵌套会使得其中的 h1-h6 下降一级，因此，在 HTML5 以后，我们只需要 section 和 h1 就足以形成文档的树形结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML中的那些事儿<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>balah balah balah balah<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML简史<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>balah balah<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>语义类标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>balah balah<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成以下标题结构：</p>
<p>HTML中的那些事儿</p>
<ul>
<li>HTML简史</li>
<li>语义类标签</li>
</ul>
</li>
<li><p>场景三：适合机器阅读的整体结构</p>
<p>应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持“阅读视图功能”，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。我们正确使用整体结构类的语义标签，可以让页面对机器更友好。这是一个典型的body结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">            ……</span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">            ……</span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>……<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>……<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>……<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span>&gt;</span>……<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>header，通常出现在前部，表示导航或者介绍性的内容。</li>
<li>footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等。</li>
<li>aside，表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。aside 很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是 aside，aside 不一定是侧边栏。</li>
<li>address，表示“文章（作者）的联系方式”，address 明确地只关联到 article 和 body。</li>
</ul>
</li>
</ul>
<p>如果你无法做到准确使用这些语义类标签，那建议你先不要使用，以免造成歧义。比如有些前端工程师喜欢给所有并列关系的元素都套上 ul。ul 多数出现正在行文的中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用 ul，会造成大量冗余标签。</p>
<h2 id="元信息类标签"><a href="#元信息类标签" class="headerlink" title="元信息类标签"></a>元信息类标签</h2><p>所谓元信息，是指描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签，它们通常出现在 head 标签中，一般都不会在页面被显示出来。元信息多数情况下是给浏览器、搜索引擎等机器阅读的，有时候这些信息会在页面之外显示给用户，有时候则不会。</p>
<h4 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h4><p>head 标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。head 标签规定了自身必须是 html 标签中的第一个标签，它的内容必须包含一个 title标签，并且最多只能包含一个base标签 。如果文档作为 iframe，或者有其他方式指定了文档标题时，可以允许不包含 title 标签。</p>
<h3 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h3><p>title 标签表示文档的标题，这主要是考虑到 title 作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以 title 应该是完整地概括整个网页内容的。而 h1 则仅仅用于页面展示，它可以默认具有上下文，并且有链接辅助，所以可以简写，即便无法概括全文，也不会有很大的影响。</p>
<h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p>base 标签实际上是个历史遗留标签。它的作用是给页面上所有的 URL 相对地址提供一个基础。base 标签最多只有一个，它改变全局的链接地址，它是一个非常危险的标签，容易造成跟 JavaScript 的配合问题，所以在实际开发中，我比较建议你使用 JavaScript 来代替 base 标签。</p>
<h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p>meta 标签是一组键值对，它是一种通用的元信息表示标签。在 head 中可以出现任意多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML中meta标签新增charset属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- http-equiv属性表示执行一个命令 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 并且指定了http编码方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- viewport没有在HTML标准中定义，却是移动端开发的事实标准 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=500, initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="链接元素"><a href="#链接元素" class="headerlink" title="链接元素"></a>链接元素</h2><p>超链接是HTML里最重要的元素之一，没有了超链接的HTML不足以叫超文本。HTML里除了<code>a</code>标签是链接元素之外，还有<code>area</code>标签和<code>link</code>标签。</p>
<h4 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h4><p>link标签会产生一个链接，它可能生成超链接，这些超链接不会像a标签那样显示在网页中，也可能会生成外部资源链接。在多数浏览器中，生成超链接的link标签不产生任何作用，但这些lInk标签被搜索引擎和一些浏览器插件识别。另外一些link标签会把外部的资源链接到文档中，即实际下载这些资源。</p>
<ul>
<li><p>超链接类link</p>
<p>超链接型link标签是一种被动型链接，即用户不操作就不会主动下载。link标签具有特定的rel属性，会成为特定类型的link标签。产生超链接型的link标签包括：</p>
<ul>
<li><p><code>rel=&quot;canonical&quot;</code>型link</p>
<p>这个标签提示页面的主URL，在网站中可能存在多个URL指向同一个页面的情况，搜索引擎访问这类页面时会去掉重复的URL，这个link会提示搜索引擎保留那一个URL。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"canonical"</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rel=&quot;alternate&quot;</code>型link</p>
<p>这个标签提示页面它的变形形式，通常是给搜索引擎使用的。最常见的场景是rss订阅。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">type</span>=<span class="string">"application/rss+xml"</span> <span class="attr">title</span>=<span class="string">"RSS"</span> <span class="attr">href</span>=<span class="string">"..."</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rel=&quot;prev&quot;</code>型link和<code>rel=&quot;next&quot;</code>型link</p>
<p>在互联网应用中，很多网页都属于一个序列。比如分页浏览、图片展示等，每个网页是序列中的一个项。这种时候就适合用<code>prev</code>和<code>next</code>型link，用来告诉搜索引擎或者浏览器它的前一项和后一项，这有助于页面的批量展示。</p>
</li>
<li><p>其他超链接类的link</p>
<p>其他超链接类link标签都表示一个跟当前文档相关联的信息，可以把这样的link标签视为一种带链接功能的meta标签。</p>
<ul>
<li><p>rel=”author”</p>
<p>链接到本页面的作者，一般是mailto:协议</p>
</li>
<li><p>rel=”help”</p>
<p>链接到本页面的帮助页</p>
</li>
<li><p>rel=”license”</p>
<p>链接到本页面的版权信息页</p>
</li>
<li><p>rel=”search”</p>
<p>链接到本页面的搜索页面(一般用于站内搜索)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部资源类link</p>
<p>外部资源类link标签会主动下载，并且根据rel类型做不同的处理。外部资源类link标签包括：</p>
<ul>
<li><p>具有icon型的link</p>
<p>这类链接表示页面的icon，多数浏览器会读取icon型link并把icon展示出来。icon型link是唯一一个外部资源类的元信息link，其他元信息类link都是超链接，这意味着icon型link中的图标地址默认会被浏览器下载使用。</p>
<p>如果没有指定icon型link，多数浏览器会使用域名根目录下的favicon.ico文件，即使不存在该文件也会请求下载，所以从性能考虑，一定要保证页面中具有icon型的link。只有icon型的link有有效的sizes属性，HTML标准允许出现多个icon型link，并且用sizes指定它适合的icon尺寸。</p>
</li>
<li><p>预处理类link</p>
<p>预处理类link允许我们控制浏览器提前针对一些资源去做一些操作以提高性能(不当使用反而会降低性能)</p>
<ul>
<li><p>dns-prefetch型link</p>
<p>提前对一个域名做dns查询，这中link的href属性只有域名有意义。</p>
</li>
<li><p>preconnect型link</p>
<p>提前对一个服务器建立TCP连接</p>
</li>
<li><p>prefetch型link</p>
<p>提取href指定的url内容</p>
</li>
<li><p>preload型link</p>
<p>提前加载href指定的url</p>
</li>
<li><p>prerender型link</p>
<p>提前渲染href指定的url</p>
</li>
</ul>
</li>
<li><p>moduleopreload型的link</p>
<p>预先加载(完成下载并放入内存，但不会执行)一个JavaScript模块，保证JS模块不必等到执行时才加载。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"modulepreload"</span> <span class="attr">href</span>=<span class="string">"app.js"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>stylesheet型的link</p>
<p>基本用法是从一个css文件创建一个样式表，这里的type属性可以没有，如果有，则其值必须是<code>text/css</code>才会生效。rel前可以加上<code>alternate</code>，即<code>rel=&quot;alternate stylesheet&quot;</code>，此时必须指定type属性。这可以为页面创建一份变体样式，一些浏览器支持从浏览器菜单中切换这些样式，但大部分浏览器不支持这个功能。</p>
</li>
<li><p>pingback型的link</p>
<p>该类型的link表示本网页被引用时应该使用的pingback地址，这个机制是一份独立的标准，遵循pingback协议的网站在引用本页面时会向这个pingback url发送一个消息。     </p>
</li>
</ul>
</li>
</ul>
<h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>a标签是<strong>anchor</strong>的缩写，意为锚点，用来表示文档中特定的位置。a标签其实同时充当了链接和目标点的角色，当a有href属性时它是链接，当它有name时，它是链接的目标。</p>
<p>a标签和link标签一样也可以拥有rel属性：</p>
<ul>
<li><p>alternate</p>
</li>
<li><p>author</p>
</li>
<li><p>help</p>
</li>
<li><p>license</p>
</li>
<li><p>next</p>
</li>
<li><p>prev</p>
</li>
<li><p>search</p>
</li>
<li><p>tag</p>
<p>表示本网页所属的标签</p>
</li>
<li><p>bookmark</p>
<p>到上级章节的链接·</p>
</li>
<li><p>nofollow</p>
<p>此链接不会被搜索引擎索引</p>
</li>
<li><p>noopener</p>
<p>此链接打开的网页无法使用opener来获得当前页面的窗口</p>
</li>
<li><p>noreferrer</p>
<p>此链接打开的网页无法使用referrer来获得当前页面的url</p>
</li>
<li><p>opener</p>
<p>打开的网页可以使用 window.opener 来访问当前页面的 window 对象，这是 a 标签的默认行为</p>
</li>
</ul>
<h3 id="area标签"><a href="#area标签" class="headerlink" title="area标签"></a>area标签</h3><p>area标签和a标签类似，但它是区域型链接。area标签支持的rel与a标签一样，它是整个HTML规则中唯一支持非矩形热区的标签，它的shape属性支持三种类型：</p>
<ul>
<li><p>圆形</p>
<p>circle或circ，coords支持三个值，分别为中心点的x,y坐标和圆形半径r</p>
</li>
<li><p>矩形</p>
<p>rectangle或rect，coords支持两个值，分别为两个对角顶点坐标(x1,y1)和(x2,y2)</p>
</li>
<li><p>多边形</p>
<p>polygon或poly，coords至少包括6个值，表示多边形的各个顶点</p>
</li>
</ul>
<p>area标签必须跟img标签和map标签配合使用：这个例子展示了在一张图片上画热区并且产生链接，分别使用了矩形、圆形和多边形三种 area。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"> Please select a shape:</span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"shapes.png"</span> <span class="attr">usemap</span>=<span class="string">"#shapes"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">"Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star."</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"shapes"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">rect</span> <span class="attr">coords</span>=<span class="string">"50,50,100,100"</span>&gt;</span> <span class="comment">&lt;!-- the hole in the red box --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">rect</span> <span class="attr">coords</span>=<span class="string">"25,25,125,125"</span> <span class="attr">href</span>=<span class="string">"red.html"</span> <span class="attr">alt</span>=<span class="string">"Red box."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">circle</span> <span class="attr">coords</span>=<span class="string">"200,75,50"</span> <span class="attr">href</span>=<span class="string">"green.html"</span> <span class="attr">alt</span>=<span class="string">"Green circle."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">poly</span> <span class="attr">coords</span>=<span class="string">"325,25,262,125,388,125"</span> <span class="attr">href</span>=<span class="string">"blue.html"</span> <span class="attr">alt</span>=<span class="string">"Blue triangle."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">poly</span> <span class="attr">coords</span>=<span class="string">"450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">"yellow.html"</span> <span class="attr">alt</span>=<span class="string">"Yellow star."</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组去重的那些事</title>
    <url>/code/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
    <content><![CDATA[<blockquote>
<p>JS的数组去重是一道面试高频题，在团队最近一次的Code Review也遇到了相关问题，在此记录一下。</p>
</blockquote>
<a id="more"></a>

<h2 id="1-普通数组"><a href="#1-普通数组" class="headerlink" title="1. 普通数组"></a>1. 普通数组</h2><p>对于普通数组，我们很容易就能写出下面这种代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;numbers.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;numbers.length;j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[i] === numbers[j]) &#123;</span><br><span class="line">      number.splice(j, <span class="number">1</span>);</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路也很简单，就是使用双重for循环去遍历数组，时间复杂度为O(n2)。那么有没有稍微优雅一点的方法呢？看下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;numbers.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!res.includes(numbers[i])) &#123;</span><br><span class="line">     res.push(numbers[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是看起来要比之前的代码简短点？这里开辟了一个新的数组<code>res</code>，但数组的查找是O(n)的复杂度，所以这里的复杂度也是O(n2)。那有没有效率更高一点的方法呢？看下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;numbers.length<span class="number">-1</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!hash[numbers[i]]) &#123;</span><br><span class="line">     hash[numbers[i]] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">numbers = <span class="built_in">Object</span>.keys(hash);</span><br></pre></td></tr></table></figure>

<p>这里把数组换成了对象，对象的查找是O(1)的时间复杂度，所以这里的时间复杂度为O(n)。那么有没有更短一点的方法了呢？在ES6中我们可以使用<code>Set</code>数据结构来去重:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers = [...new <span class="built_in">Set</span>(numbers)];</span><br></pre></td></tr></table></figure>

<p>是不是更简洁呢？而且使用<code>Set</code>数据结构去重效率也更高。那既然上了ES6了，有没有其他方法呢？看下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用filter，去重的本质就是按照数据唯一的特点筛选数组，filter刚好可以筛选，所以与去重的行为是一致的</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.filter(<span class="function">(<span class="params">item, index, currentArr</span>) =&gt;</span> currentArr.indexOf(item) === index); <span class="comment">// 时间复杂度为O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在filter的基础上使用空间换时间的思想提高效率</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">numbers.filter(<span class="function"><span class="params">item</span> =&gt;</span> hash[item] ? <span class="literal">false</span> : hash[item] = <span class="literal">true</span>);  <span class="comment">// 时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用reduce去重，改自MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.includes(cur) ? pre : [...pre, cur], []);  <span class="comment">// 时间复杂度为O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在reduce的基础上使用空间换时间的思想提高效率</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">numbers.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> (hash[cur] || (hash[cur] = <span class="literal">true</span>) &amp;&amp; pre.push(cur), pre), []); <span class="comment">// 时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-复杂数组"><a href="#2-复杂数组" class="headerlink" title="2. 复杂数组"></a>2. 复杂数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用filter</span></span><br><span class="line"><span class="keyword">let</span> numbers = [&#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;];</span><br><span class="line">numbers.filter(<span class="function">(<span class="params">itemObj, index, currentArr</span>) =&gt;</span> currentArr.findIndex(<span class="function"><span class="params">itemObj2</span> =&gt;</span> itemObj2.user === itemObj.user) === index);  <span class="comment">// 时间复杂度为O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在filter的基础上使用空间换时间的思想提高效率</span></span><br><span class="line"><span class="keyword">let</span> numbers = [&#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">numbers.filter(<span class="function"><span class="params">item</span> =&gt;</span> hash[item.user] ? <span class="literal">false</span> : hash[item.user] = <span class="literal">true</span>);  <span class="comment">// 时间复杂度为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用reduce去重</span></span><br><span class="line"><span class="keyword">let</span> numbers = [&#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;];</span><br><span class="line">numbers.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.find(<span class="function"><span class="params">item</span> =&gt;</span> item.user === cur.user) ? pre : [...pre, cur], []);  <span class="comment">// 时间复杂度为O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在reduce的基础上使用空间换时间的思想提高效率</span></span><br><span class="line"><span class="keyword">let</span> numbers = [&#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">user</span>: <span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">numbers.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> (hash[cur.user] || (hash[cur.user] = <span class="literal">true</span>) &amp;&amp; pre.push(cur), pre), []); <span class="comment">// 时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的事件机制</title>
    <url>/code/JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<h4 id="1-ECMA的标准事件流"><a href="#1-ECMA的标准事件流" class="headerlink" title="1. ECMA的标准事件流"></a>1. ECMA的标准事件流</h4><p>ECMAScript的标准事件流共分为三个阶段: <strong>事件捕获阶段</strong>、<strong>处于目标阶段</strong>、<strong>事件冒泡阶段</strong>。</p>
<p>以下是一个简单的例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>点击按钮标准的事件触发分别经历以下三个阶段:</p>
<p><img src="https://images0.cnblogs.com/blog2015/697856/201504/080003152437715.png" alt="图片"></p>
<p>事件触发一次经历三个阶段，所以我们在一个元素上注册事件也就可以在对应阶段注册事件，移除事件一样。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准注册事件函数 target: 文档节点、document、window 或 XMLHttpRequest。type: 注册事件类型(不包含on)，listener: 事件的回调函数，useCapture:事件注册在捕获期间还是冒泡期间</span></span><br><span class="line">target.addEventListener(type, listener, useCapture); </span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：给button注册onclick事件，要是在捕获阶段注册</span></span><br><span class="line">button.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在某一个元素上撤销已注册的事件。 这里强调的是 这里的listener必须与已注册的listener是同一个</span></span><br><span class="line">target.removeEventListener(type, listener, useCapture);</span><br></pre></td></tr></table></figure>

<h4 id="2-IE中的事件流"><a href="#2-IE中的事件流" class="headerlink" title="2. IE中的事件流"></a>2. IE中的事件流</h4><p>IE中的事件是非标准的，总共分为两个阶段: <strong>处于目标阶段</strong>、<strong>冒泡阶段</strong>。</p>
<p>上面提到的例子在IE中执行时这样的:</p>
<p><img src="https://images0.cnblogs.com/blog2015/697856/201504/080003359931643.png" alt="图片"></p>
<p>IE中的事件注册与销毁事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IE注册事件函数 target: 文档节点、document、window 或 XMLHttpRequest。type: 注册事件类型(包含on) listener: 事件的回调函数 由于没有事件捕获阶段，所以没有useCapture参数</span></span><br><span class="line">target.attachEvent(type, listener);</span><br><span class="line"></span><br><span class="line">target.detachEvent(type,listener);   <span class="comment">//参数与注册参数相对应。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-事件的执行顺序"><a href="#3-事件的执行顺序" class="headerlink" title="3. 事件的执行顺序"></a>3. 事件的执行顺序</h4><p>一般事件的执行顺序： 事件的捕获阶段==&gt;处于目标阶段==&gt;事件的冒泡阶段==&gt;事件的默认行为</p>
<p>事件的默认行为是最后才执行的，所以我们可以阻止事件的默认行为。例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻止文本框获取焦点  </span></span><br><span class="line"><span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(<span class="string">"inputText"</span>);</span><br><span class="line">input.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event=event||<span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span>(event.preventDefault)&#123;  <span class="comment">//非IE浏览器阻止事件默认行为</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    event.returnValue=<span class="literal">false</span>; <span class="comment">//IE浏览器阻止事件默认行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-跨浏览器的注册事件"><a href="#4-跨浏览器的注册事件" class="headerlink" title="4. 跨浏览器的注册事件"></a>4. 跨浏览器的注册事件</h4><p>上面我们提到IE是非标准的事件流，所以要跨浏览器注册事件的话需要一些处理，下面是个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil =  &#123;</span><br><span class="line">  <span class="comment">//注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的冒泡阶段</span></span><br><span class="line">  addEventListener: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      <span class="comment">// 非IE</span></span><br><span class="line">      element.addEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      <span class="comment">// IE</span></span><br><span class="line">      element.attachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//撤销事件</span></span><br><span class="line">  removeEventListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-DOM事件"><a href="#5-DOM事件" class="headerlink" title="5. DOM事件"></a>5. DOM事件</h4><ul>
<li><p>DOM0级事件</p>
<p>javaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序的属性。这种为事件处理程序赋值的方法是在第四代Web浏览器中出现的，而且至今仍然为所有现在浏览器支持。原因主要有两点： <strong>简单</strong>、<strong>具有跨浏览器优势</strong>。 每个元素（window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如 onclick， onmousedown。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'click'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局限性: </p>
<p>1.某一个属性只能赋值给一个函数，也就导致在某一个元素上的某一个事件属性只能对应着一个函数。多次注册时，已最后一次注册为准。</p>
<p>2.DOM0级事件全部都是默认在冒泡阶段执行。</p>
</li>
<li><p>DOM2级事件</p>
<p>我们在上面定义的跨浏览注册事件函数，就是一个DOM2级注册事件。DOM2级注册事件相比于DOM0级的优势就在于其可以多次注册，并且执行顺序与注册顺序一致。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"1"</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"2"</span>);&#125;</span><br><span class="line">EventUtil.addEventListener(btn,<span class="string">"click"</span>,fun1);  <span class="comment">//注册第一个事件</span></span><br><span class="line">EventUtil.addEventListener(btn,<span class="string">"click"</span>,fun1); <span class="comment">//注册第二个事件，触发事件的时候会先弹出1在弹出2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-事件对象"><a href="#6-事件对象" class="headerlink" title="6.  事件对象"></a>6.  事件对象</h4><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有事件有关的信息。例如，单击事件中会包含鼠标的位置信息，键盘触发的事件中会包含按下的键位有关的信息。所有的浏览器都支持event，但支持的方式却有不同。</p>
<ul>
<li>标准浏览器中的事件对象             </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th align="center">类型</th>
<th align="center">读写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bubbles</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作</td>
</tr>
<tr>
<td>currentTarget</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回其事件监听器触发该事件的元素</td>
</tr>
<tr>
<td>eventPhase</td>
<td align="center">Intenger</td>
<td align="center">只读</td>
<td>返回事件传播的当前阶段</td>
</tr>
<tr>
<td>target</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回触发此事件的元素（事件的目标节点）</td>
</tr>
<tr>
<td>timeStamp</td>
<td align="center">Date</td>
<td align="center">只读</td>
<td>返回事件生成的日期和时间</td>
</tr>
<tr>
<td>type</td>
<td align="center">String</td>
<td align="center">只读</td>
<td>返回当前 Event 对象表示的事件的名称</td>
</tr>
<tr>
<td>trusted</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>该事件是否是浏览器生成(true代表是浏览器生成，false代表是开发人员创建)</td>
</tr>
<tr>
<td>preventDefault</td>
<td align="center">Function</td>
<td align="center">只读</td>
<td>取消事件的默认行为在<a href="http://www.w3school.com.cn/jsref/event_cancelable.asp" target="_blank" rel="noopener">cancelable</a>=true时有效</td>
</tr>
<tr>
<td>stopPropagation</td>
<td align="center">Function</td>
<td align="center">只读</td>
<td>取消事件的捕获或者冒泡行为在<a href="http://www.w3school.com.cn/jsref/event_bubbles.asp" target="_blank" rel="noopener">bubbles</a>=true时有效</td>
</tr>
</tbody></table>
<p>​        在事件处理程序内部，对象this始终指向currentTarget的值，而target则只包含事件的实际目标。</p>
<ul>
<li>IE中的事件对象           </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th align="center">类型</th>
<th align="center">读写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cancelBubble</td>
<td align="center">boolean</td>
<td align="center">读/写</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>returnValue</td>
<td align="center">boolean</td>
<td align="center">读/写</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作</td>
</tr>
<tr>
<td>srcElement</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>type</td>
<td align="center">String</td>
<td align="center">只读</td>
<td>被触发事件的类型</td>
</tr>
</tbody></table>
<p>  上面的这些属性，是任何一个事件均会具有的属性。</p>
<p>  在IE中有些srcElement对应着target;</p>
<p>  执行event.returnValue=false对应着event.preventDefault();</p>
<p>  执行event.cancelBubble=true对应着event.stopPropagation();</p>
<p>  同时对于一些相关属性IE 比如 relatedTarget属性对应IE中的fromElement和toElement.属性</p>
<ul>
<li><p>跨浏览器的事件对象</p>
<p>由于IE和标准的事件对象不一致，所以跨浏览器的事件对象需要做一些处理。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil =  &#123;</span><br><span class="line">  <span class="comment">//注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的捕获阶段</span></span><br><span class="line">  addEventListener: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//获取事件</span></span><br><span class="line">  getEvent:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event||<span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//获取事件的触发目标</span></span><br><span class="line">  getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target||event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//阻止事件的默认行为</span></span><br><span class="line">  preventDefault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.preventDefault?event.preventDefault():event.returnValue=<span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//阻止事件冒泡</span></span><br><span class="line">  stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.stopPropagation?event.stopPropagation:event.cancelBubble=<span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//撤销事件</span></span><br><span class="line">  removeEventListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个事件在其被触发时，都有一些其特有的属性，比如键盘事件会有键位信息，鼠标事件会有会有位置信息。onmouseenter事件会有fromElement(IE)中，relatedTarget(非IE);onmouseover事件会有toElement(IE)中，relatedTarget(非IE).</p>
</li>
</ul>
<h4 id="7-自定义事件"><a href="#7-自定义事件" class="headerlink" title="7. 自定义事件"></a>7. 自定义事件</h4><ul>
<li><p>模拟鼠标事件</p>
<p>非IE浏览器</p>
<p>创建鼠标事件的方法是createEvent()传入字符串“MouseEvent”.返回的对象有initMouseEvent()方法,这个方法有15个参数，分别与鼠标事件中某个典型的属性一一对应。               </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”click”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>抽象视图：事件授予的视图，这个值几乎全是document.defaultView.</td>
</tr>
<tr>
<td>detail</td>
<td align="center">Intenger</td>
<td>附加的事件信息这个初始化时一般应该默认为0。</td>
</tr>
<tr>
<td>screenX</td>
<td align="center">Intenger</td>
<td>事件距离屏幕左边的X坐标</td>
</tr>
<tr>
<td>screenY</td>
<td align="center">Intenger</td>
<td>事件距离屏幕上边的y坐标</td>
</tr>
<tr>
<td>clientX</td>
<td align="center">Intenger</td>
<td>事件距离可视区域左边的X坐标</td>
</tr>
<tr>
<td>clientY</td>
<td align="center">Intenger</td>
<td>事件距离可视区域上边的y坐标</td>
</tr>
<tr>
<td>ctrlKey</td>
<td align="center">Boolean</td>
<td>代表ctrol键是否被按下，默认为false。</td>
</tr>
<tr>
<td>altKey</td>
<td align="center">Boolean</td>
<td>代表alt键是否被按下，默认为false。</td>
</tr>
<tr>
<td>shiftKey</td>
<td align="center">Boolean</td>
<td>Boolean类型 ： 代表shif键是否被按下，默认为false</td>
</tr>
<tr>
<td>metaKey</td>
<td align="center">Boolean</td>
<td>代表meta key 是否被按下，默认是false</td>
</tr>
<tr>
<td>button</td>
<td align="center">Intenger</td>
<td>表示被按下的鼠标键，默认是零</td>
</tr>
<tr>
<td>relatedTarget</td>
<td align="center">Elment</td>
<td>事件的关联对象只有在模拟mouseover 和 mouseout时用到</td>
</tr>
<tr>
<td>使用方法：</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEvent(<span class="string">"MouseEvent"</span>);</span><br><span class="line">    event.initMouseEvent(<span class="string">"click"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line">btn.dispatchEvent(event);  <span class="comment">//在这一步会设置event.target,以及触发事件类型</span></span><br></pre></td></tr></table></figure>

<p>  IE浏览器</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEventObject();</span><br><span class="line">event.screenX=<span class="number">100</span>;</span><br><span class="line">event.screenY=<span class="number">100</span>;</span><br><span class="line">event.clientX=<span class="number">100</span>;</span><br><span class="line">event.clientX=<span class="number">100</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">btn.fireEvent(<span class="string">"onclick"</span>,event);   <span class="comment">//在这一步会设置event.serElement,以及触发事件类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>模拟键盘事件</p>
<p> 键盘模拟事件是在DOM3规范中定义的。火狐浏览器根据草案定义了DOM2级中模拟键盘事件。在这里，我们讲述的是DOM3级规范，DOM3级不提倡使用oneypress事件。</p>
<p> DOM3标准</p>
<p> 创建键盘事件的方法是createEvent()传入字符串“KeyboardEvent”.返回的对象有initKeyEvent()方法,这个方法有以下参数：           </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>被授予事件的是图. 通常值为：document.defaultView.</td>
</tr>
<tr>
<td>key</td>
<td align="center">string</td>
<td>按下的键对应的code.</td>
</tr>
<tr>
<td>location</td>
<td align="center">integer</td>
<td>按下键所在的位置. 0 ：默认键盘, 1 左侧位置, 2 右侧位置, 3 数字键盘区, 4 虚拟键盘区, or 5 游戏手柄.</td>
</tr>
<tr>
<td>modifiers</td>
<td align="center">Boolean</td>
<td>一个有空格分开的修饰符列表.</td>
</tr>
<tr>
<td>repeat</td>
<td align="center">integer</td>
<td>一行中某个键被按下的次数</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox=<span class="built_in">document</span>.getElementById(<span class="string">"myTextBox"</span>),event;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"KeyboardEvent"</span>,<span class="number">3.0</span>))&#123;</span><br><span class="line">  event=<span class="built_in">document</span>.createEvent(<span class="string">"KeyboardEvent"</span>);</span><br><span class="line">  event.initKeyboardEvent(<span class="string">"keydown"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="string">"a"</span>,<span class="number">0</span>,<span class="string">"shift"</span>,<span class="number">0</span>);</span><br><span class="line">  textbox.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并非所有的浏览器都实现了DOM3标准，下面看一下各个浏览器时怎么模拟鼠标事件。 </p>
<p>  <strong>FireFox浏览器</strong></p>
<pre><code>在FireFox中，调用createEvent()并传入KeyEvents就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接受以下10个参数：          </code></pre><table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>被授予事件的是图. 通常值为：document.defaultView.</td>
</tr>
<tr>
<td>ctrlKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了ctrl键位，默认值 false.</td>
</tr>
<tr>
<td>altKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了altl键位，默认值 false</td>
</tr>
<tr>
<td>shiftKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了shift键位，默认值 false.</td>
</tr>
<tr>
<td>metaKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了meta键位，默认值 false.</td>
</tr>
<tr>
<td>KeyCode</td>
<td align="center">Intenger</td>
<td>被按下或者被释放的键位. 这个参数对keydown和keyup有用</td>
</tr>
<tr>
<td>charCode</td>
<td align="center">Intenger</td>
<td>通过按键生成的ASCII编码. 这个参数对keypress有用</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只适用于FireFox浏览器，在火狐浏览器中会在文本框中显示A </span></span><br><span class="line"><span class="keyword">var</span> textbox=<span class="built_in">document</span>.getElementById(<span class="string">"myTextBox"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span>  event=<span class="built_in">document</span>.createEvent(<span class="string">"keyEvents"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initKeyEvent(<span class="string">"keypress"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">65</span>,<span class="number">65</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>  <strong>非火狐非IE浏览器</strong> 在其他浏览器中，则需要创建一个通用事件，然后再向通用事件中添加键盘事件的特有信息。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在其他浏览器中不能输入文本，这是因为非浏览器创建的事件并不能精确的模拟事件。</span></span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span>  event=<span class="built_in">document</span>.createEvent(<span class="string">"Events"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initEvent(type,bubble,cancelable);</span><br><span class="line"><span class="comment">//初始化事件信息</span></span><br><span class="line">event.view=<span class="built_in">document</span>.defaultView;</span><br><span class="line">event.altKey=<span class="literal">false</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">event.keyCode=<span class="number">65</span>;</span><br><span class="line">event.charCode=<span class="number">65</span>;</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>  <strong>IE浏览器</strong>  IE浏览器创建键盘事件和创建鼠标事件有点类似。如下所示：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEventObject();</span><br><span class="line">event.altKey=<span class="literal">false</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">event.shiftKey=<span class="literal">false</span>;</span><br><span class="line">event.keyCode=<span class="number">65</span>;</span><br><span class="line">textbox.fireEvent(<span class="string">"onkeydown"</span>,event);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义DOM事件</p>
<p>DOM3级还定义了”自定义事件”。自定义事件不同时DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件；</p>
<p> <strong>非IE浏览器</strong> 可以调用createEvent(“CustomEvent”)返回的对象有一个名为initCustomEvent()方法，接受如下四个参数:          </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>detail</td>
<td align="center">Boolean</td>
<td>保存在event对象的detail属性中</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"inputText"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(<span class="string">"inputText"</span>);</span></span><br><span class="line"><span class="actionscript">      EventUtil.addEventListener(input,<span class="string">"myevent"</span>,<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line">        event=EventUtil.getEvent(event);</span><br><span class="line"><span class="actionscript">        alert(event.detail.message);   <span class="comment">//访问detail中的信息</span></span></span><br><span class="line"><span class="actionscript">      &#125;);<span class="comment">//注册时事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span>  button=<span class="built_in">document</span>.getElementById(<span class="string">"button"</span>);</span></span><br><span class="line"><span class="actionscript">      button.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CustomEvents"</span>,<span class="string">"3.0"</span>))&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> event=<span class="built_in">document</span>.createEvent(<span class="string">"CustomEvent"</span>);</span></span><br><span class="line"><span class="actionscript">          event.initCustomEvent(<span class="string">"myevent"</span>,<span class="literal">true</span>,<span class="literal">false</span>,&#123;message:<span class="string">"helloworld"</span>&#125;);</span></span><br><span class="line">          input.dispatchEvent(event);</span><br><span class="line"><span class="actionscript">        &#125; <span class="comment">//通过button按钮触发事件</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  IE浏览器自定义事件</p>
<p>   IE中document.createEventObject()方法不支持自定义的DOM事件。我们在有些前端框架中之所有能够实现自定义事件的各种浏览器兼容都是因为他们内部重写了一套事件机制来控制，才使得我们可以在各个浏览器上自定义事件。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的防抖和节流</title>
    <url>/code/JS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html</url>
    <content><![CDATA[<h2 id="JS的防抖和节流"><a href="#JS的防抖和节流" class="headerlink" title="JS的防抖和节流"></a>JS的防抖和节流</h2><blockquote>
<p>前几天在面试的过程中有被问到在监听input输入事件向后台传递数据的时候要怎么优化，由于之前并没有关注性能这一块儿的问题(之前在学redis的时候有了解过使用redis做cache)于是就胡乱答了使用缓存。然后面试官前辈就提示我可以使用JS中的防抖(PS:面试全程非常nice，有回答不对的地方面试官都给我做了指正，感觉就像是在和前辈讨论技术问题)，之后我也有查阅相关资料，今天我们就来讨论一下防抖和节流</p>
</blockquote>
<a id="more"></a>
<h4 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a>1. 防抖</h4><ul>
<li><p>含义:</p>
<p>防抖，即在某一段时间内函数只执行一次，如果在这一段时间内又触发了该时间则会重新计算函数的执行时间</p>
</li>
<li><p>举个例子:</p>
<p>比如有个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要把这个函数绑定到window.onkeypress事件上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onkeypress = print</span><br></pre></td></tr></table></figure>

<p>现在每按一下键盘按键都会打印出”hello”，然后我们对其改装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; func() &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将shake这个函数绑定到window.onkeypress事件上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onkeypress = shake(print, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们再试试，发现在一个时间段内按压多个按键的时候只打印了一次”hello”，这就是一个简单的防抖实现</p>
</li>
<li><p>类型:</p>
<ul>
<li><p>延迟执行版</p>
<p>在上面的例子中我们简单实现了一个延迟执行的防抖函数，但还没有完全实现，我们还没有将事件的参数传进去，下面我们将其补充完整:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; func.apply(<span class="keyword">this</span>, args) &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用apply方法指定函数的执行上下文(this)和参数,该版本不会立即执行函数，而是在触发事件一段时间后再去执行该函数，如果在这段时间内又触发了时间则会重新计算时间</p>
</li>
<li><p>立即执行版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    <span class="keyword">let</span> call = !timeout</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, time)</span><br><span class="line">    <span class="keyword">if</span> (call) func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该版本在事件触发后会立即执行，经过一段时间不触发事件后才能继续执行</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-节流"><a href="#2-节流" class="headerlink" title="2. 节流"></a>2. 节流</h4><ul>
<li><p>含义</p>
<p>连续触发事件但是在一段时间内只执行一次函数。节流会稀释函数的执行频率。</p>
</li>
<li><p>版本</p>
<ul>
<li><p>时间戳版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> then = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (now - then &gt; time) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      then = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      	timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>以上我们就简单的实现了一下防抖和节流，又get到了一个点，在这里还是很感谢那位前辈的。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS日期的那些事儿</title>
    <url>/code/JS%E6%97%A5%E6%9C%9F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html</url>
    <content><![CDATA[<blockquote>
<p>ECMAScript的日期参考了Java早期版本中的java.util.Date的设计，但由于浏览器对于Date的实现方式不一致导致了一些列的问题。</p>
</blockquote>
<a id="more"></a>

<h3 id="1-认识UTC与GMT"><a href="#1-认识UTC与GMT" class="headerlink" title="1. 认识UTC与GMT"></a>1. 认识UTC与GMT</h3><p><strong>协调世界时</strong>(英: <strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime  法: <strong>T</strong>emps <strong>U</strong>niversel <strong>C</strong>oordonné，作为英语和法语的妥协简称为<strong>UTC</strong>)，其在时刻上尽量接近于格林威治标准时间(GMT)。该时间系统被广泛用于互联网和万维网的标准中，如网络时间协议(<strong>N</strong>etwork <strong>T</strong>ime <strong>P</strong>rotocol <strong>NTP</strong>)就是协调世界时在互联网汇中使用的一种方式。PS: 如果本地时间比UTC时间快，例如中国大陆的时间比UTC快8小时，就会写作UTC+8，俗称东八区。</p>
<p><strong>格林威治标准时间</strong>（<strong>G</strong>reenwich <strong>M</strong>ean <strong>T</strong>ime）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被协调世界时取代。</p>
<h3 id="2-ECMAScript中的Date对象"><a href="#2-ECMAScript中的Date对象" class="headerlink" title="2. ECMAScript中的Date对象"></a>2. ECMAScript中的Date对象</h3><p>ECMAScript中的Date对象记录的是从1970年1月1日(UTC)到现在所经过的毫秒数，虽然其核心时间值是UTC，但获取基本日期和时间的基本方法都是在本地时区和偏移量下工作的。需要注意的是，最大日期和最大安全整数不同(Number.MAX_SAFE_INTEGER为9,007,199,254,740,991而日期的范围为±8,640,000,000,000,000毫秒)。</p>
<p>以一个函数的形式来调用Date对象，会返回一个代表当前日期和时间的字符串。</p>
<ul>
<li><p>构造函数</p>
<p>Date对象的构造函数有四种基本形式：</p>
<ol>
<li>没有参数: 如果没有提供参数，返回当前时刻的日期和时间。</li>
<li>UNIX时间戳：表示1970年1月1日00:00:00(UTC)以来的毫秒数</li>
<li>时间戳字符串：表示日期的字符串，应符合RFC2822或ISO8601的格式。由于浏览器之间的差异性，不推荐使用该方法解析日期字符串(在ISO8601中，只有日期会被处理为UTC时间)</li>
<li>分别提供日期与时间的每一个成员。<ul>
<li>year: 表示年份的整数值，0-99会被映射至1900年-1999年，其他值代表实际年份。</li>
<li>monthIndex: 表示月份的整数值，从0(1月)到11(12月)</li>
<li>date: 表示一个月中的第几天的整数值，从1开始，默认为1</li>
<li>hours: 表示一天中的小时数的整数值(24小时制)，默认为0</li>
<li>minutes: 表示一个完整的时间中的分钟部分的整数值，默认为0</li>
<li>seconds: 表示一个完整时间中的秒钟部分的整数值，默认为0</li>
<li>Milliseconds: 表示一个完整时间中的毫秒部分的整数值，默认为0</li>
</ul>
</li>
</ol>
</li>
<li><p>解析时间字符串</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码摘自Dayjs</span></span><br><span class="line"><span class="keyword">const</span> parseDate = <span class="function">(<span class="params">cfg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; date, utc &#125; = cfg</span><br><span class="line">  <span class="keyword">const</span> isUndefined = <span class="function"><span class="params">s</span> =&gt;</span> s === <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (date === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="literal">NaN</span>) <span class="comment">// null is invalid</span></span><br><span class="line">  <span class="keyword">if</span> (isUndefined(date)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// today</span></span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> date === <span class="string">'string'</span> &amp;&amp; !<span class="regexp">/Z$/i</span>.test(date)) &#123;</span><br><span class="line">    <span class="keyword">const</span> d = date.match(<span class="regexp">/^(\d&#123;4&#125;)[-/]?(\d&#123;1,2&#125;)?[-/]?(\d&#123;0,2&#125;)[^0-9]*(\d&#123;1,2&#125;)?:?(\d&#123;1,2&#125;)?:?(\d&#123;1,2&#125;)?.?(\d+)?$/</span>)</span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">      <span class="keyword">const</span> m = d[<span class="number">2</span>] - <span class="number">1</span> || <span class="number">0</span></span><br><span class="line">      <span class="keyword">const</span> ms = (d[<span class="number">7</span>] || <span class="string">'0'</span>).substring(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span> (utc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(d[<span class="number">1</span>], m, d[<span class="number">3</span>]</span><br><span class="line">          || <span class="number">1</span>, d[<span class="number">4</span>] || <span class="number">0</span>, d[<span class="number">5</span>] || <span class="number">0</span>, d[<span class="number">6</span>] || <span class="number">0</span>, ms))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(d[<span class="number">1</span>], m, d[<span class="number">3</span>]</span><br><span class="line">          || <span class="number">1</span>, d[<span class="number">4</span>] || <span class="number">0</span>, d[<span class="number">5</span>] || <span class="number">0</span>, d[<span class="number">6</span>] || <span class="number">0</span>, ms)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date) <span class="comment">// everything else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置Vue前后端分离项目</title>
    <url>/code/Nginx%E9%85%8D%E7%BD%AEVue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE.html</url>
    <content><![CDATA[<h4 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h4><p>项目后端采用Node.js提供RESTful API服务，监听3000端口。项目前端采用Vue，打包好的dist文件夹路径为<strong>/root/vue/</strong>。使用Nginx做反向代理实现前后端分离。</p>
<a id="more"></a>
<h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><h5 id="1-配置后端"><a href="#1-配置后端" class="headerlink" title="1. 配置后端"></a>1. 配置后端</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">upstream</span> node.server &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:3000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api/ &#123;</span><br><span class="line">  <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">  <span class="attribute">proxy_pass_header</span> Server;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://node.server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-配置前端"><a href="#2-配置前端" class="headerlink" title="2. 配置前端"></a>2. 配置前端</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  <span class="attribute">alias</span> /root/project/register/app/views/;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrites</span>;    <span class="comment"># 尝试访问资源，若无资源则重定向至index.html</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="variable">@rewrites</span> &#123;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /index.html <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-配置HTTPS"><a href="#3-配置HTTPS" class="headerlink" title="3. 配置HTTPS"></a>3. 配置HTTPS</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> cert/****_bundle.crt;    <span class="comment"># bundle.crt路径</span></span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> cert/***<span class="regexp">*.key</span>;       <span class="comment"># ****.key路径</span></span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNUL$</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-配置HTTP跳转HTTPS"><a href="#4-配置HTTP跳转HTTPS" class="headerlink" title="4. 配置HTTP跳转HTTPS"></a>4. 配置HTTP跳转HTTPS</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> iot.musiiot.top;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>serverless给前端带来的技术变革</title>
    <url>/%E5%AD%A6%E4%B9%A0/serverless%E7%BB%99%E5%89%8D%E7%AB%AF%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8F%98%E9%9D%A9.html</url>
    <content><![CDATA[<blockquote>
<p>Serverless Compute是指构建和运行不需要服务器管理的应用程序的概念。它描述了一种更细粒度的部署模型，应用程序捆绑一个或多个function(FaaS)，上传到平台，然后执行，伸缩和计费，以响应当前所需的确切需求。 —— 《CNCF Serverless White Paper》</p>
</blockquote>
<a id="more"></a>

<h2 id="什么是serverless"><a href="#什么是serverless" class="headerlink" title="什么是serverless"></a>什么是serverless</h2><ol>
<li>狭义上的serverless = FaaS + BaaS，由serverless白皮书1.0提出，是目前serverless的最佳实践。<ul>
<li>FaaS(stateless): 函数即服务，采用EDD(Event Drive Development)的方式运行和管理代码，函数作为开发者部署程序的最小单元，无需关注服务器甚至是技术栈即可对其进行扩展。</li>
<li>BaaS(stateful): 后端即服务，基于第三方API的服务。可代替应用程序的核心功能。</li>
</ul>
</li>
<li>广义上的serverless，指的是开发者不需要过多的关注服务器的平台和运维，让开发者专注于业务开发的一种云计算模式。由于这种模式服务器对开发者是透明的所以又被翻译成无服务器。</li>
</ol>
<h2 id="为什么是前端"><a href="#为什么是前端" class="headerlink" title="为什么是前端"></a>为什么是前端</h2><p>近年来前端生态圈的迅速发展，前端这个职业也在快速发展。从一开始的“切图仔”到服务于后端的模板再到前后端分离专注于用户交互的开发方式，Node.js的出现让前端开发者拥有了部分后端的能力，DevOps概念的提出前端也开始介入部分运维的工作。一职多能已是前端这个职业的趋势。</p>
<h2 id="serverless给前端带来了什么"><a href="#serverless给前端带来了什么" class="headerlink" title="serverless给前端带来了什么"></a>serverless给前端带来了什么</h2><ol>
<li><p>赋能前端</p>
<p>进一步降低后端的门槛，使得前端可以更多的参与业务交付，同时也提升了前端的发展空间。</p>
</li>
<li><p>研发提效</p>
<p>采用云端一体化的方式进行研发，相比于传统的前后端分离的方式进行开发、发布，能极大提高项目的开发和交付速度。</p>
</li>
<li><p>弱化运维</p>
<p>开发者基本不再需要关注服务器，不再需要考虑流量、并发等一系列问题，减少前端的学习和开发成本。</p>
</li>
</ol>
<h2 id="serverless是未来？未来已来"><a href="#serverless是未来？未来已来" class="headerlink" title="serverless是未来？未来已来!"></a>serverless是未来？未来已来!</h2><ol>
<li><p>serverless发展历程:</p>
<p>2012年  Iron.io的副总裁Ken首次提出serverless的概念</p>
<p>2014年 AWS率先推出Lambda即函数计算</p>
<p>2017年 各大云厂商纷纷实现serverless，并各自推出自己的serverless框架</p>
<p>2018年 微信小程序率先推出云开发，打造云端一体化的开发方式。腾讯用微信周边生态将serverless技术大规模落地，随后各大厂商纷纷效仿，现在云开发几乎已成小程序的标配。</p>
</li>
</ol>
<img src="https://upload-images.jianshu.io/upload_images/2509688-86d4747424b11cfc.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt="云计算发展历程" style="zoom:200%;" />

<ol start="2">
<li><p>云计算的发展历程:</p>
<p>IDC → IaaS(基础设施即服务) → PaaS(平台即服务) → Serverless(无服务器计算)</p>
<p>从IDC → IaaS，用户不用关注真实的物理资源。</p>
<p>从IaaS → PaaS，用户不再关注操作系统，数据库，中间件等基础软件。</p>
<p>从PaaS → serverless, 用户可以很少甚至不用关注backend，app可以简化为一个单页面程序。</p>
</li>
</ol>
<h2 id="serverless的优势"><a href="#serverless的优势" class="headerlink" title="serverless的优势"></a>serverless的优势</h2><ul>
<li><p>低成本</p>
<ul>
<li>开发成本: 开发者直接调用的是服务化的组件，如对象存储，授权服务等，可以缩短开发周期，降低开发难度。</li>
<li>运维成本: 用户的服务器、数据库将被托管至云厂商，用户将不再参与基础设施及软件的维护。</li>
</ul>
</li>
<li><p>按需付费</p>
<p>按请求次数及运行时间和cpu算力进行收费，不调用不收费。</p>
</li>
<li><p>高扩展</p>
<p>拥有完全自动的、有弹性的、且由服务提供者所管理扩展方式。</p>
</li>
<li><p>NoOps</p>
<p>开发者只需关注自身业务不需要关注服务器的运维。</p>
</li>
</ul>
<h2 id="软件开发没有银弹——serverless的不足"><a href="#软件开发没有银弹——serverless的不足" class="headerlink" title="软件开发没有银弹——serverless的不足"></a>软件开发没有银弹——serverless的不足</h2><ul>
<li>与云厂商绑定 每个云厂商的serverless框架实现方式并不统一，迁移比较困难。</li>
<li>相较于传统开发增加了冷启动耗时。</li>
<li>开发生态还不完善，缺少好用的开发和调试工具。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块</title>
    <url>/wiki/JavaScript%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promises</title>
    <url>/wiki/Promises.html</url>
    <content><![CDATA[<h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>不同于之前的回调函数，在使用Promise时会有以下约定：</p>
<ol>
<li>在本轮事件循环运行完成之前，回调函数是不会调用的</li>
<li>即使异步操作操作已经完成(成功或失败)，在这时候通过<code>then()</code>添加的回调函数也会被调用</li>
<li>通过多次<code>then()</code>可以添加多个回调函数，他们会按照插入顺序执行</li>
</ol>
<p>Promise支持链式调用。</p>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>通过创造一个Promise链来实现连续执行两个或者多个异步操作，在上一个操作执行成功之后，待着上一个操作返回的结果开始下一个的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">P<span class="comment">// then()函数会返回一个和原来不同的新的Promise</span></span><br><span class="line"><span class="keyword">const</span> promise = doSomething();</span><br><span class="line"><span class="keyword">const</span> promise2 = peomise.then(successCallBack, failureCallback);    <span class="comment">// promise2不仅代表着doSomething函数的完成，也代表了成功或者失败的回调函数的完成。每个promise都代表了链中另一个异步过程的完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调地域</span></span><br><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">thirdResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(thirdResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise链式调用</span></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);    <span class="comment">// 一定要有返回值callback才能获取上一个Promise的结果</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">ThirdReult</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ThirdReult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);    <span class="comment">// then里的参数是可选的  .catch(failureCallback)是.then(null, failureCallback)的缩略形式。</span></span><br></pre></td></tr></table></figure>

<h5 id="catch的后续链式操作"><a href="#catch的后续链式操作" class="headerlink" title="catch的后续链式操作"></a>catch的后续链式操作</h5><p>有可能会在一个回调失败之后继续使用链式操作，即使用一个<code>catch()</code>。这对于在链式操作中抛出一个错误之后再次进行新的操作会很有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'init...'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'出错之后发生的'</span>);    <span class="comment">// 永远不会执行</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到错误了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'无论有没有错都会执行'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="错误传递"><a href="#错误传递" class="headerlink" title="错误传递"></a>错误传递</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Promise链中错误回调只有尾部的一次调用</span></span><br><span class="line"><span class="comment">// 一遇到异常抛出，浏览器就会顺着Promise链寻找下一个onRejected失败回调函数或者由catch指定的回调函数</span></span><br><span class="line">doSomething()</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> doSometingElse(result));</span><br><span class="line">.then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult));</span><br><span class="line">.then(<span class="function"><span class="params">ThirdResult</span> =&gt;</span> <span class="built_in">console</span>.log(ThirdResult));</span><br><span class="line">.catch(failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过程类似于下面的同步代码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = syncDoSomething();</span><br><span class="line">  <span class="keyword">let</span> newResult = syncDoSomrthingElse(result);</span><br><span class="line">  <span class="keyword">let</span> ThirdResult = syncDoThirdThing(newResult);</span><br><span class="line">  cosole.log(ThirdResult);</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  failureCallback(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ECMAScript2017中，可以使用async/await语法糖</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> doSomething();</span><br><span class="line">    <span class="keyword">let</span> newResult = <span class="keyword">await</span> doSomrthingElse(result);</span><br><span class="line">    <span class="keyword">let</span> ThirdResult = <span class="keyword">await</span> doThirdThing(newResult);</span><br><span class="line">    cosole.log(ThirdResult);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    failureCallback(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Promise拒绝事件"><a href="#Promise拒绝事件" class="headerlink" title="Promise拒绝事件"></a>Promise拒绝事件</h4><p>当Promise被拒绝时，会将<code>rejectionhandled</code>(提供<code>reject</code>函数)或<code>unhandledrejection</code>(没有提供<code>reject</code>函数)派发到全局作用域(通常是window)。</p>
<p><code>PromiseRejectionEvent</code>事件通常有两个属性：<code>promise</code>和<code>resson</code>。<code>promise</code>属性指向被驳回的Promise，<code>reason</code>属性用来说明Promise被驳回的原因。在每一个上下文中，该处理都是全局的，所有的错误都会在同一个handle中被捕捉处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, event =&gt; &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h4 id="在旧式回调API中创建Promise"><a href="#在旧式回调API中创建Promise" class="headerlink" title="在旧式回调API中创建Promise"></a>在旧式回调API中创建Promise</h4><p>可以通过Promise的构造器从零开始创建<code>Promise</code>。该方式应当只在包裹旧API的时候用到。理想状态下，所有的异步函数都已经返回Promise了。但一些API仍使用旧方式来传入成功或失败的回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> doSomething(), <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>混用旧式回调和Promise可能会造成运行时序的问题，如果<code>doSomething</code>函数抛出异常，那就没办法捕获它了。</p>
<p>可以使用Promise来包裹它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">wait(<span class="number">10000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> doSomething()).catch(failureCallback);</span><br></pre></td></tr></table></figure>

<p>通常Promise的构造器只接受一个执行函数，可以在这个函数里手动的resolve和reject一个Promise。</p>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p><code>Promise.resolve()</code>和<code>Promise.reject()</code>是手动创建一个已经resolve或者reject的Promise快捷方法。<code>Promise.all()</code>和<code>Promise.race()</code>是并行运行异步操作的两个组合式工具。可以发起并行操作，然后等多个操作全部结束后进行下一个操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([func1(), func2()]).then(<span class="function">(<span class="params">[res1, res2]</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(res1, res2)&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以使用一些JavaScript写法实现时序组合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[func1(), func2(), func3()].reduce(<span class="function">(<span class="params">p, f</span>) =&gt;</span> p.then(f), <span class="built_in">Promise</span>.resolve()).then(<span class="function"><span class="params">res3</span> =&gt;</span> <span class="built_in">console</span>.log(res3));</span><br></pre></td></tr></table></figure>

<p>通常递归调用一个由异步函数组成的数组时相当于一个Promise链：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(func1).then(func2).then(func3);</span><br></pre></td></tr></table></figure>

<p>也可以写成可复用的函数形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> applyAsync = <span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.then(val);</span><br><span class="line"><span class="keyword">const</span> composeAsync = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> funcs.reduce(applyAsync, <span class="built_in">Promise</span>.resolve(x));</span><br></pre></td></tr></table></figure>

<p><code>composeAsync</code>函数接受任意数量的函数作为参数，并返回一个新的函数，该函数接收一个通过composition pipeline传入的初始值，它们能确保按顺序执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transformData = composeAsync(fun1, fun2, fun3);</span><br><span class="line"><span class="keyword">const</span> result3 = transformData(data);</span><br></pre></td></tr></table></figure>

<p>在ECMAScript2017中，时序组合可以使用<code>async/await</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> f <span class="keyword">of</span> [func1, func2, func3]) &#123;</span><br><span class="line">  result = <span class="keyword">await</span> f(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h4><p>为了避免意外，即使是一个已经变成resolve状态的Promise。传递给<code>then</code>函数也总会被异步调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);    <span class="comment">// 2, 1</span></span><br></pre></td></tr></table></figure>

<p>传递给<code>then</code>中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在JavaScript事件队列的所有运行时结束了事件队列被清空之后才会执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">wait().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);    <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>嵌套Promise是一种可以限制<code>catch</code>语句作用域的控制结构。准确来说，嵌套的<code>catch</code>仅捕获在其之前同时还必须是其作用域的异常，而不捕获嵌套之外的或者在其链式以外的异常：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> doSomething1()</span><br><span class="line">      .then(<span class="function"><span class="params">result1</span> =&gt;</span> <span class="built_in">console</span>.log(result1))</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">     )</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> doSomething2())</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e.message))；    <span class="comment">// 不会输出</span></span><br></pre></td></tr></table></figure>





<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的前世今生</title>
    <url>/wiki/JavaScript%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html</url>
    <content><![CDATA[<h2 id="JavaScript简史"><a href="#JavaScript简史" class="headerlink" title="JavaScript简史"></a>JavaScript简史</h2><ul>
<li>JavaScript由Brendan Eich发明，并首次应用于Netscape Navigator 2浏览器中。当时命名为LiveScript，为了赶Java的热度，后改名为JavaScript。当时它的主要目的用于验证表单数据(当时网速的限制了与服务端的交互速度)。</li>
<li>微软在IE3中加入了名为JScript的JavaScript实现。</li>
<li>由于当时并没有标准规定JavaScript的语法和特性，从而导致两个不同版本的JavaScript并存。于是在1997年，以JavasScript1.1为蓝本的建议被提交给了ECMA(欧洲计算机制造商协会)。该协会指定TC39(39号技术委员会)负责，于是出现了名为ECMAScript的语言标准(EMNA-262)，同年年底，ECMAScript1.0发布。</li>
<li>1998年6月ECMA发布ECMAScript2.0，该版主要是为了与ISO/IEC-16262保持严格一致，没有作任何新增、修改或删除处理。</li>
<li>1999年12月，ECMAScript发布ECMAScript3.0，修改的内容涉及字符串处理、错误定义和数值输出，新增了对正则表达式、新控制语句和try-catch异常处理的支持。ECMAScript3.0标志着ECMAScript成为了一门真正的编程语言。</li>
<li>2000年，ECMAScript4.0开始着手实现，但由于该版本改动幅度较大(包含强类型变量、新语句和新数据结构、真正的类和经典继承，还定义了与数据交互的新方式)，TC39下属的一个小组提出了一个名为ECMAScript3.1的替代性建议，ECMAScript3.1只进行小幅修订，能够在现有的JavaScript引擎基础上实现。最终ECMAScript4.0被放弃，ECMAScript3.1成为ECMAScript5.0并于2009年12月发布。ECMAScript5新增原生JSON对象(用于解析和序列化JSON数据)、继承的方法和高级属性定义，另外还包含一种严格模式。</li>
<li>2011年6月，ECMAScript5.1版发布，成为国际标准。</li>
<li>2015年6月，ECMAScript6版发布，成为国际标准。</li>
</ul>
<h2 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h2><p>虽然JavaScript和ECMAScript通常都被人们用来表达相同的含义，但JavaScript的含义要比ECMAScript多得多。一个完整的JavaScript应该有以下三个部分组成：</p>
<ul>
<li>语法和语义(ECMAScript)</li>
<li>文档对象模型(DOM)</li>
<li>浏览器对象模型(BOM)</li>
</ul>
<h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4><p>ECMAScript与web浏览器没有依赖关系，实际上ECMAScript定义的只是这门语言的基础，在此基础之上可以构建更完善的脚本语言。web浏览器只是ECMAScript实现可能的宿主环境之一。宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与环境之间进行交互。其他宿主环境包括Node和Adobe Flash。ECMAScript就是对实现该标准规定的各个方面内容的语言的描述。除了JavaScript，Adobe ActionScript也实现了ECMAScript。      </p>
<p>ECMA-262标准规定了这门语言的下列组成部分：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象</li>
</ul>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型(Document Object Model)是针对XML但经过扩展用于HTML的API。DOM把整个页面映射为一个多层节点结构。由于IE4和Netscape navigator4分别支持不同形式的DHTML(Dynamic HTML)导致web跨平台的天性受到影响，于是负责Web通信标准的W3C(World Wide Web Consortium,万维网联盟)开始着手规划DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在DOM中，上面的代码可以通过下面的分层节点图表示。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/节点图.png" alt="节点图" style="zoom:50%;" />

<h5 id="DOM1级"><a href="#DOM1级" class="headerlink" title="DOM1级"></a>DOM1级</h5><p>DOM1级(DOM Level 1)在1998年10月成为W3C的推荐标准，由DOM核心(DOM Core)和DOM HTML两个模块组成。DOM核心规定如何映射基于XML的文档结构，DOM HTML添加了针对HTML的对象和方法。</p>
<h4 id="DOM2级"><a href="#DOM2级" class="headerlink" title="DOM2级"></a>DOM2级</h4><p>DOM2级在原来的基础上有扩充了鼠标和用户界面事件、范围、遍历(迭代DOM文档的方法)等细分模块，同时增加了对CSS的支持。DOM2引入了下列新模块:</p>
<ul>
<li>DOM视图(DOM Views)：定义了跟踪不同文档视图的接口</li>
<li>DOM事件(DOM Events)：定义了事件和事件处理的接口</li>
<li>DOM样式(DOM Style)：定义了基于CSS为元素样式应用的接口</li>
<li>DOM遍历和范围(DOM Traversal and Range)：定义了遍历和操作文档树的接口</li>
</ul>
<h4 id="DOM3级"><a href="#DOM3级" class="headerlink" title="DOM3级"></a>DOM3级</h4><p>DOM3对DOM核心进行了扩展，开始支持XML1.0规范，涉及XML Infoset、XPath和XML Base，同时也级进一步扩展了DOM，引入了下列模块:</p>
<ul>
<li>DOM加载和保存(DOM Load and Save)：以同一方式加载和保存文档的方法</li>
<li>DOM验证(DOM Validation):：验证文档的方法</li>
</ul>
<h4 id="其他DOM标准"><a href="#其他DOM标准" class="headerlink" title="其他DOM标准"></a>其他DOM标准</h4><p>除了DOM核心和DOM HTML接口之外，另外几种语言还发布了只针对自己的DOM标准。如：</p>
<ul>
<li>SVG(Scalable Vector Graphic,可伸缩矢量图) 1.0</li>
<li>MathML(Mathematical Markup Language,数学标记语言) 1.0</li>
<li>SMIL(Synchronized Multimedia Integration Language,同步多媒体集成语言)</li>
</ul>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型(Browser Object Model)，开发人员使用BOM可以控制浏览器显示的页面以外的部分。在HTML5中吧很多BOM功能写入规范。BOM只处理浏览器窗口和框架，但人们也把一些针对浏览器的JavaScript扩展也作为BOM的一部分，下面就是这些扩展：</p>
<ul>
<li>弹出新浏览器窗口功能</li>
<li>移动、缩放和关闭浏览器窗口的功能</li>
<li>提供浏览器详细信息的navigator对象</li>
<li>提供浏览器所加载页面的详细信息的location对象</li>
<li>提供用户显示器分辨率详细信息的screen对象</li>
<li>对cookies的支持</li>
<li>像XMLHttpRequest和IE的ActiveXObject这样的自定义对象        </li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>JavaScript高级程序设计(第3版)</li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>代码里的后悔药——Git</title>
    <url>/code/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF%E2%80%94%E2%80%94Git.html</url>
    <content><![CDATA[<h2 id="代码里的后悔药—Git"><a href="#代码里的后悔药—Git" class="headerlink" title="代码里的后悔药—Git"></a>代码里的后悔药—Git</h2><h4 id="1-什么是Git"><a href="#1-什么是Git" class="headerlink" title="1. 什么是Git"></a>1. 什么是Git</h4><p>git是版本管理工具的一种，常见的版本管理工具还有<strong>CVS</strong>、<strong>SVN</strong>等等。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</p>
<h4 id="2-为什么要用Git"><a href="#2-为什么要用Git" class="headerlink" title="2. 为什么要用Git"></a>2. 为什么要用Git</h4><ul>
<li>分布式版本管理工具，容灾性较强</li>
<li>强大的分支和合并功能</li>
<li>支持多人协同开发<a id="more"></a>
<h4 id="3-Git和Github的关系"><a href="#3-Git和Github的关系" class="headerlink" title="3. Git和Github的关系"></a>3. Git和Github的关系</h4></li>
</ul>
<p>git是版本控制工具，而github则是一家以<strong>git</strong>作为唯一的版本库格式进行托管代码的托管平台，类似的托管平台还有<a href="https://about.gitlab.com" target="_blank" rel="noopener">gitlab</a>和<a href="https://gitee.com/" target="_blank" rel="noopener">码云gitee</a></p>
<h4 id="4-Git的安装"><a href="#4-Git的安装" class="headerlink" title="4. Git的安装"></a>4. Git的安装</h4><p>去<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>下载对应的版本(Linux和Mac用户可以使用自带的软件管理工具进行安装) </p>
<p>注：尽量不要使用git的GUI工具</p>
<h4 id="5-Git的基本概念"><a href="#5-Git的基本概念" class="headerlink" title="5. Git的基本概念"></a>5. Git的基本概念</h4><ul>
<li><h5 id="工作目录-Working-Directory"><a href="#工作目录-Working-Directory" class="headerlink" title="工作目录(Working Directory)"></a>工作目录(Working Directory)</h5><p>工作目录就是能在电脑上能看到的目录           </p>
</li>
<li><h5 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h5><p>暂存区又称缓存区，一般存放在项目文件夹的 <strong>.git</strong>目录下的<strong>index</strong>文件</p>
</li>
<li><h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><p>仓库又称版本库，git有本地仓库和远程仓库(即用来托管代码的服务器)之分。本地仓库一般存放在项目文件夹的<strong>.git</strong>目录中</p>
<p><img src="https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181008211557402-232838726.png" alt="工作区示意图"></p>
</li>
<li><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>一般项目中会有 <strong>主分支、开发分支、功能分支</strong> 等分支。Git非常鼓励使用分支。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14653704-1383d63bfa39e0bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/885/format/webp" alt="分支示意图"></p>
</li>
</ul>
<h4 id="6-Git的工作流程"><a href="#6-Git的工作流程" class="headerlink" title="6. Git的工作流程"></a>6. Git的工作流程</h4><blockquote>
<p>Git管理的文件有三种状态: 已修改(modified)、已暂存(staged)和已提交(commited)</p>
</blockquote>
<h5 id="1-在工作目录中添加修改文件"><a href="#1-在工作目录中添加修改文件" class="headerlink" title="1. 在工作目录中添加修改文件"></a>1. 在工作目录中添加修改文件</h5><h5 id="2-将需要进行版本管理的文件放入暂存区"><a href="#2-将需要进行版本管理的文件放入暂存区" class="headerlink" title="2. 将需要进行版本管理的文件放入暂存区"></a>2. 将需要进行版本管理的文件放入暂存区</h5><h5 id="3-将暂存区的文件提交到git仓库"><a href="#3-将暂存区的文件提交到git仓库" class="headerlink" title="3. 将暂存区的文件提交到git仓库"></a>3. 将暂存区的文件提交到git仓库</h5><h4 id="7-Git的基本命令"><a href="#7-Git的基本命令" class="headerlink" title="7. Git的基本命令"></a>7. Git的基本命令</h4><ul>
<li>初始化项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<ul>
<li>添加文件到暂存区</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add 文件路径</span><br></pre></td></tr></table></figure>

<ul>
<li>提交版本                 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "log"</span><br></pre></td></tr></table></figure>

<ul>
<li>版本回滚</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commitId     # 回退到指定版本，或者</span><br><span class="line">git reset --hard HEAD^        # 回退到上个版本</span><br><span class="line">git reset --hard HEAD~n       # 回退到前n个版本</span><br></pre></td></tr></table></figure>

<ul>
<li>查看仓库当前状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<ul>
<li>查看具体修改内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<ul>
<li>查看历史</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log      # 查看提交历史</span><br><span class="line">git reflog   # 查看命令历史</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- file      # 撤销工作区中的修改</span><br><span class="line">git reset HEAD file       # 撤销暂存区中的修改    HEAD表示最新的版本</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure>

<ul>
<li>远程仓库操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add 名字 &lt;repo address&gt;      # 添加远程仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如:</span></span><br><span class="line">git remote add origin https://github.com/musistudio/MusicBox</span><br><span class="line">git push name branch                   # 推送到远程仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line">git push -u origin master # -u参数会将本地的分支与远程的分支关联起来，origin代表提交到哪个仓库, master代表master分支</span><br><span class="line">git clone &lt;repo address&gt;               # 从远程库克隆</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如:</span></span><br><span class="line">git clone https://github.com/musistudio/MusicBox</span><br><span class="line">git remote -v                          # 查看远程库信息</span><br><span class="line">git checkout -b name origin/name       # 在本地创建和远程分支对应的分支</span><br><span class="line">git branch --set-upstream name origin/name # 建立本地分支和远程分支的关联</span><br></pre></td></tr></table></figure>

<ul>
<li>分支操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch dev                 # 创建dev分支</span><br><span class="line">git checkout dev               # 切换到dev分支</span><br><span class="line"><span class="meta">#</span><span class="bash"> ==&gt; 上面两条命令等同于下面一条命令</span></span><br><span class="line">git branck checkout -b dev     # -b 参数表示创建并切换</span><br><span class="line">git branch                     # 查看分支</span><br><span class="line">git merge dev                  # 合并指定分支(dev)到当前分支</span><br><span class="line">git merge --no-ff -m "log" dev # 以普通模式合并分支，合并后有合并历史(禁用fast forward模式)</span><br><span class="line">git branch -d dev              # 删除指定分支(dev)</span><br><span class="line">git branch -D dev              # 丢弃没有合并的分支，使用-D强行删除</span><br><span class="line">git log --graph                # 查看分支合并图</span><br><span class="line">git rebase                     # 把本地未push的分叉提交历史整理成直线，使在查看历史提交的变化更容易</span><br></pre></td></tr></table></figure>

<ul>
<li>储存工作现场</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmitgit stash</span><br></pre></td></tr></table></figure>

<ul>
<li>标签操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0      # 给HEAD打一个v1,0的标签,也可以指定一个commit</span><br><span class="line">git tag           # 查看所有标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m "log"  # 创建带有说明的标签</span><br><span class="line">git show &lt;tagname&gt;             # 查看标签的说明文字</span><br><span class="line">git tag -d &lt;tagname&gt;           # 删除本地标签</span><br><span class="line">git push origin &lt;tagname&gt;      # 向远程推送本地标签</span><br><span class="line">git push origin --tags         # 向远程推送所有未推送过的标签</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;  # 删除远程标签</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云oss部署Vue项目</title>
    <url>/code/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E9%83%A8%E7%BD%B2Vue%E9%A1%B9%E7%9B%AE.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么要用oss部署vue项目？使用oss部署前端项目可以利用oss的带宽以及cdn的加速来减少前端资源的加载速度。特别是当服务器的带宽小的情况下就显得更为重要，另外也可以使用oss配置免备案的域名。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>登陆阿里云控制台—&gt;对象存储oss—&gt;创建Bucket(设置区域把读写权限改为公共读就好了)</li>
<li>选中Bucket后点击基础设置—&gt;静态页面—&gt;设置默认首页为index.html—&gt;完成后保存</li>
<li>oss暂不支持vue的history路由，所以必须使用hash的路由，虽然可能不太美观，但由于我做的是微信H5页面所以基本上也看不到路由，也就不在意这些。</li>
</ol>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>目前使用的是手动上传的方式，后期可能会加上git hook 和 oss sdk来完成持续集成部分的东西，刚好我的毕设和这个相关可以花点时间研究一下。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title>也谈Unicode和UTF-8</title>
    <url>/code/%E4%B9%9F%E8%B0%88Unicode%E5%92%8CUTF-8.html</url>
    <content><![CDATA[<blockquote>
<p>最近在学习字符集相关的内容，遂以此文进行记录。</p>
</blockquote>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><ol>
<li><p>起源</p>
<p>大家都知道计算机起源于美国，而美国人一开始通信用的是<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a>字符，其包含所有大小写字母和常用的英文标点符号，足够美国人使用。后来计算机在其他国家普及，由于语种多样性ASCII字符不再满足需要。于是便有了欧洲的ISO 8859以及中文的GBK编码。但这样就有一个问题，美国的计算机接受到来自中国的电子邮件后无法正常显示内容。为了解决这种各国编码规范不统一的问题，<a href="https://en.wikipedia.org/wiki/The%20Unicode%20Consortium" target="_blank" rel="noopener">The Unicode Consortium</a>指定了Unicode(也叫国际码)标准。</p>
</li>
<li><p>编码方式</p>
<p>当前的Unicode使用16位的编码空间，每个字符占2字节，理论上最多可表示65536个字符。基本满足各种语言的使用。基本多文种平面的字符的编码为U+hhhh，每个h代表一个十六进制的数字。</p>
</li>
</ol>
<a id="more"></a>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><ol>
<li><p>起源</p>
<p>在实际传输过程中，由于不同系统平台的设计不确定性，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。Unicode 的实现方式称为 <strong>Unicode转换格式</strong>（Unicode Transformation Format，简称为 UTF）。而UTF-8就是8位的unicode转换格式。</p>
</li>
<li><p>编码方式</p>
<p>以8位为单元对UCS进行编码，每个使用UTF-8存储的字符，除了第一个自己外，其余字节的头两个比特都是以“10”开始，使文字处理器能够较快的找出每个字符的开始位置。为了兼容ASCII，UTF-8选择以可变长度存储Unicode。转换关系图如下：</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-22_19-25-08.jpg" alt=""></p>
</li>
<li><p>Unicode转UTF-8</p>
<p>已知“严”的unicode是4E25(100111000100101)， 根据上表，可以发现4E25处在第三行的<br>范围内(U+0800-U+FFFF), 因此“严”的UTF-8编码需要三个字节，即格式是<br>“1110xxxx 10xxxxxx 10xxxxxx”。 然后, 从“严”的最后一个二进制位开始，依次从后向前<br>填入格式中的x，多出的位补0。 这样就得到了“严”的UTF-8编码是”11100100 10111000<br>10100101”, 转换成十六进制就是E4B8A5。</p>
<p>附JavaScript实现代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeUTF8</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="built_in">parseInt</span>(str.codePointAt().toString(<span class="number">16</span>), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">let</span> bCodes = str.codePointAt().toString(<span class="number">2</span>).split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> byte, template, result = <span class="string">''</span>, temp;</span><br><span class="line">    <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'007F'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'0xxxxxxx'</span>;</span><br><span class="line">        byte = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'07FF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'110xxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'FFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1110xxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'1FFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1110xxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'1FFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'11110xxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">5</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'3FFFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'111110xx10xxxxxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">6</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'7FFFFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1111110x10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    template = template.split(<span class="string">''</span>).reverse().map(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">'x'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bCodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bCodes.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    temp = <span class="built_in">parseInt</span>(template.reverse().join(<span class="string">''</span>), <span class="number">2</span>).toString(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">let</span> len = temp.length / byte</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=byte;i++) &#123;</span><br><span class="line">        result += <span class="string">'\\x'</span> + temp.slice((i<span class="number">-1</span>)*len, i*len)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> encoding = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="string">''</span>).map(<span class="function"><span class="params">s</span> =&gt;</span> encodeUTF8(s)).join(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(encoding(<span class="string">'严厉'</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>charset</tag>
      </tags>
  </entry>
  <entry>
    <title>使用对象</title>
    <url>/wiki/%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<blockquote>
<p>JavaScript的设计是一个简单的基于对象的范式。一个对象就是一系列属性的集合，一个属性包含一个键和一个值。</p>
</blockquote>
<h3 id="对象和属性"><a href="#对象和属性" class="headerlink" title="对象和属性"></a>对象和属性</h3><p>一个JavaScript对象有很多属性。一个对象的属性可以被解释成一个附加到对象上的变量。对象的属性定义对象的特征，可以使用点符号<code>.</code>访问对象的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.propertyName</span><br></pre></td></tr></table></figure>

<p>一个对象的属性名可以是任何有效的JavaStript字符串，或者可以被转换成字符串的任何类型，包括空字符串。如果不是一个有效的标识符只能通过方括号标记访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"a b"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);      <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'a b'</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>方括号中的所有键都将转换为字符串类型，对象只能使用String类型作为键。可以在<code>for...in</code>语句中使用方括号标记以枚举一个对象的所有属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showProps</span>(<span class="params">obj, objName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(i)) &#123;</span><br><span class="line">       result += <span class="string">`<span class="subst">$&#123;objName&#125;</span>.<span class="subst">$&#123;i&#125;</span> = <span class="subst">$&#123;obj[i]&#125;</span>\n`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(showProps(obj, <span class="string">'obj'</span>));    <span class="comment">// obj.a = 1</span></span><br><span class="line">                                       <span class="comment">// obj.b = 2</span></span><br><span class="line">                                       <span class="comment">// obj.c = test</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举一个对象的所有属性"><a href="#枚举一个对象的所有属性" class="headerlink" title="枚举一个对象的所有属性"></a>枚举一个对象的所有属性</h3><p>从ES5开始，有三种原生的方法用于列出或枚举对象的属性：</p>
<ul>
<li><code>for...in</code>循环：该方法依次访问一个对象及其原型链中所有可枚举的属性</li>
<li><code>Object.keys(o)</code>：该方法返回对象<code>o</code>自身包含(不包含原型链)的所有可枚举属性的名称的数组</li>
<li><code>Object.getOwnPropertyNames(o)</code>：该方法返回对象<code>o</code>自身包含(不包含原型链)的所有属性(无论是否可枚举)的名称的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="string">'test'</span>,</span><br><span class="line">  c: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span>  obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.keys;</span></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertyName;</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">names.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[name]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="创建一个新对象"><a href="#创建一个新对象" class="headerlink" title="创建一个新对象"></a>创建一个新对象</h3><p>可以使用对象字面量和构造函数来创建新对象。</p>
<h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><ul>
<li>语法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  property: value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>使用构造函数创建对象需要两步：</p>
<ol>
<li>通过创建一个构造函数来定义对象的类型，通常构造函数的函数名首字母会大写。</li>
<li>通过<code>new</code>创建对象实例。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.oil = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 定义方法</span></span><br><span class="line">  addOil = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.oil += value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于下面的方式</span></span><br><span class="line">  <span class="comment">// addOil(value) &#123;</span></span><br><span class="line">  <span class="comment">//  this.oil += value</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.color = <span class="string">'red'</span>;    <span class="comment">// 为对象添加属性</span></span><br><span class="line"><span class="keyword">let</span> myCar = <span class="keyword">new</span> Car(<span class="string">'China'</span>, <span class="string">'Test'</span>, <span class="number">2020</span>);    <span class="comment">// myCar是Car对象的一个实例，拥有make model year三个属性</span></span><br><span class="line">myCar.money = <span class="number">100000</span>;    <span class="comment">// 为实例添加属性</span></span><br><span class="line">myCar.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 为实例添加方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myCar.color);    <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.money);    <span class="comment">// 100000</span></span><br><span class="line">myCar.run();                 <span class="comment">// running</span></span><br></pre></td></tr></table></figure>

<h4 id="使用Object-create-方法"><a href="#使用Object-create-方法" class="headerlink" title="使用Object.create()方法"></a>使用<code>Object.create()</code>方法</h4><p>该方法允许在创建对象时选择一个原型对象且不用定义构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Animal = &#123;</span><br><span class="line">  type: <span class="string">'Invertebrates'</span>,</span><br><span class="line">  displayType: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal1 = <span class="built_in">Object</span>.create(Animal);  <span class="comment">// 创建新动物 animal1</span></span><br><span class="line">animal1.displayType();                <span class="comment">// Invertebrates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fish = <span class="built_in">Object</span>.create(Animal); <span class="comment">// 创建新动物fish</span></span><br><span class="line">fish.type = <span class="string">'fish'</span>;</span><br><span class="line">fish.displayType();               <span class="comment">// fish</span></span><br></pre></td></tr></table></figure>

<h4 id="定义getters和setters"><a href="#定义getters和setters" class="headerlink" title="定义getters和setters"></a>定义getters和setters</h4><p><code>getter</code>是获取某个特定属性值的方法，<code>setter</code>是设置某个属性值的方法。定义getter和setter可以使用对象字面量方式添加，或使用添加方法的方式添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  <span class="keyword">get</span> b() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> c(c) &#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c /<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.a);    <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);    <span class="comment">// 8</span></span><br><span class="line">o.c = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.c);    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为定义好的类添加getter和setter</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">Date</span>.prototype;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(d, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;<span class="keyword">return</span> <span class="keyword">this</span>.getFullYear()&#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(year) &#123;<span class="keyword">this</span>.setFullYear(year)&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();    <span class="comment">// 创建一个Date对象的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(now.year);   <span class="comment">// 2020</span></span><br><span class="line">now.year = <span class="number">2021</span>;</span><br><span class="line"><span class="built_in">console</span>.log(now.year);   <span class="comment">// 2021</span></span><br></pre></td></tr></table></figure>

<h4 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h4><p><code>delete</code>操作符可以删除一个不是继承而来的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span>,</span><br><span class="line">  b: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> obj.a;</span><br><span class="line"><span class="built_in">console</span>.log(obj);   <span class="comment">// &#123;b: 12&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个全局变量不是使用var声明的也可以使用delete删除(默认是全局对象上的属性)</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>

<h4 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h4><p>在JavaScript中objects是一种引用类型。两个独立声明的对象永远不会相等，只有在比较一个对象和这个对象的引用时才会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = &#123;<span class="attr">name</span>: <span class="string">'apple'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fruit1 = &#123;<span class="attr">name</span>: <span class="string">'apple'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruit == fruit1);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fruit === fruit1);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruit = &#123;<span class="attr">name</span>: <span class="string">'apple'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fruit1 = fruit;</span><br><span class="line"><span class="built_in">console</span>.log(fruit == fruit1);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fruit === fruit1);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端搞编译——AST在前端的应用</title>
    <url>/code/%E5%89%8D%E7%AB%AF%E6%90%9E%E7%BC%96%E8%AF%91%E2%80%94%E2%80%94AST%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="前端搞编译-AST在PRO中的运用"><a href="#前端搞编译-AST在PRO中的运用" class="headerlink" title="前端搞编译-AST在PRO中的运用"></a>前端搞编译-AST在PRO中的运用</h2><blockquote>
<p>AST(Abstract Syntax Tree, 抽象语法树)，以树状形式表现编程语言的语法结构。</p>
</blockquote>
<a id="more"></a>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><blockquote>
<p> 代码是写给人看的，顺便能给计算机执行。</p>
</blockquote>
<p>在程序可以被计算机执行之前，需要先被翻译成计算机可以执行的形式。负责这项工作的软件系统被称为<strong>编译器</strong>。一个编译器就是一个程序，它可以阅读某一种语言编写的程序，并把该程序翻译成一个等价的、用另一个语言编写的程序。例如<strong>Babel</strong>。编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误。例如<strong>ESLint</strong>。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/image-20210810064538026.png" alt="image-20210810064538026" style="zoom:50%;" />

<h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>并不通过翻译的形式生成目标程序，直接使用用户的输入去执行指定的操作。(使用解释器的常见的编程语言有Python、JavaScript等)</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/image-20210810070514469.png" alt="image-20210810070514469" style="zoom:50%;" />

<h4 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h4><ol>
<li><p>词法分析</p>
<p>词法分析器读入源程序的字符流，并且将它们组成有意义的词素序列，对于每个词素，词法分析器会生成词法单元作为输出。这一步也叫做分词。</p>
</li>
<li><p>语法分析</p>
<p>语法分析器使用词法分析器生成的词法单元创建树形的中间表示(AST)。</p>
</li>
<li><p>语义分析</p>
<p>使用语法树和符号表(用来记录源程序中使用的变量的名字)中的信息来检查源程序是否和语言定义的语义一致。它同时收集类型信息，存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。</p>
</li>
<li><p>中间代码生成</p>
<p>在语义分析之后，一些编译器会生成一个类机器语言的中间表示，该中间表示易于生成且能被轻松翻译成目标语言。</p>
</li>
<li><p>代码优化</p>
<p>机器无关的代码优化步骤试图优化中间代码，以便生成更好的目标代码。</p>
</li>
<li><p>代码生成</p>
<p>以源程序的中间表示形式作为输入，并把它映射到目标语言。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/image-20210810072810249.png" alt="image-20210810072810249" style="zoom: 33%;" />

</li>
</ol>
<h4 id="语法分析器-Parser"><a href="#语法分析器-Parser" class="headerlink" title="语法分析器(Parser)"></a>语法分析器(Parser)</h4><ul>
<li><p>自顶向下</p>
<p>构造过程从根节点开始，逐步向叶子节点推进。（简单高效）</p>
</li>
<li><p>自底向上</p>
<p>构造过程从叶子节点开始，逐步构造出根节点。(复杂)</p>
</li>
</ul>
<h4 id="AST在公式业务中的运用"><a href="#AST在公式业务中的运用" class="headerlink" title="AST在公式业务中的运用"></a>AST在公式业务中的运用</h4><p>所谓公式，其实就是一个个的JS函数。使用公式，在系统内部就是发起一次函数调用。具体<a href="https://xbb.yuque.com/lfwuxq/vsf9sv/sw53n7" target="_blank" rel="noopener">参见这里</a>。</p>
<p>对于这种实现，我们很容易就能构造出以下字符串去执行任意代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">''</span>[<span class="string">'sub'</span>][<span class="string">'constructor'</span>](<span class="string">'alert("这是一条警告：可以执行任意的js")'</span>)()</span><br></pre></td></tr></table></figure>

<h5 id="案例一：使用AST校验用户输入是否合法"><a href="#案例一：使用AST校验用户输入是否合法" class="headerlink" title="案例一：使用AST校验用户输入是否合法"></a>案例一：使用AST校验用户输入是否合法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> types = &#123;</span><br><span class="line">    CallExpression: <span class="string">'CallExpression'</span>, <span class="comment">// 函数调用表达式</span></span><br><span class="line">    BinaryExpression: <span class="string">'BinaryExpression'</span>, <span class="comment">// 条件表达式</span></span><br><span class="line">    Identifier: <span class="string">'Identifier'</span>, <span class="comment">// 标识符</span></span><br><span class="line">    Literal: <span class="string">'Literal'</span>, <span class="comment">// 字面量</span></span><br><span class="line">    Brackets: <span class="string">'Brackets'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rules = &#123;</span><br><span class="line">    IF: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length === <span class="number">3</span> &amp;&amp; params[<span class="number">0</span>].type === types.BinaryExpression &amp;&amp; [<span class="string">'&gt;'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;='</span>, <span class="string">'&lt;='</span>, <span class="string">'!='</span>, <span class="string">'=='</span>].includes(params[<span class="number">0</span>].operator),</span><br><span class="line">    ADD: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    SUBTRACT: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MULTIPLY: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    DIVIDE: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    SUM: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    AVERAGE: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MAX: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MIN: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    DATE_DIFF: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> [<span class="number">2</span>, <span class="number">3</span>].includes(params.length) &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> [types.Identifier, types.Literal].includes(p.type))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.EOF = <span class="built_in">Symbol</span>(<span class="string">'EOF'</span>)</span><br><span class="line">        <span class="keyword">this</span>.str = str</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.funcs = []</span><br><span class="line">        <span class="keyword">this</span>.AST = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.tempStr = <span class="string">''</span></span><br><span class="line">        <span class="keyword">this</span>.expression = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    getLastFunc() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.funcs[<span class="keyword">this</span>.funcs.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    start(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[A-Z_]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.start</span><br><span class="line">    &#125;</span><br><span class="line">    findLetter(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[A-Z_]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rules[<span class="keyword">this</span>.tempStr]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.EOF</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.funcs.push(&#123;</span><br><span class="line">                type: types.CallExpression,</span><br><span class="line">                name: <span class="keyword">this</span>.tempStr,</span><br><span class="line">                params: []</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.tempStr = <span class="string">''</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findFunc(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = &#123;</span><br><span class="line">                type: types.Identifier,</span><br><span class="line">                name: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findVar</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">','</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.expression) &#123;</span><br><span class="line">                <span class="keyword">this</span>.expression.right = <span class="keyword">this</span>.node</span><br><span class="line">                <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.expression)</span><br><span class="line">                <span class="keyword">this</span>.expression = <span class="literal">null</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.node) <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[A-Z]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.funcs.push(&#123;</span><br><span class="line">                type: types.Brackets,</span><br><span class="line">                name: <span class="literal">null</span>,</span><br><span class="line">                params: []</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.node) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">                <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> func = <span class="keyword">this</span>.funcs.pop()</span><br><span class="line">            <span class="keyword">this</span>.node = func</span><br><span class="line">            <span class="keyword">this</span>.AST = func</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/[a-zA-Z0-9_.]/</span>.test(s)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.node) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.node = &#123;</span><br><span class="line">                        type: types.Literal,</span><br><span class="line">                        name: <span class="string">''</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.node.name += s</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.expression &amp;&amp; !<span class="keyword">this</span>.expression.right) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.expression.operator += s</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.expression = &#123;</span><br><span class="line">                        type: types.BinaryExpression,</span><br><span class="line">                        left: <span class="keyword">this</span>.getLastFunc().params.pop(),</span><br><span class="line">                        operator: s,</span><br><span class="line">                        right: <span class="string">''</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findVar(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">            <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.node.name += s</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findVar</span><br><span class="line">    &#125;</span><br><span class="line">    check() &#123;</span><br><span class="line">        <span class="keyword">let</span> state = <span class="keyword">this</span>.start</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> <span class="keyword">this</span>.str) &#123;</span><br><span class="line">            state = state.call(<span class="keyword">this</span>, s)</span><br><span class="line">            <span class="keyword">if</span> (state === <span class="keyword">this</span>.EOF) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> BFS = <span class="function"><span class="params">tree</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> queue = [tree]</span><br><span class="line">            <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">                <span class="keyword">let</span> n = queue.length</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> node = queue.pop()</span><br><span class="line">                    <span class="keyword">if</span> (node.type === types.CallExpression &amp;&amp; rules[node.name] &amp;&amp; !rules[node.name](node)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">if</span> (node.type === types.Brackets &amp;&amp; node.params.length &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">if</span> (node.params) <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> node.params) queue.push(p)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BFS(<span class="keyword">this</span>.AST)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Parser(<span class="string">'ADD(&#123;4105.num_61&#125;,((&#123;4105.num_61&#125;,23)))'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.check(), <span class="string">'test.check()'</span>)</span><br></pre></td></tr></table></figure>



<h5 id="案例二：使用AST实现公式"><a href="#案例二：使用AST实现公式" class="headerlink" title="案例二：使用AST实现公式"></a>案例二：使用AST实现公式</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> types = &#123;</span><br><span class="line">    CallExpression: <span class="string">'CallExpression'</span>, <span class="comment">// 函数调用表达式</span></span><br><span class="line">    BinaryExpression: <span class="string">'BinaryExpression'</span>, <span class="comment">// 条件表达式</span></span><br><span class="line">    Identifier: <span class="string">'Identifier'</span>, <span class="comment">// 标识符</span></span><br><span class="line">    Literal: <span class="string">'Literal'</span>, <span class="comment">// 字面量</span></span><br><span class="line">    Brackets: <span class="string">'Brackets'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rules = &#123;</span><br><span class="line">    IF: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length === <span class="number">3</span> &amp;&amp; params[<span class="number">0</span>].type === types.BinaryExpression &amp;&amp; [<span class="string">'&gt;'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;='</span>, <span class="string">'&lt;='</span>, <span class="string">'!='</span>, <span class="string">'=='</span>].includes(params[<span class="number">0</span>].operator),</span><br><span class="line">    ADD: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    SUBTRACT: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MULTIPLY: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    DIVIDE: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">2</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    SUM: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    AVERAGE: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MAX: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    MIN: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> params.length &gt;= <span class="number">1</span> &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> <span class="built_in">Object</span>.keys(types).includes(p.type)),</span><br><span class="line">    DATE_DIFF: <span class="function">(<span class="params">&#123; params &#125;</span>) =&gt;</span> [<span class="number">2</span>, <span class="number">3</span>].includes(params.length) &amp;&amp; params.every(<span class="function"><span class="params">p</span> =&gt;</span> [types.Identifier, types.Literal].includes(p.type))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Calculator = &#123;</span><br><span class="line">    ADD: <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> +a + +b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> varNames = &#123;</span><br><span class="line">    <span class="string">'4105.num_61'</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.EOF = <span class="built_in">Symbol</span>(<span class="string">'EOF'</span>)</span><br><span class="line">        <span class="keyword">this</span>.str = str</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.funcs = []</span><br><span class="line">        <span class="keyword">this</span>.AST = &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.tempStr = <span class="string">''</span></span><br><span class="line">        <span class="keyword">this</span>.expression = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    getLastFunc() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.funcs[<span class="keyword">this</span>.funcs.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    start(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[A-Z_]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.start</span><br><span class="line">    &#125;</span><br><span class="line">    findLetter(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[A-Z_]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rules[<span class="keyword">this</span>.tempStr]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.EOF</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.funcs.push(&#123;</span><br><span class="line">                type: types.CallExpression,</span><br><span class="line">                name: <span class="keyword">this</span>.tempStr,</span><br><span class="line">                params: []</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">this</span>.tempStr = <span class="string">''</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findFunc(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node = &#123;</span><br><span class="line">                type: types.Identifier,</span><br><span class="line">                name: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findVar</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">','</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.expression) &#123;</span><br><span class="line">                <span class="keyword">this</span>.expression.right = <span class="keyword">this</span>.node</span><br><span class="line">                <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.expression)</span><br><span class="line">                <span class="keyword">this</span>.expression = <span class="literal">null</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.node) <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[A-Z]/</span>.test(s)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tempStr += s</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findLetter</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.funcs.push(&#123;</span><br><span class="line">                type: types.Brackets,</span><br><span class="line">                name: <span class="literal">null</span>,</span><br><span class="line">                params: []</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s === <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.node) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">                <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> func = <span class="keyword">this</span>.funcs.pop()</span><br><span class="line">            <span class="keyword">this</span>.node = func</span><br><span class="line">            <span class="keyword">this</span>.AST = func</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="regexp">/[a-zA-Z0-9_.]/</span>.test(s)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.node) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.node = &#123;</span><br><span class="line">                        type: types.Literal,</span><br><span class="line">                        name: <span class="string">''</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.node.name += s</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.expression &amp;&amp; !<span class="keyword">this</span>.expression.right) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.expression.operator += s</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.expression = &#123;</span><br><span class="line">                        type: types.BinaryExpression,</span><br><span class="line">                        left: <span class="keyword">this</span>.getLastFunc().params.pop(),</span><br><span class="line">                        operator: s,</span><br><span class="line">                        right: <span class="string">''</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findVar(s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getLastFunc().params.push(<span class="keyword">this</span>.node)</span><br><span class="line">            <span class="keyword">this</span>.node = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findFunc</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.node.name += s</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findVar</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">let</span> state = <span class="keyword">this</span>.start</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> <span class="keyword">this</span>.str) &#123;</span><br><span class="line">            state = state.call(<span class="keyword">this</span>, s)</span><br><span class="line">            <span class="keyword">if</span> (state === <span class="keyword">this</span>.EOF) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> callStack = [];</span><br><span class="line">        <span class="keyword">const</span> pushCallStack = <span class="function"><span class="params">tree</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; name, type, params &#125; = tree;</span><br><span class="line">            <span class="keyword">if</span> ([types.CallExpression, types.Brackets].includes(type)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type === types.CallExpression) callStack.push(&#123; name, type &#125;)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> params) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arg.type === types.CallExpression || arg.type === types.Brackets) &#123;</span><br><span class="line">                        pushCallStack(arg)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callStack.push(arg)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pushCallStack(<span class="keyword">this</span>.AST)</span><br><span class="line">        <span class="keyword">let</span> args = [];</span><br><span class="line">        <span class="keyword">while</span> (callStack.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> current = callStack.pop();</span><br><span class="line">            <span class="keyword">if</span> (current.type === types.Literal) &#123;</span><br><span class="line">                args.unshift(current.name)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.type === types.Identifier) &#123;</span><br><span class="line">                args.unshift(varNames[current.name])</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.type === types.CallExpression) &#123;</span><br><span class="line">                <span class="keyword">const</span> res = Calculator[current.name](...args);</span><br><span class="line">                args = [];</span><br><span class="line">                callStack.push(&#123;</span><br><span class="line">                    type: types.Literal,</span><br><span class="line">                    name: res</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (callStack.length === <span class="number">1</span> &amp;&amp; callStack[<span class="number">0</span>].type === types.Literal) <span class="keyword">return</span> callStack.pop().name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Parser(<span class="string">'ADD(&#123;4105.num_61&#125;,(ADD(&#123;4105.num_61&#125;,23)))'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.run(), <span class="string">'test.run()'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>元编程</title>
    <url>/wiki/%E5%85%83%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[<blockquote>
<p>从ECMAScript2015开始，JavaScript获得了<code>Proxy</code>和<code>Reflect</code>对象的支持，允许拦截并定义基本语言操作的自定义行为(例如属性查找、赋值、枚举和函数调用等)。借助这两个对象，可以在JavaScript元级别进行编程。</p>
</blockquote>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>在ES6中引入的Proxy对象可以拦截某些操作并实现自定义行为。例如获取一个对象上的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">42</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);    <span class="comment">// 1, 42</span></span><br></pre></td></tr></table></figure>

<p>Proxy对象定义了一个目标(这里是一个对象)和一个实现了<code>get</code>方法的handle对象，代理的对象在获取未定义的属性时不会返回<code>undefined</code>而返回42。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/wiki/%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数定义，也称为函数声明或函数语句，由<code>function</code>关键字组成。其后为：</p>
<ul>
<li>函数的名称</li>
<li>函数参数列表</li>
<li>定义函数的JavaScript语句，用大括号<code>{}</code>括起来</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">theObject</span>) </span>&#123;</span><br><span class="line">  theObject.make = <span class="string">'Toyota'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line">x = mycar.make; <span class="comment">// Honda</span></span><br><span class="line">myFunc(mycar);</span><br><span class="line">y = mycar.make; <span class="comment">// Toyota</span></span><br></pre></td></tr></table></figure>

<p>原始类型的参数将值传给函数，非原始类型的参数(比如对象、数组)将引用传给函数。</p>
<p>除了上面的函数声明方式，还可以通过函数表达式来创建函数。使用这种方法创建的函数可以是匿名的(即不需要函数名)，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123; <span class="keyword">return</span> number * number; &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n</span>) </span>&#123;<span class="keyword">return</span> n&lt;<span class="number">2</span> ? <span class="number">1</span> : n*fac(n<span class="number">-1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>还有第三种创建函数的方法，即使用<code>Function</code>构造函数来创建一个Function对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">6</span>));    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>当函数是一个对象的属性时，它也叫方法。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数被定义后不会被自动执行，函数定义仅仅是赋予函数以名称并明确函数被调用时该做什么。调用函数才会真正执行定义函数时的动作，可以使用函数名加小括号<code>()</code>的方式调用它，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>调用函数时，他们必须在作用域内(但会有函数声明提升，即声明在调用下方)。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用域指函数声明时所处的地方，当函数在顶层被声明时就是整个程序。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数内定义的变量不能再函数之外的任何地方访问，因为变量仅仅在该函数内部有定义。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> test = <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域和函数堆栈"><a href="#作用域和函数堆栈" class="headerlink" title="作用域和函数堆栈"></a>作用域和函数堆栈</h4><ul>
<li><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>调用自身的函数称为<strong>递归函数</strong>，一个函数可以<strong>指向</strong>并<strong>调用</strong>自身。有三种方法可以达到这个目的：</p>
<ol>
<li>函数名</li>
<li>arguments.callee</li>
<li>作用域下的一个指向该函数的变量名</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数体内，下面语句是等价的</p>
<ol>
<li>bar()</li>
<li>arguments.callee()</li>
<li>foo()</li>
</ol>
<p>在某种意义上递归近似于循环：两者都重复执行相同的代码，并且两者都需要一个终止条件。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面循环可以转化成下面的递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">  loop(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套函数和闭包</p>
<p>你可以在一个函数里面嵌套另外一个函数，内部函数对内部函数来说是私有的。它自身也形成了一个闭包。闭包是一个表达式(最常见的是一个函数)，可以拥有自身变量以及绑定这些变量的环境。这意味着内部函数可以访问外部函数的参数和变量。</p>
<p>总结如下：</p>
<ul>
<li>内部函数只可以在外部函数中访问</li>
<li>内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的函数和变量</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn_inside = out(<span class="number">3</span>);    <span class="comment">// 返回一个函数</span></span><br><span class="line"><span class="keyword">let</span> result = fn_inside(<span class="number">5</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = out(<span class="number">3</span>)(<span class="number">5</span>);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>闭包必须在其引用的所有范围内保留参数和变量，由于每次调用都可能传入不同的参数，每一次外部函数的调用实际上重新创建了一遍这歌闭包。仅当返回的函数没有再被引用时，才释放内存。</p>
<p>函数可以被多层嵌套，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x + y +z);</span><br><span class="line">    &#125;</span><br><span class="line">    C(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  B(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>);    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>函数B和C都形成了闭包，所以B可以访问A，C可以访问B和A。所以闭包可以包含多个作用域，它们递归式的包含了所有包含它的作用域，这被称为作用域链。</p>
<p>当同一个闭包作用域下两个参数或者变量同名时会产生命名冲突，最近的作用域拥有更高的优先级，这就是作用域链。链的第一个元素就是最里面的元素，最后一个元素便是最外层的作用域。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line">outside()(<span class="number">10</span>);    <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是JavaScript最强大的特性之一，JavaScript允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是外部函数不能访问·定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生命周期大于外部函数时，外部函数中定义的变量和函数的生命周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createPet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sex;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getSex: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      retuen sex;</span><br><span class="line">    &#125;,</span><br><span class="line">    setSex: <span class="function"><span class="keyword">function</span>(<span class="params">newSex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> newSex == <span class="string">'string'</span> &amp;&amp; (newSex.toLowerCase() == <span class="string">'male'</span> || newSex.toLowerCase() == <span class="string">'female'</span>)) sex = newSex; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = create(<span class="string">'Pet'</span>);</span><br><span class="line">pet.getName();    <span class="comment">// Pet</span></span><br><span class="line">pet.setName(<span class="string">'Ppet'</span>);</span><br><span class="line">pet.setSex(<span class="string">'male'</span>);</span><br><span class="line">pet.getName();    <span class="comment">// ppet</span></span><br><span class="line">pet.getSex();     <span class="comment">// male</span></span><br></pre></td></tr></table></figure>

<p>如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createPet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      name = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet = createPet(<span class="string">'Pet'</span>);</span><br><span class="line">pet.setName(<span class="string">'Ppet'</span>);</span><br><span class="line">pet.getName(<span class="string">');    // Pet</span></span><br></pre></td></tr></table></figure>

<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>函数的实际参数会被保存在一个类似数组的arguments对象中，在函数内，可以使用<code>arguments[i]</code>的形式获取传入的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 遍历获取所有参数</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i] + separator;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argumnets只是类数组对象，并不是一个数组，并不拥有全部的Array对象的操作方法。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>从ES6开始，有两个新类型的参数：<strong>默认参数</strong>、<strong>剩余参数</strong></p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>在JavaScript中，函数参数的默认值是<code>undefined</code>。在ES6之前，设置默认参数一般是在函数体中判断函数值是否为undefined，如果是则赋给这个参数一个默认值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ? b : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6中可以使用以下写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p><code>rest</code>语法允许将不确定数量的参数表示成一个数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="params">x</span> =&gt;</span> a * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数表达式相比函数表达式具有较短的语法并以词法的形式绑定<code>this</code>。箭头函数总是匿名的。</p>
<h5 id="更简洁的函数"><a href="#更简洁的函数" class="headerlink" title="更简洁的函数"></a>更简洁的函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [</span><br><span class="line">  <span class="string">"Hydrogen"</span>,</span><br><span class="line">  <span class="string">"Helium"</span>,</span><br><span class="line">  <span class="string">"Lithium"</span>,</span><br><span class="line">  <span class="string">"Beryllium"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arrs.map(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123; <span class="keyword">return</span> s.length &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// logs [ 8, 6, 7, 9 ]</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arrs.map( <span class="function"><span class="params">s</span> =&gt;</span> s.length );</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// logs [ 8, 6, 7, 9 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h4><p>在箭头函数之前，每一个函数都重新定义了自己的<code>this</code>值(在构造函数中是一个新的对象，在严格模式下是undefined，在作为对象方法调用的函数中指向这个对象)。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);    <span class="comment">// undefined</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>在ES3或ES5中，通过把<code>this</code>的值赋值给一个变量赋值给一个变量可以修复这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.age);    <span class="comment">// 0</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>使用箭头函数可以捕捉闭包上下文的this值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.age);    <span class="comment">// 0</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>


<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云代码托管平台托管博客图床</title>
    <url>/%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A.html</url>
    <content><![CDATA[<blockquote>
<p>无折腾，不青春</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>博客的图床在试过QQ空间相册(防盗链)，百度网盘(时间限制)之后，发现还是需要一个稳定点的图床比较好。github够稳定但是网速是在不敢恭维，突然想起之前在做<a href="https://github.com/musistudio/wukong-robot-install-script" target="_blank" rel="noopener">wukong-robot-install-script</a>的时候我用用过<a href="https://code.aliyun.com/" target="_blank" rel="noopener">阿里云的代码托管平台</a>进行仓库加速，使用的时候速度的确挺快的。那能不能使用这个来托管博客的图床呢？</p>
<a id="more"></a>

<h4 id="折腾开始"><a href="#折腾开始" class="headerlink" title="折腾开始"></a>折腾开始</h4><ol>
<li><p>首先打开阿里云的代码托管平台，使用阿里云账号登录后新建一个项目。名称随意，描述随意，可见等级选Public。如下图所示:<br><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-09-52.jpg" alt="新建项目示意图"></p>
</li>
<li><p>项目建好后在首页点击设置进入账户设置页，然后点击SSH公钥选项将自己电脑的公钥粘贴到这里。如果不知道怎么操作网页上有操作指示</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-13-21.jpg" alt="上传公钥示意图"></p>
</li>
<li><p>公钥上传好后打开刚刚新建的项目，复制该链接clone到电脑本地，git的具体操作这里不再赘述。</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-16-03.jpg" alt=""></p>
</li>
<li><p>以后要上传图片的时候将图片复制到这里然后再提交一次Push就可以啦。为方便Typora食用，我写了个自动上传脚本，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "------welcom to use upload-image programme------"</span><br><span class="line">echo "maked by musi"</span><br><span class="line">DIR="$( cd "$( dirname "$0"  )" &amp;&amp; pwd  )"</span><br><span class="line">cd $DIR</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    echo $i</span><br><span class="line">    cp $i ./</span><br><span class="line">done</span><br><span class="line">git add .</span><br><span class="line">git commit -m"auto upload by upload-image.sh"</span><br><span class="line">git push</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    array=(`echo $i | tr '/' ' '` )  </span><br><span class="line">    lens=$&#123;#array[*]&#125;</span><br><span class="line">    echo "https://code.aliyun.com/qingshanglishao/images/raw/master/"$&#123;array[$lens-1]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>再配置一下Typora就能很方便的食用啦</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_10-40-32.jpg" alt="Typora配置示意图"></p>
</li>
</ol>
<h4 id="折腾结束"><a href="#折腾结束" class="headerlink" title="折腾结束"></a>折腾结束</h4><p>正所谓工欲善其事必先利其器，有一套顺手的工具是写好博客的开始。如果你有什么食用顺手的工具欢迎在下方评论与我交流。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>对象模型的细节</title>
    <url>/wiki/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82.html</url>
    <content><![CDATA[<blockquote>
<p>JavaScript是基于原型的语言，它只有对象。原型对象可以作为一个模板，新对象可以从中获得原始的属性。任何对象都可以在创建对象时或在运行时指定其自身的属性。此外，任何对象都可以关联另一个对象的原型，从而允许第二个对象共享第一个对象的属性。</p>
</blockquote>
<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><p>在基于类的语言中，需要专门的类的定义来定义类。在定义类时，允许定义被称为构造器的特殊方法来创建该类的实例。在构造器方法中，可以指定实例的属性的初始值并做一些其他的操作。可以通过使用<code>new</code>操作符来创建对象的实例。</p>
<p>JavaScript没有专门的类定义。可以通过定义构造函数的方式来创建一系列有着特定初始值和方法的对象。任何JavaScript函数都可以被用作构造函数，可以使用<code>new</code>操作符来创建一个新对象。</p>
<h4 id="子类和继承"><a href="#子类和继承" class="headerlink" title="子类和继承"></a>子类和继承</h4><p>在基于类的语言中，可以通过类定义来创建类的层次结构，在类的定义中，可以指定新类是已经存在类的子类，子类继承父类的所有属性，并且可以添加新属性和修改继承的属性。JavaScript通过将构造函数与原型对象相关联的方式来实现继承。</p>
<h3 id="添加和移除属性"><a href="#添加和移除属性" class="headerlink" title="添加和移除属性"></a>添加和移除属性</h3><p>在基于类的语言中，通常在编译时创建一个类，然后在编译时或运行时实例化该类的实例。定义类后，无法更改类的数量或属性类型。但在JavaScript中可以在运行时添加或修改任何对象的属性，如果为一个对象添加了一个属性，而这个对象有作为其他对象的原型，则以该对象为原型的所有其他对象也将获得该属性。</p>
<h3 id="基于类的对象和基于原型的对象差异"><a href="#基于类的对象和基于原型的对象差异" class="headerlink" title="基于类的对象和基于原型的对象差异"></a>基于类的对象和基于原型的对象差异</h3><table>
<thead>
<tr>
<th align="center">基于类的对象</th>
<th align="center">基于原型的对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类和实例是不同的事物</td>
<td align="center">所有对象均为实例</td>
</tr>
<tr>
<td align="center">通过类定义来定义类，通过构造函数来实例化类</td>
<td align="center">通过构造函数来定义和创建一组对象</td>
</tr>
<tr>
<td align="center">通过<code>new</code>操作符来创建单个对象</td>
<td align="center">相同</td>
</tr>
<tr>
<td align="center">通过类定义来定义现存类的子类，从而构建对象的层级结构</td>
<td align="center">指定一个对象作为原型并且与构造函数一起构建对象的层级结构</td>
</tr>
<tr>
<td align="center">遵循类链继承属性</td>
<td align="center">遵循原型链继承属性</td>
</tr>
<tr>
<td align="center">类定义指定类的所有实例的所有属性，无法在运行时动态添加属性</td>
<td align="center">构造函数或原型指定实例的初始属性集，允许动态地向单个的对象或者整个对象集中添加或移除属性</td>
</tr>
</tbody></table>
<h3 id="继承层级结构示例"><a href="#继承层级结构示例" class="headerlink" title="继承层级结构示例"></a>继承层级结构示例</h3><p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/employee.png" alt="employee"></p>
<ul>
<li><code>Employee</code>具有<code>name</code>属性(默认为空字符串)和<code>dept</code>属性(默认为<code>general</code>)</li>
<li><code>Manager</code>是<code>Employee</code>的子类，它添加了<code>reports</code>属性(默认为空数组，以<code>Employee</code>对象数组作为他的值)</li>
<li><code>WokerBee</code>是<code>Employee</code>的子类，它它添加了<code>projects</code>属性(默认为空数组，以字符串数组作为它的值)</li>
<li><code>SalesPerson</code>是<code>WorkBee</code>的子类，它添加了<code>quota</code>属性(默认为100)，重载了<code>dept</code>属性值为<code>sales</code>，表明所有的销售人员都同属于同一部门</li>
<li><code>Engineer</code>基于<code>WorkerBee</code>，它添加了<code>machine</code>属性(默认为空字符串)，重载了<code>dept</code>属性为<code>engineering</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Employee对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, dept</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name === <span class="literal">undefined</span> ? <span class="string">''</span> : name;</span><br><span class="line">  <span class="keyword">this</span>.dept = dept === <span class="literal">undefined</span> ? <span class="string">'general'</span> : dept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Manager对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.reports = [];</span><br><span class="line">&#125;</span><br><span class="line">Manager.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br><span class="line"><span class="comment">// 定义WorkerBee对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.projects = [];</span><br><span class="line">&#125;</span><br><span class="line">WorkerBree.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br><span class="line"><span class="comment">// 定义SalesPerson对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SalesPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.quota = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'sales'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SalesPerson.prototype = <span class="built_in">Object</span>.create(WorkerBree.prototype);</span><br><span class="line"><span class="comment">// 定义Engineer对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.machine = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'engineering'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Engineer.prototype = <span class="built_in">Object</span>.create(WorkerBree.prototype);</span><br></pre></td></tr></table></figure>

<h4 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h4><h5 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象实例化</span></span><br><span class="line"><span class="keyword">var</span> mark = <span class="keyword">new</span> WorkerBee;</span><br><span class="line"></span><br><span class="line">mark.name = <span class="string">""</span>;</span><br><span class="line">mkrk.dept = <span class="string">"general"</span>;</span><br><span class="line">mark.projects = [];</span><br></pre></td></tr></table></figure>

<p>当JavaScript执行<code>new</code>操作符时，它会先创建一个普通对象，并将这个普通对象中的[[prototype]]指向<code>WorkBee.prototype</code>，然后再把这个普通对象设置为执行<code>WorkBee</code>构造函数时的<code>this</code>值。该普通对象的[[prototype]]决定其用于检索属性的原型链。当构造函数执行完成后，所有的属性都被设置完毕，JavaScript返回之前创建的对象，通过赋值语句将他的引用赋值给变量<code>mark</code>。</p>
<p>这个过程不会显示的将<code>mark</code>所继承的原型链中的属性作为本地属性存放在<code>mark</code>对象中。当访问属性时，JavaScript将首先检查对象自身中是否存在该属性，有则返回该属性的值。如果不存在，则会检查原型链(使用内置的prototype属性)。如果原型链中的某个对象包含该属性，则返回这个属性的值。如果遍历整个原型链都没有找到该属性，则返回<code>undefined</code>。</p>
<p>Employee构造函数为mark对象分配了name和dept的属性值。WorkerBee的构造函数分配了project属性值。这就是JavaScript中的属性和属性值继承。</p>
<p>在JavaScript中，可以在运行时为任何对象添加属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加特定于某个对象的属性</span></span><br><span class="line">mark.bonus = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向构造函数的原型对象添加新的属性，该属性将添加到从这个原型中继承属性的所有对象中</span></span><br><span class="line">Employee.prototype.specialty = <span class="string">"none"</span>;</span><br></pre></td></tr></table></figure>

<h5 id="本地属性和继承属性"><a href="#本地属性和继承属性" class="headerlink" title="本地属性和继承属性"></a>本地属性和继承属性</h5><p>在访问一个对象的属性时，JavaScript将进行以下操作：</p>
<ol>
<li>检查对象自身是否存在。如果存在，返回值。</li>
<li>如果本地值不存在，检查原型链</li>
<li>如果原型链中的某个对象具有指定属性，则返回值。</li>
<li>如果这样的属性不存在，则没有该属性，返回undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'general'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.projects = [];</span><br><span class="line">&#125;</span><br><span class="line">WorkerBee.prototype = <span class="keyword">new</span> Employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建WorkerBee的实例amy</span></span><br><span class="line"><span class="keyword">let</span> amy = <span class="keyword">new</span> WorkerBee;</span><br><span class="line">amy.name == <span class="string">''</span>;         <span class="comment">// 继承属性</span></span><br><span class="line">amy.dept == <span class="string">'general'</span>;  <span class="comment">// 继承属性</span></span><br><span class="line">amy.projects = [];      <span class="comment">// 本地属性</span></span><br></pre></td></tr></table></figure>

<h4 id="判断实例的关系"><a href="#判断实例的关系" class="headerlink" title="判断实例的关系"></a>判断实例的关系</h4><p>JavaScript中的属性查找在对象自身的属性内查找，如果未找到属性名称，则在特殊对象属性<code>__proto__</code>中查找。这个过程是递归的，这被称为在原型链中查找。</p>
<p>特殊的<code>__proto__</code>属性是在构建对象中设置的。设置为构造器的prototype属性的值。所以表达式<code>new Foo()</code>将创建一个对象。其<code>__proto__ == Foo.prototype</code>。因而，修改<code>Foo.prototype</code>的属性，将改变所有通过<code>new Foo()</code>创建的对象的属性的查找。</p>
<p>每个对象都有一个<code>__proto__</code>对象属性(Object除外)。每个函数都有一个<code>prototype</code>对象属性。因此，通过原型继承对象就可以与其他对象之间形成关系。通过比较对象的<code>__proto__</code>属性和<code>prototype</code>属性可以检测对象的继承关系。JavaScript提供了便捷的方法：<code>instanceof</code>操作符可以用来将一个对象和一个函数做检测，如果对象继承自函数的原型则返回true：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面的Engineer的例子</span></span><br><span class="line"><span class="keyword">var</span> chris = <span class="keyword">new</span> Engineer(<span class="string">"Pigman, Chris"</span>, [<span class="string">"jsd"</span>], <span class="string">"fiji"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chris.__proto__ == Engineer.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(chris.__proto__.__proto__ == WorkerBee.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(chris.__proto__.__proto__.__proto__ == Employee.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(chris.__proto__.__proto__.__proto__.__proto__ == <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(chris.__proto__.__proto__.__proto__.__proto__.__proto__ == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">object, constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(object != <span class="literal">null</span>) &#123;</span><br><span class="line">  	<span class="keyword">if</span>(object == <span class="keyword">constructor</span>.prototype) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> object == <span class="string">'xml'</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">constructor</span>.prototype == XML.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    object = object.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">  reurn false;</span><br><span class="line">&#125;</span><br><span class="line">instanceOf (chris, Engineer);    // true</span><br><span class="line">instanceOf (chris, WorkerBee);   // true</span><br><span class="line">instanceOf (chris, Employee);    // true</span><br><span class="line">instanceOf (chris, Object);      // true</span><br></pre></td></tr></table></figure>

<h4 id="构造器中的全局属性"><a href="#构造器中的全局属性" class="headerlink" title="构造器中的全局属性"></a>构造器中的全局属性</h4><p>在创建构造器时，在构造器中修改全局属性要慎重：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> idCounter = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, dept</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = dept || <span class="string">'general'</span>;</span><br><span class="line">  <span class="keyword">this</span>.id = idCounter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> victoria = <span class="keyword">new</span> Employee(<span class="string">'victoria'</span>, <span class="string">'public'</span>);   <span class="comment">// victoria.id = 1</span></span><br><span class="line"><span class="keyword">var</span> harry = <span class="keyword">new</span> Employee(<span class="string">'harry'</span>, <span class="string">'sales'</span>);          <span class="comment">// harry.id = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每一次创建Employee对象时，idCounter都将被递增一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Manager.prototypr = <span class="keyword">new</span> Employee();    <span class="comment">// 此时idCounter也将被递增一次</span></span><br></pre></td></tr></table></figure>

<h4 id="没有多重继承"><a href="#没有多重继承" class="headerlink" title="没有多重继承"></a>没有多重继承</h4><p>某些面向对象语言支持多重继承(Python)，对象可以从无关的父对象中继承属性和属性值。JavaScript不支持多重继承。JavaScript的属性继承是在运行时通过检索对象的原型链来实现的，因为对象只有一个原型与之关联，所以JavaScript无法动态的从多个原型链中继承。</p>
<p>在JavaScript中，可以在构造函数中调用多个其他的构造函数，造成了多重继承的假象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hobbist</span>(<span class="params">hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby || <span class="string">'code'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span>(<span class="params">name, projs, mach, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base1 = WorkerBee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, <span class="string">'engineering'</span>, projs);</span><br><span class="line">  <span class="keyword">this</span>.base2 = Hobbist;</span><br><span class="line">  <span class="keyword">this</span>.base2(hobby);</span><br><span class="line">  <span class="keyword">this</span>.mach = mach || <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">Engineer.prototype = <span class="keyword">new</span> WorkerBee;</span><br><span class="line"><span class="keyword">var</span> dennis = <span class="keyword">new</span> Engineer(<span class="string">'Dennis'</span>, [<span class="string">'test'</span>], <span class="string">'hugo'</span>);</span><br><span class="line"></span><br><span class="line">dennis.name == <span class="string">'Dennis'</span>;</span><br><span class="line">dennis.dept == <span class="string">'engineering'</span>;</span><br><span class="line">dennis.peojects == [<span class="string">'test'</span>];</span><br><span class="line">dennis.machine == <span class="string">'hugo'</span>;</span><br><span class="line">dennis.hobby == <span class="string">'codde'</span>;</span><br><span class="line"></span><br><span class="line">Hobbyist.prototype.equipment = [<span class="string">"mask"</span>, <span class="string">"fins"</span>, <span class="string">"regulator"</span>, <span class="string">"bcd"</span>]</span><br><span class="line">dennis.equipment == <span class="literal">null</span>;    <span class="comment">// 不会继承</span></span><br></pre></td></tr></table></figure>



<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>大学蒙太奇</title>
    <url>/life/%E5%A4%A7%E5%AD%A6%E8%92%99%E5%A4%AA%E5%A5%87.html</url>
    <content><![CDATA[<p>转眼已经大学毕业了，回想起三年前那个拿着录取通知书来报道的我，还仿若昨日。算算拿到毕业证已经有两天了，便以这篇文章来记录一下我的大学生活吧，也算是没浪费这三年的光阴。至于名字，借鉴于<a href="https://www.hahack.com/" target="_blank" rel="noopener">潘伟洲</a>的年度总结，用蒙太奇手法记录我的大学生活，倒也比较合适。</p>
<a id="more"></a>

<h2 id="2017-初入校园-打比赛-入“逍遥”"><a href="#2017-初入校园-打比赛-入“逍遥”" class="headerlink" title="2017 初入校园 打比赛 入“逍遥”"></a>2017 初入校园 打比赛 入“逍遥”</h2><p>还记得在军训时，我就被黄老大找到，说要带带我。当初我单纯的就是张小白纸，并不知道这个“带带”是什么意思，也没去多想。我怎么也不会想到这句话给我整个的大学生涯造成了巨大的影响。</p>
<p>军训结束后，黄老师再次找到了我，想让我参加比赛。出于好奇和学习技术的心理，我当时想也不想的就答应了。于是我在学校的第一个国庆节以泡在实训楼度过。当时还没有“逍遥“社，便在电子焊接室里准备着比赛。虽然之前没参加过，但因为高中接触过编程和对编程的喜爱倒也不是畏惧，但我怎么也没想到的是”比赛“贯穿了我整个大学生涯。大学里的社团我也参加了不少，爱网、蜗壳、电子、3D打印……后来便去了逍遥，其他的社团活动也没怎么参与了，除了3D打印社</p>
<p>10月底，我参加了阿里巴巴举办的杭州云栖大会。虽然我在高中时就已经参加过北京的峰会，但这里毕竟是杭州，是阿里的大本营，杭州峰会和北京峰会简直就是天差地别。各种新兴技术各种展厅看的我眼花缭乱，晚上音乐节也有幸见到了马云老师，也不枉我冒雨看完这一场露天音乐会。</p>
<div style="display: block">
  <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/WechatIMG248.jpeg" style="zoom:20%;display: inline-block" />
  <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0782.JPG" style="zoom:33%;display: inline-block" />
</div>



<p>在随后的一个多月里，我一边上着课，一边操心着班级活动(当时我是学习委员)，一边准备着比赛，由于学习委员要收集班级同学的作业再交给老师，但是同学们教的时间过于分散，我也没那么多精力去一个一个接受再整理，于是开发了一个上传作业的系统，总算是解放了我的生产力，可以安心弄比赛了。我的任务是做一个小程序和单片机进行通信，17年小程序刚出来不久，我也没接触过，只能硬着头皮一边学一边做了，为此没少熬夜。除了比赛，其他事我也没闲着：闲着无聊扫了一下校园网找到了一个漏洞，随后开发了一个免费且不断网的工具，自用了一个月发到班级群后被图书馆老师修复了(我万万没想到教我SQL Server的是图书馆信息中心的老师)。</p>
<p>经过两个多月的努力总算得到了回报：浙江省高职院校挑战杯二等奖。我的第一次比赛以省二落幕，同时落幕的还有我在大学里的第一个学期。</p>
<h2 id="2018-步入大二-继续努力"><a href="#2018-步入大二-继续努力" class="headerlink" title="2018 步入大二 继续努力"></a>2018 步入大二 继续努力</h2><p>大一的下学期就要面对分流了，对于我这种高中就把自己的职业生涯规划好了的人来说，选专业从来就不是问题。刚好分流考试赶上了大学生三创赛的准备期间，出于对比赛成绩的考虑，我们组的电商方向的分流考试免了。当然，成绩也不负所望，我们获得了省赛一等奖，于是我们组包揽了电商分流考试的前四名。这就是比赛的魅力，免考第一！</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0775.JPG" style="zoom:20%;" />

<p>同年暑假，我们继续参加了浙江省大学生互联网+大赛，这个比赛就比较厉害了，如果你是本科生，拿到了省赛一等奖会直接保研。听名字就瑟瑟发抖，虽然我们做足了准备，但最后成绩仍然不够理想。但是没关系，路还长，下次继续加油呗。有一句话怎么说的来着：比赛前：与天下棋，胜天半子。比赛时：尽人事以听天命。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0777.JPG" style="zoom:20%;" />

<p>经过几次比赛，我也成长了不少，也不再是当初那个懵懂无知的小白了。比赛给我的最大收货不是荣誉，不是奖金(虽然一开始的确是冲着奖金去的，不然我怎么集齐苹果全家桶)，而是每次比赛前沉下心来钻研技术以及和团队配合练习答辩的感觉。这一年除了比赛，我的技术积累也没闲着：放弃了PHP开发转向Python。主次之外我也比较喜欢折腾：装Linux系统、玩Kali、折腾树莓派、DDOS……有时候甚至可以通宵实现一个小玩意儿，就为了那实现功能之后的满足感。之前还有一次，学校的同学收到了大量的钓鱼邮件，还有些同学上当受骗的，于是我用DDOS攻击把我知道的钓鱼网站都给打挂了，这也算是我为学校出的一份力吧。戴上福克斯面具，还真有点“黑客”的感觉，虽然我是真崇拜<code>Anonymous</code>，所以也买了一些社会工程学的书来读。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0792.JPG" style="zoom:40%;" />

<p>九月份，我受邀于Jetbrains公司在云栖大会期间到他们展位上做志愿者，这是我第二次去杭州云栖大会，这次就显得轻车熟路。志愿者的工作内容也很简单，就是了解的就介绍一下工具集，然后发发小礼品之类。但他们展会会有一个技术分享，这就很吸引我，有布道师坐在你面前演示的机会可不多，于是我又认识了范圣佑大佬。不知道怎的就感觉和他聊天很有趣。</p>
<div style="display: vlock">
  <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0783.JPG" style="zoom:18%;display: inline-block" />
    <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0785.JPG" style="zoom:25%;display: inline-block" />
</div>



<p style="clear:both;padding-top:30px">2018年已经过去了一大半，但我的比赛还未结束，十月份，我们参加了大学生职业生涯规划大赛。令我意外的是，歌手叶炫清也参加了这场比赛(还记得17年的时候经常单曲循环双世宠妃的主题曲)</p>

<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/psb.jpeg" style="zoom:20%;" />



<p>最后我们的成绩也和”叶学姐“的成绩一样：省一。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0768.JPG" style="zoom:33%;" />

<p>2018，至此结束。</p>
<h2 id="2019-职场初体验-比赛终结"><a href="#2019-职场初体验-比赛终结" class="headerlink" title="2019 职场初体验 比赛终结"></a>2019 职场初体验 比赛终结</h2><p>早就了解到大三要去实习，于是在年初的时候我就先去体验”面试“的感觉。寒假的时候学习了Latex排版技术于是在github上找了一份简历自己对照着改了改，随后投了几家公司，也接收到几家公司的面试邀请。与此同时，潘伟洲也帮我内部推荐了几家公司，其中就包括鹅厂。可能是第一次有点紧张，也有可能是准备不充分，最后毫无意外的全部挂了，到现在我才发现我的不足：之前比赛对于技术的要求都是野蛮式增长的，没有时间将技术沉淀下来。于是在随后的几个月里我开始潜心学习技术，对比赛也不再那么上心了。倒是有和潘伟洲一起参加了杨超越编程大赛，最后成绩竟然是投票制的，我们一不刷票，二不怎么拉票，所以成绩也不是很好。</p>
<p><video src="https://code.aliyun.com/qingshanglishao/images/raw/master/4b6db841e1349be5583b24f0a8dc94a3.MP4" style="height: 200px;" controls="controls"></video></p>
<p>随后就去虹软公司实习了两周，两周结束后我又回来了。暑假期间先后参加了互联网+比赛和Ti杯大学生电子设计竞赛，最终名次都是省三。这时候，我已经不再看重比赛结果了，相比于比赛结果我更关注于自身技术的成长。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0793.JPG" style="zoom:20%;transform: rotate(270deg)" />

<p>九月份，再次受邀与JetBrains公司做云栖大会展位的志愿者。连续参加了三届云栖大会，科技展会远没有一开始的那么吸引我了，我更关注的是和我职业相关的技术的发展。</p>
<div style="text-align: center;">
  <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0786.JPG" style="zoom:33%;" />
  <img src="https://code.aliyun.com/qingshanglishao/images/raw/master/IMG_0787.JPG" style="zoom:20%;transform: rotate(270deg);margin-top: -200px;" />
</div>

<p>大三上学期的时候我再次参加了大学生挑战杯比赛，我的比赛生涯始于挑战杯，止于挑战杯，比赛终结了……</p>
<h2 id="2020-些许遗憾-收拾行囊再出发"><a href="#2020-些许遗憾-收拾行囊再出发" class="headerlink" title="2020 些许遗憾 收拾行囊再出发"></a>2020 些许遗憾 收拾行囊再出发</h2><p>受疫情影响，学校于五月份才开学。今年的毕业季注定与往年的不同：没有毕业典礼、没有学士服、就连毕业照都是p上去的，在强大的photoshop面前我望着那一个个陌生的脸庞竟都不认识了……这其中的一些人，很有可能这辈子再也不会见面了，我们对于彼此来说只是匆匆过客。对于这所学校，尽管我在学校时说学校的千般不好，但在这离别之际我竟然会有一丝伤感，可能是我不舍学生的这个身份吧，学校对于社会来说还是太单纯了。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/WechatIMG250.jpeg" style="zoom:25%;transform: rotate(270deg)" />

<p>尽管我的大学不向别人那样充斥着各种活动和兼职，但我参加过比赛，去过云栖见过马老师，认识了来自JetBrains的大佬，参与了开源项目，同时也谈了恋爱，创了业，也算不负这三年的时光！</p>
<p>此后：</p>
<p style="text-align:right">校园”无忧“，你自“逍遥”。江湖路远，我自驰骋。</p>

<p style="text-align:right">今生我们有缘再见！</p>]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>带键集合</title>
    <url>/wiki/%E5%B8%A6%E9%94%AE%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h4><p>ES6新增Map对象用于将一个值映射到另一个值，一个Map对象就是一个简单的键值对映射集合，并可以按照数据插入时的顺序遍历所有的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayings = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">sayings.set(<span class="string">'dog'</span>, <span class="string">'woof'</span>);</span><br><span class="line">sayings.set(<span class="string">'cat'</span>, <span class="string">'meow'</span>);</span><br><span class="line">sayings.set(<span class="string">'elephant'</span>, <span class="string">'toot'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayings.size);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sayings.get(<span class="string">'fox'</span>)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sayings.get(<span class="string">'dog'</span>));   <span class="comment">// woof</span></span><br><span class="line"><span class="built_in">console</span>.log(sayings.has(<span class="string">'dog'</span>));   <span class="comment">// true</span></span><br><span class="line">sayings.delete(<span class="string">'dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayings.has(<span class="string">'dog'</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> sayings) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> goes <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dog goes woof</span></span><br><span class="line"><span class="comment">// cat goes meow</span></span><br><span class="line"><span class="comment">// elephant goes toot</span></span><br><span class="line">sayings.clear();</span><br><span class="line"><span class="built_in">console</span>.log(sayings.size);    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>Object与Map的区别：</p>
<ul>
<li>Object的键均为String类型，在map里键可以是任意类型。</li>
<li>Object的长度必须手动计算。</li>
<li>Map的遍历遵循元素的插入顺序。</li>
<li>Object有prototype，映射中有一些缺省的键，可以使用<code>Object.create(null)</code>回避。</li>
</ul>
<p>下面三点可以决定用Object还是Map:</p>
<ul>
<li>如果键在运行时才知道，或者所有的键类型相同，所有的值类型相同，使用Map。</li>
<li>如果需要将原始值存储为键，则使用map。Object将每个键视为字符串，不管是数字布尔值还是其他原始类型。</li>
<li>如果需要对个别元素进行操作，使用Object。</li>
</ul>
<h4 id="WeakMap对象"><a href="#WeakMap对象" class="headerlink" title="WeakMap对象"></a>WeakMap对象</h4><p>WeakMap对象也是键值对的集合，但它的键必须是对象类型，值可以是任意类型。它的键被弱保持，当其值所指对象没有其他地方引用的时候，它会被GC回收掉。WeakMap的键是不可枚举的。</p>
<p>WeakMap常被用来存储一个对象的私有数据或实现细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">consr privates = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Public</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> me = &#123;&#125;;    <span class="comment">// 私有数据</span></span><br><span class="line">  privates.set(<span class="keyword">this</span>, me);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public.prototype,method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> me = privates.get(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Public;</span><br></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="set对象"><a href="#set对象" class="headerlink" title="set对象"></a>set对象</h4><p>Set对象是一组数据的集合，这些值是不重复的，可以按照添加顺序来遍历：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">mySet.add(<span class="number">1</span>);</span><br><span class="line">mySet.add(<span class="string">'test'</span>);</span><br><span class="line">mySet.add(<span class="number">2</span>);</span><br><span class="line">mySet.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mySet.size);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.has(<span class="number">1</span>));  <span class="comment">// true             </span></span><br><span class="line">mySet.delete(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mySet.size);    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) <span class="built_in">console</span>.log(item);</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合转数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(mySet));    <span class="comment">// ["test", 2]</span></span><br><span class="line"><span class="built_in">console</span>.log([...mySet]);           <span class="comment">// ["test", 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转集合</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>在JavaScript中一般使用数组来存储一组数据，集合对象有以下优势：</p>
<ul>
<li>数组中<code>indexOf</code>函数效率低下</li>
<li>Set对象允许根据值删除元素，而数组必须使用基于下标的splice方法</li>
<li>数组的<code>indexOf</code>方法无法找到<code>NaN</code>值</li>
<li>Set对象存储不重复的值，所以不需要手动处理包含重复值的情况</li>
</ul>
<h4 id="WeakSet对象"><a href="#WeakSet对象" class="headerlink" title="WeakSet对象"></a>WeakSet对象</h4><p>WeakSet中的对象不重复且不可枚举，并且值必须是对象类型。如果集合中的对象不存在其他引用，则该对象将会被垃圾回收。</p>
<h3 id="Map和Set的键和值相等判断"><a href="#Map和Set的键和值相等判断" class="headerlink" title="Map和Set的键和值相等判断"></a>Map和Set的键和值相等判断</h3><p>Map对象的键相等性和Set对象的值相等性均基于same-value-zero算法</p>
<ul>
<li>判断使用与<code>===</code>相似的规则。</li>
<li><code>-0</code>和<code>+0</code>相等。</li>
<li><code>NaN</code>与自身相等(与<code>===</code>有所不同)</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Keyed_Collections" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习的方法论一：知识溯源法</title>
    <url>/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA%E4%B8%80%EF%BC%9A%E7%9F%A5%E8%AF%86%E6%BA%AF%E6%BA%90%E6%B3%95.html</url>
    <content><![CDATA[<blockquote>
<p>有一千个读者，就有一千个哈姆雷特</p>
</blockquote>
<h4 id="什么是知识溯源法"><a href="#什么是知识溯源法" class="headerlink" title="什么是知识溯源法"></a>什么是知识溯源法</h4><p>在学习本方法之前我们先来看看百度百科的定义。</p>
<blockquote>
<p><em>溯源</em>法是一种追究根源的逆向思维方式，也是一种以倒推的方式追寻原因而达到解决问题的工作方式。</p>
</blockquote>
<p>我的理解就是对知识的起源做一个探寻。计算机的历史距今也不算太久，第一台图灵完备的电子计算机ENIAC诞生于1946年，所以计算机编程的相关知识大多都是可溯源的。</p>
<a id="more"></a>

<h4 id="为什么要对知识进行溯源"><a href="#为什么要对知识进行溯源" class="headerlink" title="为什么要对知识进行溯源"></a>为什么要对知识进行溯源</h4><p>可以帮助我们了解该知识出现的历史背景，为什么会出现以及该知识所带来的影响。虽然网上现在的资料多到数不胜数，其中也不乏有一些大佬们的总结，读这些文章固然可以帮我们理解该知识点（站在巨人的肩膀上），但如果我们能拿到第一手资料的话或许我们会有一些不一样的理解（有一千个读者就有一千个哈姆雷特）。</p>
<h4 id="怎么对知识进行溯源"><a href="#怎么对知识进行溯源" class="headerlink" title="怎么对知识进行溯源"></a>怎么对知识进行溯源</h4><p>下面我会以对<strong>面向对象编程(object-oriented programming)</strong>这个概念进行溯源为例：</p>
<ol>
<li><p>通过google查询object-oriented programming出现的历史，我在维基百科(wikipedia)中找到了这个词的History。摘抄部分如下：</p>
<blockquote>
<p>Terminology invoking “objects” and “oriented” in the modern sense of object-oriented programming made its first appearance at MIT in the late 1950s and early 1960s. In the environment of the artificial intelligence group, as early as 1960, “object” could refer to identified items (LISP) atoms) with properties (attributes);Alan Kay was later to cite a detailed understanding of LISP internals as a strong influence on his thinking in 1966</p>
</blockquote>
<p>大概意思就是面向对象这个术语最早出现在19世纪50年代末到60年代初，后来Alan Kay这个人详细的解释了这个术语的含义。</p>
</li>
<li><p>随后我在<a href="https://scholar.google.com" target="_blank" rel="noopener">谷歌学术</a>找到了Alan Kay发给别人的邮件阐述他对于object-oriented programming的理解。<a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" target="_blank" rel="noopener">原文在这里</a>，摘抄部分如下:</p>
<blockquote>
<p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other<br>systems in which this is possible, but I’m not aware of them.</p>
</blockquote>
<p>大概意思就是面向对象操作仅意味着消息传递，本地保留和保护以及隐藏状态过程。</p>
<blockquote>
<p>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning – it took a while to see how to do messaging in a programming language efficiently enough to be useful).</p>
</blockquote>
<p>正如Alan Kay说的，每个对象就像生物细胞那样，只负责消息传递，而代谢的任务则由细胞内部完成，外部不必介入。这不正是面向对象编程的三大特性之一的<strong>封装</strong>么。</p>
<blockquote>
<p>The term “polymorphism” was imposed much later (I think by Peter Wegner) and it isn’t quite valid.</p>
</blockquote>
</li>
<li><p>Alan Kay提到他认为多态性是由Peter Wegner提出的，所以接下来继续通过谷歌学术搜到了这个人的论文</p>
<p><a href="https://dl.acm.org/doi/abs/10.1145/382192.383004" target="_blank" rel="noopener">《Concepts and paradigms of object-oriented programming》</a>。论文中提到</p>
<blockquote>
<p> Inheritance is a mechanism for sharing and reusing behavior. It is distinguished from other behavior sharing mechanisms by delayed binding of self-reference so that<br>superclasses may merge their identity with the subclasses that inherit them. </p>
</blockquote>
<p>大概含义就是继承是共享和重用行为的一种机制，它与其他行为共享机制的区别在于延迟了对自我参照的绑定，所以父类可以将其与继承它们的子类合并。</p>
</li>
<li><p>而在他的论文<a href="https://dl.acm.org/doi/abs/10.1145/6041.6042" target="_blank" rel="noopener">《On understanding types, data abstraction, and polymorphism》</a>可以找到他对于多态性的解释，摘抄如下：</p>
<blockquote>
<p>Conventional typed languages, such as Pascal, are based on the idea that functions and procedures, and hence their operands, have a unique type. Such languages are said to be monomorphic, in the sense that every value and variable can be interpreted to be of one and only one type. Monomorphic programming languages may be contrasted with polymorphic languages in which some values and variables may have more than one type. Polymorphic functions are functions whose operands (actual parameters) can have more than one type. Polymorphic types may be defined as types whose operations are applicable to operands of more than one type. </p>
</blockquote>
<p>大概含义就是 多态与单态形成对比，传统类型的语言的函数和过程及其操作数具有唯一的类型，而多态是函数其操作数（实际参数）可以具有多种类型。</p>
</li>
</ol>
<p>到此为止，对面向对象编程的溯源就结束了，在这个过程中，我们了解了其历史，并且重新的认识了面向对象的三大特性。(由于英语比较渣，有些地方可能翻译的不对 欢迎与我反馈)</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>循环与迭代</title>
    <url>/wiki/%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3.html</url>
    <content><![CDATA[<p>JavaScript提供了以下循环语句：</p>
<ul>
<li><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><code>for</code>语句</h4><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>([initialExpression]; [condition]; [incrementExpression])</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>当一个<code>for</code>语句执行的时候，会发生以下过程：</p>
<ol>
<li>如果存在初始化表达式<code>initialExpression</code>则会被执行，该表达式通常会初始化一个或多个循环计数器，还可以声明变量。</li>
<li>计算<code>condition</code>表达式的值，如果<code>condition</code>的值是true，则执行循环中的语句，如果是false，则终止循环。如果<code>condition</code>表达式被忽略了，则值默认为true。</li>
<li>循环中的<code>statement</code>被执行，如果有多个<code>statement</code>，可以使用代码块<code>{}</code>包裹起来。</li>
<li>如果存在更新表达式<code>incrementExpression</code>则执行。</li>
<li>回到步骤2。</li>
</ol>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do...while语句"></a><code>do...while</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>

<p><code>statement</code>在检查<code>condition</code>之前会被执行一次，如果<code>condition</code>的值为true，则会再次执行<code>statement</code>，直到<code>condition</code>的值为false。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i++);</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>条件检测会在每次<code>statement</code>执行前发生，如果<code>condition</code>返回为true，<code>statement</code>会被再次执行并紧接着再次检测<code>condition</code>，如果<code>condition</code>为false，则退出循环。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  n++;</span><br><span class="line">  x += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="labeled语句"><a href="#labeled语句" class="headerlink" title="labeled语句"></a><code>labeled</code>语句</h3><p><code>label</code>提供了带有标识符的语句，可以在程序的其他位置引用它。可以使用<code>label</code>标识循环，然后使用<code>break</code>或者<code>continue</code>语句让程序在指定处中断或是继续循环。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label: </span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p><code>label</code>的值可以是非保留字的任意标识符，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">markLoop:</span><br><span class="line"><span class="keyword">while</span> (theMark === <span class="literal">true</span>) &#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h3><p><code>break</code>语句可以用来终止循环和<code>switch</code>分支语句，或者链接到<code>label</code>语句。</p>
<ul>
<li>当<code>break</code>后不带<code>label</code>时，它会立即终止当前所在的循环或<code>switch</code>语句。</li>
<li>当<code>break</code>后带<code>label</code>时，它会终止指定的带<code>label</code>的语句。</li>
</ul>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> [label];</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">0</span></span><br><span class="line">labelCancelLoops: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"外部循环: "</span> + x);</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">  z = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"内部循环: "</span> + z);</span><br><span class="line">    z += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (z === <span class="number">10</span> &amp;&amp; x === <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> labelCancelLoops;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z === <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span> [label];</span><br></pre></td></tr></table></figure>

<p><code>continue</code>语句可以重新启动(跳过代码块的剩余部分并进入下一个循环)一个<code>while</code>、<code>do-while</code>、<code>for</code>或者<code>label</code>语句。</p>
<ul>
<li>当使用不带<code>label</code>的<code>continue</code>语句时，终止当前这次的循环并执行下一次循环。</li>
<li>当使用带<code>label</code>的<code>continue</code>语句时，它会应用于<code>lebel</code>标识的循环语句。</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n += i;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,3,7,12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> j = <span class="number">10</span>;</span><br><span class="line">checkiandj:</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    checkj:</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((j % <span class="number">2</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span> checkj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(j + <span class="string">' is odd.'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i = '</span> + i);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'j = '</span> + j);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for...in语句"></a><code>for...in</code>语句</h3><p><code>for...in</code>语句指定一个变量名来迭代对象上的所有可枚举属性的属性名。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dump_props</span>(<span class="params">obj, obj_name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    result += obj_name + <span class="string">'.'</span> + i + <span class="string">' = '</span> + obj[i] + <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">'&lt;hr&gt;'</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用<code>for...in</code>语句迭代数组，则有可能除了数字索引之外，还有其他自定义的属性。因此不建议使用<code>for...in</code>语句迭代数组。</p>
</li>
<li><h3 id="for-of语句"><a href="#for-of语句" class="headerlink" title="for...of语句"></a><code>for...of</code>语句</h3><p><code>for...of</code>语句在可迭代对象(<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>arguments</code>等)上创建一个循环，并为每个属性不同的值调用一次迭代(迭代的是属性值)。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">of</span> object)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_statement" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>文本格式化</title>
    <url>/wiki/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript的String类型用于表示文本型的数据，它由无符号整数值(UTF-16)作为元素而组成的集合。字符串在中的每个元素在字符串中占据一个位置。</p>
<h4 id="String字面量"><a href="#String字面量" class="headerlink" title="String字面量"></a>String字面量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用单引号或双引号创建简单字符串</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'string'</span>;    <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"test"</span>;      <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用转义字符创建复杂字符串</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'\'test\''</span>;  <span class="comment">// 'test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制转义序列</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'\xA9'</span>;      <span class="comment">// ©</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unicode转移序列</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="string">'\u00A9'</span>;    <span class="comment">// ©</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unicode字元溢出</span></span><br><span class="line"><span class="comment">// 在ES6中，通过Unicode代码点转义，可以使用十六进制数对任意字符进行转义，这使得使用Unicode转义表示大于0x10FFFF的字符成为可能</span></span><br><span class="line"><span class="string">'\u&#123;2F804&#125;'</span></span><br><span class="line"><span class="string">'\uD874\uDc04'</span>    <span class="comment">// 简单的Unicode转义需要拆分为相应的两个小于0x10FFFF的部分</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p><code>String</code>对象是对原始string类型的封装。</p>
<p>String对象方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>charAt</code>、<code>charCodeAt</code>、<code>codePointAt</code></td>
<td>返回字符串指定位置的字符或者字符编码</td>
</tr>
<tr>
<td><code>indexOf</code>、<code>lastIndexOf</code></td>
<td>分别返回字符串中指定字串的位置或者最后位置</td>
</tr>
<tr>
<td><code>startsWith</code>、<code>endsWith</code>、<code>includes</code></td>
<td>返回字符串是否以指定字符开头、结束包含指定的字符串</td>
</tr>
<tr>
<td><code>concat</code></td>
<td>连接两个字符串并返回新的字符串</td>
</tr>
<tr>
<td><code>fromCharCode</code>、<code>fromCodePoint</code></td>
<td>从指定的Unicode值序列构造一个字符串，这是String类方法，不是实例方法</td>
</tr>
<tr>
<td><code>split</code></td>
<td>通过将字符串分离成一个个子串来把一个String对象分割到一个字符串数组中</td>
</tr>
<tr>
<td><code>slice</code></td>
<td>从一个字符串提取片段并作为新字符串返回</td>
</tr>
<tr>
<td><code>substring</code>、<code>substr</code></td>
<td>分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集</td>
</tr>
<tr>
<td><code>match</code>、<code>replace</code>、<code>search</code></td>
<td>通过正则表达式来工作</td>
</tr>
<tr>
<td><code>toLowerCase</code>、<code>toUpperCase</code></td>
<td>分别返回字符串的小写表示和大写表示</td>
</tr>
<tr>
<td><code>normalize</code></td>
<td>按照指定的一种Unicode正规形式将当前字符串正规化</td>
</tr>
<tr>
<td><code>repeat</code></td>
<td>将字符串内容重复指定次数后返回</td>
</tr>
<tr>
<td><code>trim</code></td>
<td>去掉字符串开头和结尾的空格</td>
</tr>
</tbody></table>
<h4 id="多行模板字符串"><a href="#多行模板字符串" class="headerlink" title="多行模板字符串"></a>多行模板字符串</h4><p>模板字符串是一种允许内嵌表达式的String字面量，其使用<strong>``</strong>符号表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`a is</span></span><br><span class="line"><span class="string">b`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);              <span class="comment">// a is \r\nb</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a is <span class="subst">$&#123;x&#125;</span>`</span>);    <span class="comment">// a is b</span></span><br></pre></td></tr></table></figure>



<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p><code>Intl</code>对象是ECMAScript国际化API的命名空间，它提供了语言敏感的字符串比较、数字格式化和日期时间格式化功能。<code>Collator</code>、<code>NumberFormat</code>和<code>DateTimeFormat</code>对象的构造函数是<code>Intl</code>对象的属性。</p>
<h4 id="日期和时间格式化"><a href="#日期和时间格式化" class="headerlink" title="日期和时间格式化"></a>日期和时间格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// July 17, 2014 00:00:00 UTC</span></span><br><span class="line"><span class="keyword">let</span> july172014 = <span class="keyword">new</span> <span class="built_in">Date</span>(msPerDay * (<span class="number">44</span> * <span class="number">365</span> + <span class="number">11</span> + <span class="number">197</span>));</span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  year: <span class="string">'2-digit'</span>,</span><br><span class="line">  month: <span class="string">'2-digit'</span>,</span><br><span class="line">  day: <span class="string">'2-digit'</span>,</span><br><span class="line">  hour: <span class="string">'2-digit'</span>,</span><br><span class="line">  minute: <span class="string">'2-digit'</span>,</span><br><span class="line">  timeZoneName: <span class="string">'short'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> americanDateTime = <span class="keyword">new</span> <span class="built_in">Intl</span>.DateTimeFormat(<span class="string">'en-US'</span>, options).format;</span><br><span class="line"><span class="built_in">console</span>.log(americanDateTime(july172014));    <span class="comment">// 07/17/14, 08:00 AM GMT+8</span></span><br></pre></td></tr></table></figure>

<h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gasPrice = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(<span class="string">'en-US'</span>, &#123;</span><br><span class="line">  style: <span class="string">'currency'</span>,</span><br><span class="line">  currency: <span class="string">'USD'</span>,</span><br><span class="line">  minimunFractionDigits: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(gasPrice.format(<span class="number">5.259</span>));    <span class="comment">// $5.26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hanDecimalRMBInChina = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(<span class="string">'zh-CN-u-nu-hanidec'</span>, &#123;</span><br><span class="line">  style: <span class="string">'currency'</span>,</span><br><span class="line">  currency: <span class="string">'CNY'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(hanDecimalRMBInChina.format(<span class="string">'1314.52'</span>));    <span class="comment">// ¥一,三一四.五二</span></span><br></pre></td></tr></table></figure>

<h4 id="定序"><a href="#定序" class="headerlink" title="定序"></a>定序</h4><p><code>Collator</code>通常用于字符串比较和排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 德语中有两种不同的排序方式 电话本（phonebook） 和 字典（dictionary）. 电话本排序强调发音, 比如在排序前 “ä”, “ö”等被扩展为 “ae”, “oe”等发音</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Hochberg"</span>, <span class="string">"Hönigswald"</span>, <span class="string">"Holzman"</span>];</span><br><span class="line"><span class="keyword">let</span> germanPhonebook = <span class="keyword">new</span> <span class="built_in">Intl</span>.Collator(<span class="string">"de-DE-u-co-phonebk"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(names.sort(germanPhonebook.compare).join(<span class="string">", "</span>));    <span class="comment">// Hochberg, Hönigswald, Holzman</span></span><br></pre></td></tr></table></figure>



<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中正则表达式也是对象。</p>
</blockquote>
<h4 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JavaScript中创建正则表达式有两种方法：</span></span><br><span class="line"><span class="comment">// 1. 使用正则表达式字面量，如果表达式不变该方法拥有较好的性能</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用RegExp的构造函数</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h4><p>一个正则表达式的模式是由简单字符所构成的<code>/abc/</code>，或是简单和特殊字符的组合<code>/ab*c/</code>。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Text_formatting" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解有限状态机</title>
    <url>/code/%E7%90%86%E8%A7%A3%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.html</url>
    <content><![CDATA[<h2 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h2><p>有限状态机也叫状态机，是一种编程思想或者说是编程范式。在有限状态机中：</p>
<ul>
<li>每个状态都是一个机器<ul>
<li>在每个机器中，可以做计算、存储或输出等等…</li>
<li>所有的机器接受的输入是一致的</li>
<li>状态机的每一个机器本身没有状态，如果我们用函数表示的话，它应该是纯函数(即不依赖于外部环境，无副作用)</li>
</ul>
</li>
<li>每一个机器都知道下一个状态<ul>
<li>每个机器都有确定的下一个状态(Moore)</li>
<li>每个机器根据输入决定下一个状态(Melay)</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="JavaScript中的有限状态机实现-Melay"><a href="#JavaScript中的有限状态机实现-Melay" class="headerlink" title="JavaScript中的有限状态机实现(Melay)"></a>JavaScript中的有限状态机实现(Melay)</h2><ul>
<li><p>每个函数是一个状态，函数参数就是输入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something here</span></span><br><span class="line">  <span class="keyword">return</span> next; <span class="comment">// 返回值作为下一个状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用状态机</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(input) &#123;</span><br><span class="line">	state = state(input); <span class="comment">// 把状态机的返回值作为下一个状态      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="实例：使用状态机匹配字符串”abcdef”"><a href="#实例：使用状态机匹配字符串”abcdef”" class="headerlink" title="实例：使用状态机匹配字符串”abcdef”"></a>实例：使用状态机匹配字符串”abcdef”</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = start;    <span class="comment">// 初始状态为start</span></span><br><span class="line">  <span class="comment">// 遍历整个字符串</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> string) &#123;</span><br><span class="line">    state = state(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state === end; <span class="comment">// 判断最后状态是否是end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'a'</span>) &#123;  <span class="comment">// 如果找到字符'a'则进入foundA状态</span></span><br><span class="line">  	<span class="keyword">return</span> foundA;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foundA</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'b'</span>) &#123;  <span class="comment">// 如果找到字符'b'则进入foundB状态</span></span><br><span class="line">  	<span class="keyword">return</span> foundB;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foundB</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'c'</span>) &#123;  <span class="comment">// 如果找到字符'c'则进入foundC状态</span></span><br><span class="line">  	<span class="keyword">return</span> foundC;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foundC</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'d'</span>) &#123;  <span class="comment">// 如果找到字符'd'则进入foundD状态</span></span><br><span class="line">  	<span class="keyword">return</span> foundD;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foundD</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'e'</span>) &#123;  <span class="comment">// 如果找到字符'a'则进入foundE状态</span></span><br><span class="line">  	<span class="keyword">return</span> foundE;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foundE</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(c === <span class="string">'f'</span>) &#123;  <span class="comment">// 如果找到字符'f'则进入end状态</span></span><br><span class="line">  	<span class="keyword">return</span> end;   </span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数字与日期</title>
    <url>/wiki/%E6%95%B0%E5%AD%97%E4%B8%8E%E6%97%A5%E6%9C%9F.html</url>
    <content><![CDATA[<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>在JavaScript中，数字以双精度64位二进制格式IEEE 754实现(一个介于±2−1023和±2+1024之间的数字，或者大约为±10−308到±10+308，数字精度为53位)。整数数字在运算完毕后，其值在±(253 − 1)内 可以认为是准确的，超出此范围后，数据已无法保证准确性。除了能表示浮点数，还可以表示<code>+Infinity(正无穷)</code>和<code>-Infinity(负无穷)</code>和<code>NaN(不是一个数字)</code>。</p>
<ul>
<li><p>十进制数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123456</span>;    <span class="comment">// 123456</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0888</span>;      <span class="comment">// 888</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0777</span>;     <span class="comment">// 非严格模式下当做八进制处理 511</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制数</p>
<p>二进制数字语法是以0开头，后面接一个大写或小写的拉丁文字母<code>B</code>(即<code>0b</code>或<code>0B</code>)，加入<code>0b</code>后边的数字不是0或1，则会报语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> FLT_SIGNBIT  = <span class="number">0b10000000000000000000000000000000</span>; <span class="comment">// 2147483648</span></span><br><span class="line"><span class="keyword">let</span> FLT_EXPONENT = <span class="number">0b01111111100000000000000000000000</span>; <span class="comment">// 2139095040</span></span><br><span class="line"><span class="keyword">let</span> FLT_MANTISSA = <span class="number">0B00000000011111111111111111111111</span>; <span class="comment">// 8388607</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>b313242;    <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>八进制数</p>
<p>八进制数字语法是以0开头的，加入后面的数字不在0-7的范围内，则会被转成十进制数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0755</span>;    <span class="comment">// 493</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0911</span>;    <span class="comment">// 911</span></span><br></pre></td></tr></table></figure>

<p>在ES5的严格模式下禁止使用八进制语法，八进制语法并不是ES5规范的一部分，但在所有浏览器中都支持八进制语法。在ES6中使用八进制需要给数字添加前缀<code>0o</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0o10</span>;    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制数</p>
<p>十六进制数字语法是以0开头，后接一个小写或大写的拉丁文字母X(即<code>0x</code>或<code>0X</code>)，如果<code>0x</code>后面的数字超过规定的范围，则会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0x123</span>;    <span class="comment">// 291</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0X456</span>;    <span class="comment">// 1110</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0</span>Xjhg;    <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1E3</span>;    <span class="comment">// 1000</span></span><br><span class="line"><span class="number">2e6</span>;    <span class="comment">// 2000000</span></span><br><span class="line"><span class="number">0.1e2</span>;  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数字对象"><a href="#数字对象" class="headerlink" title="数字对象"></a>数字对象</h4><p>内置的<code>Number</code>对象有一些有关数字的常量属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Number.MAX_VALUE</td>
<td align="center">可表示的最大值</td>
</tr>
<tr>
<td align="center">Number.MIN_VALUE</td>
<td align="center">可表示的最小值</td>
</tr>
<tr>
<td align="center">Number.NaN</td>
<td align="center">特指“非数字”</td>
</tr>
<tr>
<td align="center">Number.NEGATIVE_INFINITY</td>
<td align="center">特指“负无穷”，在溢出时返回</td>
</tr>
<tr>
<td align="center">Number.POSITIVE_INFINITY</td>
<td align="center">特指“正无穷”，在溢出时返回</td>
</tr>
<tr>
<td align="center">Number.EPSILON</td>
<td align="center">表示1与可表示的大于的最小浮点数之间的差值</td>
</tr>
<tr>
<td align="center">Number.MIN_SAFE_INTEGER</td>
<td align="center">JavaScript最小安全整数</td>
</tr>
<tr>
<td align="center">Number.MAX_SAFE_INTEGER</td>
<td align="center">JavaScript最大安全整数</td>
</tr>
</tbody></table>
<p><code>Number</code>的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Number.parseFloat()</td>
<td align="center">把字符串参数解析成浮点数，和全局方法<code>parseFloat</code>作用一致</td>
</tr>
<tr>
<td align="center">Number.parseInt()</td>
<td align="center">把字符串参数解析成特定基数对应的整型数字，和全局方法<code>parseInt</code>作用一致</td>
</tr>
<tr>
<td align="center">Number.isFinite()</td>
<td align="center">判断传入的值是否为有限数字</td>
</tr>
<tr>
<td align="center">Number.isInteger()</td>
<td align="center">判断传入的值是否为整数</td>
</tr>
<tr>
<td align="center">Number.isNaN()</td>
<td align="center">判断传入的值是否为<code>NaN</code></td>
</tr>
<tr>
<td align="center">Number.isSafeInteger()</td>
<td align="center">判断传入的值是否为安全整数</td>
</tr>
</tbody></table>
<p><code>Number</code>原型上的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">toExponential()</td>
<td align="center">返回一个数字的指数形式字符串，如：1.23e+2</td>
</tr>
<tr>
<td align="center">toFixed()</td>
<td align="center">返回指定小数位数的表示形式</td>
</tr>
<tr>
<td align="center">toPrecision()</td>
<td align="center">返回一个指定精度的数字</td>
</tr>
</tbody></table>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>JavaScript中没有日期对象，但是可以使用<code>Date</code>对象和其提供的方法来处理日期和时间。</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制与错误处理</title>
    <url>/wiki/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在JavaScript中，分号<code>;</code>用于分割代码中的语句，任何表达式(expression)也是语句(statement)。</p>
<h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>最基本的语句是块语句，用于对语句进行分组，该块有一对大括号<code>{}</code>进行定界:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句块通常和流程控制语句(<code>if</code>、<code>for</code>、<code>while</code>)一起使用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(x++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ES6之前，JavaScript没有块级作用域，在块中引入的变量的作用域是包含函数或者脚本，并且设置他们的效果将持续到块本身之外，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在ES6之后，可以使用<code>let</code>或<code>const</code>声明块级作用域变量。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件语句是一组在指定条件为<code>true</code>时执行的语句，JavaScript支持两个条件语句：<code>if...else</code>和<code>switch</code></p>
<ul>
<li><h6 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if...else语句"></a><code>if...else</code>语句</h6><p>如果条件为真，则使用<code>if</code>语句执行一条语句，如果条件为假，则使用可选的<code>else</code>子句执行一条语句。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的条件可以是任何计算结果为布尔值的表达式，如果结果为<code>true</code>则执行语句1，如果条件为<code>false</code>则执行语句2，语句1和语句2可以是任何语句，包括进一步嵌套<code>if</code>语句。JavaScript中的<code>else if</code>是<code>else</code>语句和<code>if</code>语句嵌套的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">3</span>) &#123;</span><br><span class="line">  语句<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在条件表达式中使用赋值，通常的做法是在赋值周围加上其他括号，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((x = y)) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean转换为false的值:</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>NaN</li>
<li>空字符串<code>&quot; &quot;</code></li>
</ul>
<p>其他值包括所有对象都或被转为<code>true</code>。注意原始的布尔类型和布尔对象的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(b)             <span class="comment">// =&gt; true，b是一个对象</span></span><br><span class="line"><span class="keyword">if</span>(b === <span class="literal">true</span>)    <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h4><p><code>switch</code>语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个<code>case</code>标签，如果匹配成功，则执行相关语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> label_1:</span><br><span class="line">    statements_1</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> label_2:</span><br><span class="line">    statements_2</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">    …</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    statements_def</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序会首先查找一个与<code>expression</code>匹配的<code>case</code>语句，然后将控制权转移到该子句并执行相关的语句。如果没有匹配值，则程序会去查找<code>default</code>字句，如果找到了<code>default</code>字句则执行相关的语句，如果没有找到，程序会执行<code>switch</code>后面的语句，<code>default</code>语句通常出现在<code>switch</code>语句的最后面，当然这不是必须的。</p>
<p>每个<code>case</code>语句会关联一个可选的<code>break</code>语句，保证在匹配的语句被执行完成后可以跳出<code>switch</code>语句并继续执行后面的语句，如果<code>break</code>被忽略，则程序将继续执行<code>switch</code>语句中的下一个<code>case</code>语句</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在JavaScript中可以使用<code>throw</code>语句引发异常，并使用<code>try...catch</code>语句捕获处理它。</p>
<h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><p>JavaScript可以抛出任意对象作为异常，但不是所有对象都能产生相同结果。尽管抛出数字或字符串作为异常信息非常常见，但是用下列其中一种异常类型来创建将更加高效：</p>
<ul>
<li>ECMAScript exceptions</li>
<li>DOMException and DOMError</li>
</ul>
<h3 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a><code>throw</code>语句</h3><p>使用<code>throw</code>语句引发异常，并制定要抛出的异常的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'Error'</span></span><br></pre></td></tr></table></figure>

<h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try...catch语句"></a><code>try...catch</code>语句</h3><p><code>try...catch</code>语句标记一块待尝试的语句，并制定一个或多个引发异常的响应，如果引发一个异常，那么就可以使用<code>try...catch</code>语句捕获它。</p>
<p><code>try...catch</code>语句包含一个<code>try</code>代码块，可以有一个或多个语句。零个或一个<code>catch</code>代码块，包含<code>try</code>语句块中引发异常时需要执行的语句。如果<code>try</code>中的代码块没有抛出异常，则<code>catch</code>代码块被跳过。<code>finally</code>代码块总会在<code>try</code>和<code>catch</code>代码块之后执行。</p>
<ul>
<li><code>catch</code>代码块：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (catchID) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code>块指定了一个标识符(catchID)来存放抛出语句指定的值，可以用这个标识符来获取抛出的异常信息。在插入<code>trrow</code>块中创建这个标识符，标识符只存在与<code>catch</code>块的存续期间内，当<code>catch</code>块执行完成时，标识符不在可用。</p>
<ul>
<li><p><code>finally</code>代码块</p>
<p><code>finally</code>语句块无论是否抛出异常都会执行，如果抛出了一个异常，就算没有异常处理也会执行。如果<code>finally</code>块返回一个值，则这个值将会成为整个<code>try...catch...finally</code>流程的返回值，不管在<code>try</code>或<code>catch</code>中是否有任何的return语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在<code>try</code>或者<code>catch</code>里使用return语句，其会作为整个<code>try...catch...finally</code>流程的返回值，而不会中断流程的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果在<code>finally</code>块中有定义return，则会覆盖其他的返回值。</p>
</li>
</ul>
<ul>
<li><p>使用<code>Error</code>对象</p>
<p>根据错误类型，可以使用<code>name</code>和<code>message</code>获取更精炼的信息。<code>name</code>提供了常规的错误类(如<code>DOMException</code>或<code>Error</code>)，<code>message</code>提供了一条从错误对象转换成从字符串的简明信息。如果要抛出自己的异常，可以利用这些属性，使用<code>Error</code>的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingErrorProne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ourCodeMakesAMistake()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The message'</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doSomethingToGetAJavascriptError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  doSomethingErrorProne();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;               </span><br><span class="line">  <span class="built_in">console</span>.error(e.name);    <span class="comment">// 'Error'</span></span><br><span class="line">  <span class="built_in">console</span>.error(e.message); <span class="comment">// 'The message', or a JavaScript error message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h4 id="1-代码重构"><a href="#1-代码重构" class="headerlink" title="1. 代码重构"></a>1. 代码重构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">summaryList.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.saasAttr === <span class="string">'userAvatar'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.headImg = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'userName'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.headName = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'type'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.headType = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'memo'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memo = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'images'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.imgList = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'communicateTime'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.communicateTime = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'communicateBusinessLinkText'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.communicateBusinessLinkText = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'customerNameLinkText'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.customerNameLinkText = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'contactNameLinkText'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.contactNameLinkText = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'address'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.address = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">this</span>.addressExtra = summaryList[index].extra</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.saasAttr === <span class="string">'video'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.videoData = summaryList[index].value[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码大量使用了<code>if...else...</code>，可以使用策略模式重构:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> relationsMap = &#123;</span><br><span class="line">  userAvatar: <span class="string">'headImg'</span>,</span><br><span class="line">  userName: <span class="string">'headName'</span>,</span><br><span class="line">  type: <span class="string">'headType'</span>,</span><br><span class="line">  images: <span class="string">'imgList'</span>,</span><br><span class="line">  communicateTime,</span><br><span class="line">  communicateBusinessLinkText,</span><br><span class="line">  customerNameLinkText,</span><br><span class="line">  contactNameLinkText,</span><br><span class="line">  address,</span><br><span class="line">  memo,</span><br><span class="line">  video</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">summaryList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  relationsMap[item.saasAttr] &amp;&amp; (<span class="keyword">this</span>[relationsMap[item.saasAttr]] = item.value[<span class="number">0</span>])</span><br><span class="line">  item.saasAttr === <span class="string">'address'</span> &amp;&amp; (<span class="keyword">this</span>.addressExtra = item.extra)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-使用策略模式计算奖金"><a href="#2-使用策略模式计算奖金" class="headerlink" title="2. 使用策略模式计算奖金"></a>2. 使用策略模式计算奖金</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义薪资计算类</span></span><br><span class="line"><span class="keyword">const</span> Strategies = &#123;</span><br><span class="line">  S: <span class="function"><span class="params">salary</span> =&gt;</span> salary * <span class="number">4</span>,</span><br><span class="line">  A: <span class="function"><span class="params">salary</span> =&gt;</span> salary * <span class="number">3</span>,</span><br><span class="line">  B: <span class="function"><span class="params">salary</span> =&gt;</span> salary * <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义薪资计算方法调用薪资计算类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcBonus</span>(<span class="params">level, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Strategies[level](salary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果以后需要添加C级D级的计算只需要在Strategies类里添加C和D就可以了。可扩展性较好。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>语法和数据类型</title>
    <url>/wiki/%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>JavaScript区分大小写，并使用Unicode字符集。即变量<code>test</code>和<code>TEXT</code>是两个不同的变量，并且可以使用中文作为变量名，如：<code>var 中文;</code></p>
<h3 id="分号可省略"><a href="#分号可省略" class="headerlink" title="分号可省略"></a>分号可省略</h3><p>每行代码结尾的分号可以省略，因为ECMAScript规定了在语句的末尾自动插入分号(ASI机制)。如果一行中有多条语句，那么这些语句必须以分号隔开。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JavaScript源码从左往右被扫描并转换成一系列由token、控制字符、行终止符、注释和空白字符组成的输入元素。</p>
<ul>
<li>控制字符<ul>
<li>零宽非连字符(&lt;ZWNJ&gt;, U+200C)，放置在一些经常会被当成连字的字符之间，用于将它们分别以独立形式显示。</li>
<li>零宽连字符(&lt;ZWJ&gt;, U+200D)，放置在一些通常不会被标记为连接字的字符之间，用于将这些字符以连字形式显示。</li>
<li>字节顺序标记(&lt;BOM&gt;, U+FEFF)，在脚本开头使用，除了将脚本标记为Unicode格式以外，还用来标记文本的字节流方向。</li>
</ul>
</li>
<li>空白符<ul>
<li>制表符(&lt;HT&gt;, U+0009)，水平制表符，<code>\t</code></li>
<li>垂直制表符(&lt;VT&gt;, U+000B)，垂直制表符，<code>\v</code></li>
<li>分页符(&lt;FF&gt;, U+000C)，分页符，<code>\f</code></li>
<li>空格(&lt;SP&gt;, U+0020)，空格</li>
<li>无间断空格(&lt;NBSP&gt;, U+00A0)，在该空格处不会换行</li>
</ul>
</li>
<li>行终止符<ul>
<li>换行符(&lt;LF&gt;, U+000A)，在UNIX系统中起新行，<code>\n</code></li>
<li>回车符(&lt;CR&gt;, U+000D)，在Commodore和早期的Mac系统中起新行，<code>\r</code></li>
<li>行分隔符(&lt;LS&gt;, U+2028)</li>
<li>段分隔符(&lt;PSs&gt;, U+2029)</li>
</ul>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>JavaScript的注释语法类似于C++，有两种注释方式：单行和多行。两种注释方式不能混用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量又叫标识符，需要遵循一定的规则：必须以字母、下划线(_)或者美元符($)开头，后续的字符也可以是数字(0-9)，可以使用ISO 8859-1或Unicode编码的字符作为标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> \u4e25 = <span class="number">1</span>;     <span class="comment">// 严的unicode编码为\u4e25</span></span><br><span class="line"><span class="built_in">console</span>.log(严);    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量声明</p>
<ul>
<li>使用关键词<code>var</code>，例如<code>var test = 1;</code>。该语法可以声明局部变量和全局变量。</li>
<li>直接赋值，例如<code>test = 1;</code>。在函数外使用这种形式赋值会产生一个全局变量，在严格模式下会产生错误。</li>
<li>使用关键词<code>let</code>，例如<code>let test = 1;</code>。该语法可以用来声明块作用域的局部变量</li>
</ul>
</li>
<li><p>变量求值</p>
<p>用<code>var</code>或<code>let</code>声明的变量如果没有赋初始值，则其值为<code>undefined</code>。如果访问一个未声明的变量会抛出一个·<code>ReferenceError</code>异常。</p>
<p>可以使用<code>undefined</code>来判断一个变量是否已经赋值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span>(test === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量未赋值'</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量已赋值'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>undefined</code>在布尔类型环境中会被当做<code>false</code>，所以上面的代码可以简化成下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span>(test) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量未赋值'</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量已赋值'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数值类型中<code>undefined</code>会被转成<code>NaN</code>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a+<span class="number">2</span>);    <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>空值<code>null</code>在数值类型中会被转换成0，在布尔类型中会准换成false，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span>(!a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的作用域</p>
<p>在函数之外生声明的变量叫做全局变量，它可被当前文档中的任何其他代码访问。在函数内部声明的变量称为局部变量，只能在当前函数内部访问。    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;    <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> test;  <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ECMAScript6之前没有块级作用域(即大括号之间的代码块)，语句块中声明的变量会称为语句块所在的作用域中的变量。如果使用ES6中的<code>let</code>声明，就会变为块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test);    <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量提升</p>
<p>在JavaScript中可以先使用变量再进行声明，这被称为变量提升。感觉上提升是被移到了文档的最前面，但提升后的变量将返回<code>undefined</code>值，因此即便是在声明时赋值了初始值，也会返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>在ECMAScript6中，使用<code>let</code>或<code>const</code>声明会将变量提升但不会被初始化，因此在变量声明之前就使用这个变量，将会抛出引用错误(RefenceError)。这个变量将从代码块一开始的时候就处在一个<strong>暂时性死区</strong>(temporal dead zone)，直到这个变量被声明为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数提升</p>
<p>对于函数来说，只有函数声明会被提升，而函数表达式不会被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test();    <span class="comment">// test!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">test2();  <span class="comment">// TypeError: test2 is not a function</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局变量</p>
<p>全局变量实际上是全局对象的属性，在浏览器中默认的全局变量为<code>window</code>，可以使用<code>window.variable</code>的语法来设置和访问变量。</p>
</li>
<li><p>常量</p>
<p>在ECMAScript6中，可以使用<code>const</code>关键字声明常量，常量不可以重新赋值，所以在声明时就需要赋值。常量作用域与<code>let</code>一样，在同一作用域中，不能使用变量名或函数名相同的名字来命名常量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的ECMAScript定义了8中数据类型，分别为：</p>
<ul>
<li>原始类型<ul>
<li>Boolean，有且只有两个值: <code>true</code>和<code>false</code></li>
<li>Null，一个表明null值得特殊关键字，</li>
<li>undefined，一个表示值未定义的顶级属性</li>
<li>Number，整数或浮点数</li>
<li>String，代表文本值的一系列字符</li>
<li>Symbol，实例是唯一且不可变的数据类型</li>
<li>BigInt，具有任意精度的整数</li>
</ul>
</li>
<li>Object</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>JavaScript是一门动态类型的语言，在声明变量时可以不必指定数据类型，数据类型会在代码执行时根据需要自动转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;    <span class="comment">// 此时a的类型为number</span></span><br><span class="line">a = <span class="string">'1234'</span>;    <span class="comment">// 此时a的类型为string</span></span><br></pre></td></tr></table></figure>

<p>在包含数字和字符串的表达式中使用<code>+</code>运算，JavaScript会将数字隐式转换成字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'37'</span> + <span class="number">1</span>);    <span class="comment">// 371，类型为字符串，使用字符串的拼接操作</span></span><br></pre></td></tr></table></figure>

<p>在涉及其他运算符时，JavaScript会将字符串隐式转换成数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'37'</span> - <span class="number">1</span>);    <span class="comment">// 36，类型为数字</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量是在脚本中实际提供的固定值而不是变量，通常有以下类型的字面量：</p>
<ul>
<li><h5 id="数组字面量-Array-Literals"><a href="#数组字面量-Array-Literals" class="headerlink" title="数组字面量(Array Literals)"></a>数组字面量(Array Literals)</h5><p>数组字面量是0个或多个表达式的列表，每个表达式代表一个数组元素，并使用方括号<code>[]</code>括起来。使用数组字面量创建数组时，将使用指定的值作为其元素进行初始化，并且将其长度设置为指定的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, ,<span class="number">3</span>];</span><br><span class="line">nums[<span class="number">0</span>];    <span class="comment">// 1</span></span><br><span class="line">nums[<span class="number">1</span>];    <span class="comment">// undefined</span></span><br><span class="line">nums[<span class="number">2</span>];    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="布尔字面量-Boolean-Literals"><a href="#布尔字面量-Boolean-Literals" class="headerlink" title="布尔字面量(Boolean Literals)"></a>布尔字面量(Boolean Literals)</h4><p>有且仅有两个值：<code>true</code>和<code>false</code>。</p>
</li>
<li><h4 id="浮点数字面量-Float-point-Literals"><a href="#浮点数字面量-Float-point-Literals" class="headerlink" title="浮点数字面量(Float-point Literals)"></a>浮点数字面量(Float-point Literals)</h4><p>浮点数字面量可以有以下部分组成:</p>
<ul>
<li>一个带正负号(<code>+</code>、<code>-</code>)的十进制整数</li>
<li>小数点<code>.</code></li>
<li>小数部分(由一串十进制数表示)</li>
<li>指数部分，即<code>e</code>或<code>E</code>后跟一个整数，该整数可以带正负号。</li>
</ul>
<p>浮点数字面量必须至少包含一位数字，并带有小数点或<code>e</code>。语法类似:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(+|-)][digits].[digits][(E|e)[(+|-)]digits]</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="数字字面量-Numeric-Literals"><a href="#数字字面量-Numeric-Literals" class="headerlink" title="数字字面量(Numeric Literals)"></a>数字字面量(Numeric Literals)</h4><p>Number和BigInt类型可以使用十进制、十六进制、八进制和二进制表示。</p>
<ul>
<li>十进制的数字字面量是由前缀不为0的一串数字序列组成</li>
<li>八进制的数字字面量是由前缀为<code>0</code>或者前缀为<code>0O</code>的只包含0-7的数字组成</li>
<li>十六进制的数字字面量是由前缀为<code>0x</code>并且包含0-9和a-f的序列组成</li>
<li>二进制的数字字面量是由前缀为<code>0b</code>并且只包含0-1的数字序列组成</li>
</ul>
</li>
<li><h4 id="对象字面量-Object-Literals"><a href="#对象字面量-Object-Literals" class="headerlink" title="对象字面量(Object Literals)"></a>对象字面量(Object Literals)</h4><p>对象字面量是使用花括号<code>{}</code>括起来的0或多对<strong>属性名：属性值</strong>对的元素列表。不要在语句的开头使用对象字面量语法，这位被认为是一个块的开始</p>
<h6 id="增强的对象字面量-Enhanced-Object-literals"><a href="#增强的对象字面量-Enhanced-Object-literals" class="headerlink" title="增强的对象字面量(Enhanced Object literals)"></a>增强的对象字面量(Enhanced Object literals)</h6><p>在ES2015中，对象字面量扩展了支持在创建时设置原型，简写了<code>foo: foo</code>形式的属性赋值和方法定义，支持父方法调用，以及使用表达式动态计算属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  __proto__: theProtoObj,</span><br><span class="line">  handler, <span class="comment">// =&gt; handler: handler</span></span><br><span class="line">  toString() &#123;&#125;, <span class="comment">// =&gt; toString: function() &#123;&#125;</span></span><br><span class="line">  [<span class="string">'prop_'</span> + <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="number">42</span>)()]: <span class="number">42</span> <span class="comment">// 动态计算属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="正则表达式字面量-RegExp-Literals"><a href="#正则表达式字面量-RegExp-Literals" class="headerlink" title="正则表达式字面量(RegExp Literals)"></a>正则表达式字面量(RegExp Literals)</h4><p>正则表达式字面量是被斜杠<code>/</code>围成的表达式，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="字符串字面量-String-Literals"><a href="#字符串字面量-String-Literals" class="headerlink" title="字符串字面量(String Literals)"></a>字符串字面量(String Literals)</h4><p>字符串字面量是由双引号<code>&quot;</code>或单引号<code>&#39;</code>括起来的0个或多个字符，字符被限制在相同类型的引号之间。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure>

<p>ES2015还提供了一种模板字面量(template literals)，模板字面量使用反引号(<strong>`</strong>)，其为构造字符串提供了语法糖，还可以在模板字符串前添加一个tag来自定义模板字符串的解析过程，以预防注入攻击或建立基于字符串的高级数据抽象。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'bob'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);    <span class="comment">// Hello, bob</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>索引集合</title>
    <url>/wiki/%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>数组是一个有序的数据集合，可以通过数组名称和索引进行访问。JavaScript中没有明确的数组数据类型，但可以使用内置的Array对象和其方法对数组进行操作。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数组有以下三种方法：</span></span><br><span class="line"><span class="comment">// 1. 使用Array构造函数</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用Array函数</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用数组字面量</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h4 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过给元素赋值进行填充数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr [<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr [<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// [1, 2, empty, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果索引是一个非整型数值，则将会被作为数组对象的属性存储，而非数组元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr[<span class="number">3.14</span>] = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);        <span class="comment">// [3.14: 3.14]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3.14</span>]);  <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty(<span class="number">3.14</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组元素"><a href="#引用数组元素" class="headerlink" title="引用数组元素"></a>引用数组元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组名加索引的方式引用</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p>在实施层面，JavaScript实际上是将元素作为标准的对象属性来存储。把索引作为属性名。<strong>length</strong>属性是特殊的，它总是返回最后一个元素的索引值+1，也可以通过改写<strong>length</strong>来修改数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [];</span><br><span class="line">arrs[<span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrs.length);  <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">arrs.length = <span class="number">0</span>;    <span class="comment">// 将length属性改为0会清空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(arrs);  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的操作是遍历数组的值，并以某种方式进行处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrs[i]);    <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果确定数组中的元素没有一个false，例如只包含dom节点的数组，可以使用下面的方法</span></span><br><span class="line"><span class="comment">// 该方法可以避免检测数组长度的开销，并确保每次循环时都将div变量重新分配给当前项</span></span><br><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, div; div = divs[i]; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用forEach方法</span></span><br><span class="line"><span class="comment">// 被传递给forEach的回调函数会在数组的每个元素上执行一次，元素作为参数传递给回调函数，未赋值的值不会在forEach循环迭代</span></span><br><span class="line">arrs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在数组定义时省略的元素不会在forEach遍历中列出，但手动赋值的undefined会被列出</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [,,<span class="literal">undefined</span>,<span class="number">1</span>];</span><br><span class="line">arr1.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);    <span class="comment">// undefined, 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// concat()连接两个数组并返回一个新的数组</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2));    <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join()将数组所有元素连接成一个字符串，并以参数作为分隔符</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.join(<span class="string">','</span>));      <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push()在数组末尾添加一个或多个元素，并返回数组操作后的长度</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.push(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);                <span class="comment">// [4,5,6,"a","b","c"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pop()从数组中移除最后一个元素，并返回该元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.pop());         <span class="comment">// c</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);               <span class="comment">// [4,5,6,"a","b"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift()从数组中移出第一个元素，并返回该元素</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.shift());      <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);              <span class="comment">// [5,6,"a","b"] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unshift()在数组开头添加一个或多个元素，并返回数组的新长度</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.unshift(<span class="number">4</span>));   <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);              <span class="comment">// [4,5,6,"a","b"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice(start_index, end_index)从数组提取一个片段，并作为一个新数组返回</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.slice(<span class="number">0</span>, <span class="number">3</span>));  <span class="comment">// [4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice(index, count_to_remove, addElment1...)从数组中移出一些元素，(可选)并替换它们</span></span><br><span class="line">arr2.splice(<span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);         <span class="comment">// [4, 5, 6, 7, 8,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse()颠倒数组元素的顺序</span></span><br><span class="line">arr2.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr2);         <span class="comment">// [9, 8, 7, 6, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort()给数组元素排序</span></span><br><span class="line">arr2.sort();</span><br><span class="line"><span class="built_in">console</span>.log(arr2);         <span class="comment">// [4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">// sort也可以传一个回调函数来决定排序方法</span></span><br><span class="line">arr2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);         <span class="comment">// [9, 8, 7, 6, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf(element[, fromIndex])在数组中搜索element并返回第一个匹配的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.indexOf(<span class="number">9</span>));      <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lastIndexOf(element[, fromIndex])从结尾开始反向搜索elemnt，并返回第一次匹配的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.lastIndexOf(<span class="number">9</span>));  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach(callback[, thisObject])在数组的每个元素上执行callback</span></span><br><span class="line">arr2.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);    <span class="comment">// 9 8 7</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map(callback[, thisObject])在数组的每个元素上执行callback，并将每次执行callback时的返回值组成新数组并返回</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>));   <span class="comment">// [18, 16, 14, 12, 10, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter(callback[, thisObject])在数组的每个元素上执行callback，并将每次执行callback时的返回值w为true的元素组成新数组并返回</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>));  <span class="comment">// [8, 6, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every(callback[, thisObject])在数组的每个元素上执行callback，如果每次执行callback的返回值都为true则返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.every(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">0</span>));         <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some(callback[, thisObject])在数组的每个元素上执行callback，如果有一次次执行callback的返回值为true则返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.some(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">8</span>));         <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce(callback[, initialValue])使用回调函数callback(first_value, second_value)把数组所有元素计算成一个单一值。</span></span><br><span class="line"><span class="comment">// 如果指定了initialValue，则使用initialValue作为第一个参数值并以数组中第一项的值作为第二个参数值来调用回调。如果未指定initialValue，则回调的前两个参数值将是数组的第一个和第二个元素。</span></span><br><span class="line"><span class="comment">// 9 + 8 + 7 + 6 + 5 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.reduce(<span class="function">(<span class="params">first, second</span>) =&gt;</span> first + second));  <span class="comment">// 39</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduceRight(callback[, initialValue])从最后一个元素开始，使用回调函数callback(first_value, second_value)把数组所有元素计算成一个单一值</span></span><br><span class="line"><span class="comment">// 4 + 5 + 6 + 7 + 8 + 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.reduce(<span class="function">(<span class="params">first, second</span>) =&gt;</span> first + second));  <span class="comment">// 39</span></span><br></pre></td></tr></table></figure>

<h4 id="使用类数组对象"><a href="#使用类数组对象" class="headerlink" title="使用类数组对象"></a>使用类数组对象</h4><p>Array的原生(prototype)方法可以用来处理类似数组(例如arguments)行为的对象:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgumnets</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, item =&gt; <span class="built_in">console</span>.log(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h3><p>Typed Arrays是类数组对象，其提供访问原始二进制数据的机制</p>
<h4 id="缓冲和视图：类型化的数组结构"><a href="#缓冲和视图：类型化的数组结构" class="headerlink" title="缓冲和视图：类型化的数组结构"></a>缓冲和视图：类型化的数组结构</h4><p>JavaScript类型数组被分解为缓冲(Buffer, 由ArrayBuffer实现)和视图(views)。缓冲是代表数据块的对象，它没有格式可言并没有提供任何机制来访问其内容。为了访问包含在缓冲区的内存需要使用视图，视图提供一个上下文，即数据类型、起始偏移量和元素数，这些元素将数据转换为实际类型数组。</p>
<h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p>ArrayBuffer是一种数据类型，用于表示一个通用的、固定长度的二进制数据缓冲区。不能直接操作一个ArrayBuffer中的内容，需要创建一个数组类型视图或者DataView来代表特定格式的缓冲区，从而实现读写缓冲区中的内容。</p>
<h4 id="类型数组视图"><a href="#类型数组视图" class="headerlink" title="类型数组视图"></a>类型数组视图</h4><p>类型数组属视图具有自描述性的名字，并且提供数据类型信息。例如<code>Int8</code>、<code>Unit32</code>、<code>Float64</code>等。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8.html</url>
    <content><![CDATA[<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>在JavaScript中，迭代器是一个对象，它定义一个序列，并在终止时可能返回一个返回值。准确说，迭代器是使用<code>next</code>方法实现iterator protocol的任何一个对象，该方法返回具有两个属性的对象：<code>value</code>和<code>done</code>。<code>value</code>是序列中的next的值。<code>done</code>用来判断是否迭代完成，如果已经迭代到序列中的最后一个值，则为true。如果<code>value</code>和<code>done</code>一起存在，则是迭代器的返回值。</p>
<p>迭代器一旦创建，就可以通过重复调用<code>next()</code>方法显示迭代。迭代一个迭代器被称为消费，因为它通常只能执行一次。在产生终止值之后，对<code>next()</code>的额外调用应该继续返回<code>{done: true}</code>。</p>
<p>JavaScript中最常见的迭代器是数组迭代器，它只是按顺序返回关联数组中的每个值。数组必须完整分配，但迭代器仅在必要时使用。因此，迭代器可以表示大小不受限制的序列，例如0到Infinity之间的整数范围。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRangeIterator</span>(<span class="params">start = <span class="number">0</span>, end = Infinite, step = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextIndex = start;</span><br><span class="line">  <span class="keyword">let</span> iterationCount = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> rangeIterator = &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">if</span>(nextIndex &lt; end) &#123;</span><br><span class="line">        result = &#123;<span class="attr">value</span>: nextIndex, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">        nextIndex += step;</span><br><span class="line">        iterationCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">value</span>: iterationCount, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> rangeIterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> it = makeRangeIterator(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> result = it.next();</span><br><span class="line"><span class="keyword">while</span>(!result.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result.value);</span><br><span class="line">  result = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><p>虽然自定义的迭代器是一个有用的工具，但由于需要显示地维护其内部状态，需要谨慎使用。生成器函数提供了一个强大的选择：它允许你自定义一个包含自有迭代算法的函数，同时它可以自动的维护自己的状态。生成器函数使用<code>function*</code>语法编写。最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeRangeIterator</span>(<span class="params">start = <span class="number">0</span>, end = Infinity, step = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start, i &lt; end, i += step) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = makeRangeIterator(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">a.next();    <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">a.next();    <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">a.next();    <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">a.next();    <span class="comment">// &#123;value: 7, done: false&#125;</span></span><br><span class="line">a.next();    <span class="comment">// &#123;value: 9, done: false&#125;</span></span><br><span class="line">a.next();    <span class="comment">// &#123;value: uundefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>若一个对象拥有迭代行为，比如在<code>for...of</code>中会循环一些值，那么该对象便是一个可迭代对象。某些内置对象(Array或Map)具有默认的迭代行为，而其他类型(Object)则没有。</p>
<p>为了实现可迭代，对象必须实现<code>@@iterator</code>方法，这意味着这个对象(或其原型链中的任何一个对象)必须具有一个带<code>Symbol.iterator</code>键的属性。可以一次或多次迭代一个迭代器，只能迭代一次的iterables通常从他们的@@iterator方法中返回自身。可以多次迭代的方法必须在每次调用@@iterator时返回一个新的迭代器。</p>
<h5 id="自定义的可迭代对象"><a href="#自定义的可迭代对象" class="headerlink" title="自定义的可迭代对象"></a>自定义的可迭代对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">[...myIterable];    .. [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h5 id="内置可迭代对象"><a href="#内置可迭代对象" class="headerlink" title="内置可迭代对象"></a>内置可迭代对象</h5><ul>
<li>String</li>
<li>Array</li>
<li>TypedArray</li>
<li>Map</li>
<li>Set</li>
</ul>
<h5 id="用于可迭代对象的语法"><a href="#用于可迭代对象的语法" class="headerlink" title="用于可迭代对象的语法"></a>用于可迭代对象的语法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> vaule <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="string">'abc'</span>];    <span class="comment">// [a, b, c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&#125;</span><br><span class="line">gen().next();    <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line">[a, b, c] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">a; <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<h5 id="高级生成器"><a href="#高级生成器" class="headerlink" title="高级生成器"></a>高级生成器</h5><p>生成器会按需计算它们的产生值，这使得它们能够有效表示一个计算成本很高的序列。<code>next()</code>方法也接受一个参数用于修改生成器内部状态。传递给<code>next()</code>的参数值会被yield接受，传给第一个<code>next()</code>的值会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> fn2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current = fn1;</span><br><span class="line">    fn1 = fn2;</span><br><span class="line">    fn2 = current + fn1;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> current;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123;</span><br><span class="line">      fn = <span class="number">0</span>;</span><br><span class="line">      fn = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sequence = fibonacci();</span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next(<span class="literal">true</span>).value);    <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence.next().value);    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以通过调用其<code>throw()</code>方法强制生成器抛出异常，并传递应该抛出的异常值。这个异常将从当前挂起的生成器上下文中抛出，就好像当前挂起得<code>yield</code>是一个<code>throw value</code>语句。如果在抛出异常的处理期间没有遇到<code>yield</code>则异常通过调用<code>throw()</code>向上传播，对next的后续调用将导致<code>done</code>为true。生成器具有<code>return(value)</code>方法，返回给定的值并完成生成器本身。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式与运算符</title>
    <url>/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content><![CDATA[<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>一个赋值运算符将它右边操作数的值赋值给它左边的操作数。JavaScript包含的赋值表达式如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">简写的操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">赋值操作符</td>
<td align="center"><code>x = y</code></td>
<td align="center"><code>x = y</code></td>
</tr>
<tr>
<td align="center">加法赋值操作符</td>
<td align="center"><code>x += y</code></td>
<td align="center"><code>x = x + y</code></td>
</tr>
<tr>
<td align="center">减法赋值操作符</td>
<td align="center"><code>x -= y</code></td>
<td align="center"><code>x = x - y</code></td>
</tr>
<tr>
<td align="center">乘法赋值操作符</td>
<td align="center"><code>x *= y</code></td>
<td align="center"><code>x = x * y</code></td>
</tr>
<tr>
<td align="center">除法赋值操作符</td>
<td align="center"><code>x /= y</code></td>
<td align="center"><code>x = x / y</code></td>
</tr>
<tr>
<td align="center">求余赋值操作符</td>
<td align="center"><code>x %= y</code></td>
<td align="center"><code>x = x % y</code></td>
</tr>
<tr>
<td align="center">求幂赋值操作符</td>
<td align="center"><code>x **= y</code></td>
<td align="center"><code>x = x ** y</code></td>
</tr>
<tr>
<td align="center">左移位赋值操作符</td>
<td align="center"><code>x &lt;&lt;= y</code></td>
<td align="center"><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td align="center">右移位赋值操作符</td>
<td align="center"><code>x &gt;&gt;= y</code></td>
<td align="center"><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td align="center">无符号右移位赋值操作符</td>
<td align="center"><code>x &gt;&gt;&gt;= y</code></td>
<td align="center"><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td align="center">按位与赋值操作符</td>
<td align="center"><code>x &amp;= y</code></td>
<td align="center"><code>x = x &amp; y</code></td>
</tr>
<tr>
<td align="center">按位异或赋值操作符</td>
<td align="center"><code>x ^= y</code></td>
<td align="center"><code>x = x ^ y</code></td>
</tr>
<tr>
<td align="center">按位或赋值操作符</td>
<td align="center"><code>x |= y</code></td>
<td align="center"><code>x = x | y</code></td>
</tr>
</tbody></table>
<h5 id="解构运算符"><a href="#解构运算符" class="headerlink" title="解构运算符"></a>解构运算符</h5><p>对于更复杂的赋值，解构赋值语法可以将属性或值从对象或数组中取出，赋值给其他变量。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, rest;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [30, 40, 50]</span></span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stage 4（已完成）提案中的特性</span></span><br><span class="line">(&#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>解构数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明并赋值时的解构</span></span><br><span class="line"><span class="keyword">let</span> foo = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br><span class="line"><span class="keyword">let</span> [one, two, three] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);    <span class="comment">// 'one', 'two', 'three'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量先声明后赋值时的解构</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">3</span>, b=<span class="number">5</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 3, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析一个从函数返回的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);   <span class="comment">// 1, 3, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);   <span class="comment">// 1, 3</span></span><br><span class="line">[,,] = f();          <span class="comment">// 忽略全部返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用正则表达式匹配提取值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseProtocol</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parsedUrl = <span class="regexp">/^(\w+)\:\/\/([^\/]+)\/(.*)$/</span>.exec(url);</span><br><span class="line">  <span class="keyword">if</span>(!parsedUrl) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(parsedUrl);</span><br><span class="line">  <span class="keyword">let</span> [, protocol, fullhost, fullpath] = parsedUrl;</span><br><span class="line">  <span class="keyword">return</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(parseProtocol(<span class="string">'https://developer.mozilla.org/en-US/Web/JavaScript'</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(p, q);    <span class="comment">// 42, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无声明赋值</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">(&#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);    <span class="comment">// 括号()在使用对象字面量无声明结构赋值时是必须的</span></span><br><span class="line">                            <span class="comment">// &#123;a, b&#125; = &#123;a: 1, b: 2&#125; 左边会被认为是一个代码块而不是对象字面量</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给新的变量名赋值</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: foo, <span class="attr">q</span>: bar&#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(foo, bar);    <span class="comment">// 42, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;a=<span class="number">10</span>, b=<span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">cosole.log(a, b);    <span class="comment">// 1, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给新的变量命名并提供默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:aa=<span class="number">5</span>, <span class="attr">b</span>:bb=<span class="number">10</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb);    <span class="comment">// 1, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="comment">// ES5版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES5Chart</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options === <span class="literal">undefined</span> ? &#123;&#125; : options;</span><br><span class="line">  <span class="keyword">let</span> size = options.size === <span class="literal">undefined</span> ? <span class="string">'big'</span> : options.size;</span><br><span class="line">  <span class="keyword">let</span> cords = options.cords === <span class="literal">undefined</span> ? &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125; : options.cords;</span><br><span class="line">  <span class="keyword">let</span> radius = options.size === <span class="literal">undefined</span> ? <span class="number">25</span> : options.radius;</span><br><span class="line">  <span class="built_in">console</span>.log(size, cords, radius);</span><br><span class="line">&#125;</span><br><span class="line">drawES5Chart(&#123;</span><br><span class="line">  cords: &#123;<span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;,</span><br><span class="line">  radius: <span class="number">30</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ES6版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES6Chart</span>(<span class="params">&#123;size = <span class="string">'big'</span>, cords = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, radius = <span class="number">25</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(size, cords, radius);</span><br><span class="line">&#125;</span><br><span class="line">drawES6Chart(&#123;</span><br><span class="line">  cords: &#123;<span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;,</span><br><span class="line">  radius: <span class="number">30</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构嵌套对象和数组</span></span><br><span class="line"><span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  title: <span class="string">'test'</span>,</span><br><span class="line">  translations: [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">'JavaScript'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  title: englishTitle,</span><br><span class="line">  translations: &#123;</span><br><span class="line">    title: localeTitle</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = metadata;</span><br><span class="line"><span class="built_in">console</span>.log(englishTitle, localeTitle);     <span class="comment">// test, JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of迭代和解构</span></span><br><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Mike'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    family: &#123;</span><br><span class="line">      mother: <span class="string">'Jane'</span>,</span><br><span class="line">      father: <span class="string">'Harry'</span>,</span><br><span class="line">      brother: <span class="string">'Samantha'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    family: &#123;</span><br><span class="line">      mother: <span class="string">'Norah'</span>,</span><br><span class="line">      father: <span class="string">'Richard'</span>,</span><br><span class="line">      brother: <span class="string">'Howard'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> &#123;<span class="attr">name</span>: n, <span class="attr">family</span>: &#123;<span class="attr">father</span>: f&#125;, <span class="attr">age</span>: a&#125; <span class="keyword">of</span> people) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;n&#125;</span>, age: <span class="subst">$&#123;a&#125;</span>, father: <span class="subst">$&#123;f&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name: Mike, age: 18, father: Harry</span></span><br><span class="line"><span class="comment">// name: Tom, age: 20, father: Richard</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从作为函数实参的对象中提取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userId</span>(<span class="params">&#123;id&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whois</span>(<span class="params">&#123;displayName: displayName, fullName: &#123; firstName: name &#125;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;displayName&#125;</span> is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  displayName: <span class="string">'jdoe'</span>,</span><br><span class="line">  fullname: &#123;</span><br><span class="line">    firstName: <span class="string">'John'</span>,</span><br><span class="line">    lastName: <span class="string">'Doe'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cosole.log(<span class="string">`userId: <span class="subst">$&#123;userId(user)&#125;</span>`</span>)    <span class="comment">// userId: 42</span></span><br><span class="line">whois(user);    <span class="comment">// jdoe is John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性计算名和解构</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'z'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;[key]: foo&#125; = &#123;<span class="attr">z</span>: <span class="string">'bar'</span>&#125;;</span><br><span class="line">cosnole.log(foo);    <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构中的Rest</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest);    <span class="comment">// a, 2, &#123;c: 3, d: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的JavaScript标识符作为属性名称</span></span><br><span class="line"><span class="keyword">const</span> foo = &#123;<span class="string">'fizz-buzz'</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="string">'fizz-buzz'</span>: fizzBuzz&#125; = foo;</span><br><span class="line"><span class="built_in">console</span>.log(fizzBuzz);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构对象时查找原型链</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">self</span>: <span class="string">'123'</span>&#125;;</span><br><span class="line">obj.__proto__.port = <span class="string">'456'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;self, port&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(self, port);    <span class="comment">// 123, 456</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符比较它的操作数并返回一个基于表达式是否为真的逻辑值，操作数可以是数字、字符串、逻辑、对象值。字符串比较是基于标准的字典顺序，使用Unicode值。在多数情况下，如果两个操作数不是相同类型，JavaScript会尝试转换它们为恰当的类型来比较。类型转换的例外使用<code>===</code>和<code>!==</code>操作符，它们不会在检查相等之前转换操作数的类型。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等于<code>==</code></td>
<td align="center">当两边操作数相等时返回true</td>
<td align="center"><code>1 == &#39;1&#39;</code></td>
</tr>
<tr>
<td align="center">不等于<code>!=</code></td>
<td align="center">当两边操作数不相等时返回true</td>
<td align="center"><code>1 != 2</code></td>
</tr>
<tr>
<td align="center">严格等于<code>===</code></td>
<td align="center">两边操作数相等且类型相同时返回true</td>
<td align="center"><code>1 === 1</code></td>
</tr>
<tr>
<td align="center">严格不等于<code>!==</code></td>
<td align="center">当两边操作数不相等或类型不相同时返回true</td>
<td align="center"><code>1 !== &#39;1&#39;</code></td>
</tr>
<tr>
<td align="center">大于<code>&gt;</code></td>
<td align="center">当左边的操作数大于右边的操作数是返回true</td>
<td align="center"><code>2 &gt; 1</code></td>
</tr>
<tr>
<td align="center">小于<code>&lt;</code></td>
<td align="center">当左边的操作数小于右边的操作数是返回true</td>
<td align="center"><code>1 &lt; 2</code></td>
</tr>
<tr>
<td align="center">大于等于<code>&gt;=</code></td>
<td align="center">当左边的操作数大于或等于右边的操作数是返回true</td>
<td align="center"><code>2 &gt;= 2</code></td>
</tr>
<tr>
<td align="center">小于等于<code>&lt;=</code></td>
<td align="center">当左边的操作数小于或等于右边的操作数是返回true</td>
<td align="center"><code>2 &lt;= 2</code></td>
</tr>
</tbody></table>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符使用数值作为操作数并返回一个数值。注：除<code>0</code>会返回<code>Infinity</code>，除<code>-0</code>会返回<code>-Infinity</code>。除了标准的算数运算符(<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>)，JavaScript还提供了一下算数运算符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求余<code>%</code></td>
<td align="center">二元运算符，返回相除之后的余数</td>
<td align="center"><code>12 % 5 // 2</code></td>
</tr>
<tr>
<td align="center">自增<code>++</code></td>
<td align="center">一元运算符，将操作数的值加1。如果放在操作数的前面则返回加1后的值，如果放在操作数后面则返回操作数原值，再将操作数加1。</td>
<td align="center"><code>let x = 3</code><br /><code>x++ //3</code><br /><code>++x  // 4</code></td>
</tr>
<tr>
<td align="center">自减<code>--</code></td>
<td align="center">一元运算符，将操作数的值减1。前后规则和则增相同</td>
<td align="center"><code>let x = 3</code><br /><code>x-- //3</code><br /><code>--x  // 2</code></td>
</tr>
<tr>
<td align="center">一元负值符<code>-</code></td>
<td align="center">一元运算符，返回操作数的负值</td>
<td align="center"><code>-x</code></td>
</tr>
<tr>
<td align="center">一元正操作符<code>+</code></td>
<td align="center">一元运算符，返回操作数的正值</td>
<td align="center"><code>+x</code></td>
</tr>
<tr>
<td align="center">指数运算符<code>**</code></td>
<td align="center">计算底数的指数次方</td>
<td align="center"><code>x**y //x的y次方</code></td>
</tr>
</tbody></table>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符将它的操作数当做32位元的二进制串。位运算符在二进制上执行运算，返回标准的JavaScript数值。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按位与<code>&amp;</code></td>
<td align="center"><code>a &amp; b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位都是1则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位或<code>|</code></td>
<td align="center"><code>a | b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位只要有1个是1则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位异或<code>^</code></td>
<td align="center"><code>a ^ b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位两个不相同则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位非<code>~</code></td>
<td align="center"><code>~ a</code></td>
<td align="center">翻转操作数的位</td>
</tr>
<tr>
<td align="center">左移<code>&lt;&lt;</code></td>
<td align="center"><code>a &lt;&lt; b</code></td>
<td align="center">将a的二进制串想左移动b位，右边加入0</td>
</tr>
<tr>
<td align="center">算数右移<code>&gt;&gt;</code></td>
<td align="center"><code>a &gt;&gt; b</code></td>
<td align="center">将a的二进制串向右移动b位，丢弃被移除的所有位</td>
</tr>
<tr>
<td align="center">无符号右移<code>&gt;&gt;&gt;</code></td>
<td align="center"><code>a &gt;&gt;&gt; b</code></td>
<td align="center">将a的二进制串向右移动b位，丢弃被移除的所有位，将左边空出的位都补0</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符常用于布尔值之间</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">范例</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑与<code>&amp;&amp;</code></td>
<td align="center"><code>a &amp;&amp; b</code></td>
<td align="center">如果a能被转成false，则返回a，否则返回b。当<code>&amp;&amp;</code>用于布尔值时，当操作数都为true时返回true，否则返回false</td>
</tr>
<tr>
<td align="center">逻辑或<code>||</code></td>
<td align="center"><code>a || b</code></td>
<td align="center">如果a能被转成true，则返回a，否则返回b。当<code>||</code>用于布尔值时，当操作数有一个为true时返回true，否则返回false</td>
</tr>
<tr>
<td align="center">逻辑非<code>!</code></td>
<td align="center"><code>!a</code></td>
<td align="center">如果操作数能转换true则返回false，否则返回true</td>
</tr>
</tbody></table>
<h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><ul>
<li><p><code>delete</code></p>
<p><code>delete</code>删除一个对象或一个对象的属性或者一个数组中的键值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.b;</span><br><span class="line"><span class="built_in">console</span>.log(o);    <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> arrs[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arrs);    <span class="comment">// [empty , 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>typeof</code></p>
<p><code>typeof</code>返回一个表示操作数类型的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'string'</span>);    <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);           <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);          <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);          <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);        <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);   <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>void</code></p>
<p><code>void</code>表明一个运算没有返回值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript: void(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><ul>
<li><p><code>in</code></p>
<p><code>in</code>操作符如果所制定得属性确实存在于所制定的对象中，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> arrs);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">in</span> arrs);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> arrs);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">in</span> o);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">in</span> o);       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code></p>
<p><code>instanceof</code>操作符如果所判断的对象是所指定的对象类型，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.log(theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="基本表达式"><a href="#基本表达式" class="headerlink" title="基本表达式"></a>基本表达式</h4><ul>
<li><p><code>this</code></p>
<p><code>this</code>关键字被用于指代方法中正在被调用的对象，</p>
</li>
</ul>
<h4 id="左值表达式"><a href="#左值表达式" class="headerlink" title="左值表达式"></a>左值表达式</h4><ul>
<li><p><code>new</code></p>
<p><code>new</code>可以创建一个自定义类型或者是预置类型的对象实例。</p>
</li>
<li><p><code>super</code></p>
<p><code>super</code>可以用来调用一个对象父类的函数</p>
</li>
<li><p>扩展语句</p>
<p>扩展语句允许一个表达式在原地展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);    <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
</search>
