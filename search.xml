<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP协议初探</title>
    <url>/code/HTTP%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%8E%A2.html</url>
    <content><![CDATA[<h2 id="HTTP协议初探"><a href="#HTTP协议初探" class="headerlink" title="HTTP协议初探"></a>HTTP协议初探</h2><ul>
<li><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p>HTTP(Hyper Text Transfer Protocol)即超文本传输协议，它的发展是万维网协会(World Wide Web Consortium)和Internet小组IETF(Internet Engineering Task Force)合作的结果，最终发布了一系列的RFC。RFC 1945定义了HTTP/1.0版本，其中最著名的就是RFC 2616，其定义了普遍使用的一个版本——HTTP 1.1         </p>
</blockquote>
<p>HTTP协议是用于从www服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。</p>
<p>HTTP是一个应用层协议，由请求和相应构成，是一个标准的C/S(客户端/服务器)模型。<strong>HTTP是一个无状态的协议</strong></p>
<a id="more"></a></li>
<li><h4 id="在TCP-IP协议栈中的位置"><a href="#在TCP-IP协议栈中的位置" class="headerlink" title="在TCP/IP协议栈中的位置"></a>在TCP/IP协议栈中的位置</h4><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上(HTTPS)</p>
</li>
<li><h4 id="HTTP的请求相应模型"><a href="#HTTP的请求相应模型" class="headerlink" title="HTTP的请求相应模型"></a>HTTP的请求相应模型</h4><p>HTTP协议永远都是客户端发起请求，服务器返回相应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p>
<p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有关系的。</p>
</li>
<li><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一次HTTP操作称为一个事务，其工作过程课分为四部：</p>
<ol>
<li>首先客户机与服务器建立连接，只要单击某个超级链接，HTTP的工作开始</li>
<li>建立链接后，客户机发送一个请求给服务器，请求方式的格式为:统一资源标识符(URL)、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容</li>
<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容</li>
<li>客户端接收服务器所返回的信息通过浏览器显示出来，然后客户端与服务器断开链接</li>
</ol>
<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回给客户端</p>
</li>
<li><h4 id="头域"><a href="#头域" class="headerlink" title="头域"></a>头域</h4><p>每个头域由一个域名，冒号(:)和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处使用至少一个空格或制表符</p>
<ol>
<li><p>Host头域</p>
<p>Host头域指定请求资源的Internet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</p>
</li>
<li><p>Referer头域</p>
<p> Referer头域允许客户端指定请求URI的源资源地址，这可以允许服务器生成回退链表，可用来登录、优化cache等。它也允许废除的或错误的连接由于维护的目的被追踪。如果请求的URI没有自己的URI地址，Referer不能被发送。如果指定的是部分URI地址，则此地址应该是一个相对地址。</p>
</li>
<li><p>User-Agent头域</p>
<p>User-Agent头域的内容包含发出请求的用户信息</p>
</li>
<li><p>Cache-Control头域</p>
<p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程。请求时的缓存指令包括<strong>no-cache</strong>、<strong>no-store</strong>、<strong>max-age</strong>、<strong>max-stale</strong>、<strong>min-fresh</strong>、<strong>only-if-cached</strong>，响应消息中的指令包括<strong>public</strong>、<strong>private</strong>、<strong>no-cache</strong>、<strong>no-store</strong>、<strong>no-transform</strong>、<strong>must-revalidate</strong>、<strong>proxy-revalidate</strong>、<strong>max-age</strong>。</p>
</li>
<li><p>Date头域</p>
<p>Date头域表示消息发送的时间，时间的描述格式由<strong>rfc822</strong>定义。</p>
</li>
</ol>
</li>
<li><h4 id="HTTP协议中的几个重要概念"><a href="#HTTP协议中的几个重要概念" class="headerlink" title="HTTP协议中的几个重要概念"></a>HTTP协议中的几个重要概念</h4><ol>
<li><p>连接：Connection</p>
<p>一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p>
<p>在HTTP/1.1中，request和response头中都有可能出现一个connection的头，此header的含义是client和server通信时对于长连接如何进行处理</p>
<p>在HTTP/1.1中，client和server都是默认支持长连接的，如果client使用HTTP/1.1协议，但又不希望使用长连接，则需要在header中指明Connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp连接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp连接了</p>
</li>
<li><p>消息：Message</p>
<p>HTTP通讯的基本单位，包括一个结构化的八元祖序列并通过连接传输</p>
</li>
<li><p>请求：Request</p>
<p>一个从客户端到服务器的请求信息包括应用于资源的方法，资源的标识符和协议的版本号</p>
</li>
<li><p>响应：Response</p>
<p>一个从服务器返回的信息包括HTTP协议的版本号，请求的状态和文档的MIME类型。</p>
</li>
<li><p>资源：Resource</p>
<p>由URI标识的网络数据对象或服务</p>
</li>
<li><p>实体：Entity</p>
<p>数据资源或来自服务资源的回应的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p>
</li>
<li><p>客户机：Client</p>
<p>一个为发送请求目的而建立连接的应用程序</p>
</li>
<li><p>用户代理：UserAgent</p>
<p>初始化一个请求的客户机。它们是浏览器、编辑器或者是其它用户工具。</p>
</li>
<li><p>服务器：Server</p>
<p>一个接受连接并对请求返回信息的应用程序。</p>
</li>
<li><p>源服务器：Originserver</p>
<p>是一个给定资源可以在其上驻留或被创建的服务器。</p>
</li>
<li><p>代理：Proxy</p>
<p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求前，必须解释如果可能并重写它。</p>
<p>代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p>
</li>
<li><p>网关：Gateway</p>
<p>一个作为其它服务器中介媒介的服务器。与代理不同的是，网关接受请求对被请求的资源来说它就是源服务器。发出请求的客户机并没有意识到它在同网关打交道。</p>
<p>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p>
</li>
<li><p>通道：Tunnel</p>
<p>通道是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通信，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
</li>
<li><p>缓存：Cache</p>
<p>反应信息的局域存储。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议补充</title>
    <url>/code/HTTP%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85.html</url>
    <content><![CDATA[<blockquote>
<p>上次我们对HTTP协议已经有了吃不的了解，今天我们就来继续学习一下HTTP协议</p>
</blockquote>
<ol>
<li><p>HTTP协议格式</p>
<p>HTTP协议的格式大致可划分成一下几个部分</p>
<ul>
<li>Request<ul>
<li>Request line<ul>
<li>method</li>
<li>path</li>
<li>Version</li>
</ul>
</li>
<li>head</li>
<li>body</li>
</ul>
</li>
<li>Response<ul>
<li>Response line<ul>
<li>version</li>
<li>Status code</li>
<li>Statis text</li>
</ul>
</li>
<li>head</li>
<li>body<a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP Method(方法)</p>
<p>HTTP Method是HTTP请求中Request部分，大概有以下几种定义:</p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ul>
<p>在这几种方法中，比较常用的是<strong>GET</strong>和<strong>POST</strong>方法，HEAD和GET类似，只返回请求头</p>
<p>PUT和DELETE分别表示添加资源和删除资源，这只是一种语义上的约定，并没有强约束</p>
<p>CONNECT多用于HTTPS和WebSocket</p>
<p>OPTIONS和TRACE一般用于调试，多数线上服务器不支持</p>
</li>
<li><p>HTTP Status code(状态码)和HTTP status text(状态文本)</p>
<p>常见的状态码有以下几种:</p>
<ul>
<li>1xx: 临时回应，表示客户端请继续</li>
<li>2xx: 请求成功<ul>
<li>200: 请求成功</li>
</ul>
</li>
<li>3xx: 表示请求的目的有变化，希望客户端进一步处理<ul>
<li>301&amp;302：永久性与临时性跳转</li>
<li>304：客户端缓存没有更新</li>
</ul>
</li>
<li>4xx: 客户端请求错误<ul>
<li>403：无权限</li>
<li>404：表示请求的页面不存在</li>
<li>418：这是一个彩蛋</li>
</ul>
</li>
<li>5xx: 服务端请求错误<ul>
<li>500: 服务端错误</li>
<li>503: 服务端暂时性错误，可以稍后再试</li>
</ul>
</li>
</ul>
<p>在前端开发的过程中，1xx系列的状态码被浏览器http库直接处理掉了，不会让上层知晓</p>
<p>2xx系列的状态码通常是网页请求成功的标志</p>
<p>3xx系列比较复杂，301和302两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上301更接近于一种报错，提示客户端下次别来了</p>
<p>产生304状态的前提是客户端本地已经有缓存的版本，并且在Request中告诉了服务端，当服务端通过时间或者tag发现没有更新的时候，就会返回一个不含body的304状态</p>
</li>
<li><p>HTTP Head(HTTP头)</p>
<p>HTTP头可以看作一个键值对。原则上，HTTP头也是一种数据，我们可以自由定义HTTP头和值。在HTTP规范中规定了一些特殊的HTTP头。</p>
<p>Request Header              </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">Request Header</th>
<th align="center">规定</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">浏览器端接收的格式</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">浏览器接收的编码方式</td>
</tr>
<tr>
<td align="center">Accept_Language</td>
<td align="center">浏览器接受的语言，用于服务端判断多语言</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的事件机制</title>
    <url>/code/JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<h4 id="1-ECMA的标准事件流"><a href="#1-ECMA的标准事件流" class="headerlink" title="1. ECMA的标准事件流"></a>1. ECMA的标准事件流</h4><p>ECMAScript的标准事件流共分为三个阶段: <strong>事件捕获阶段</strong>、<strong>处于目标阶段</strong>、<strong>事件冒泡阶段</strong>。</p>
<p>以下是一个简单的例子:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>点击按钮标准的事件触发分别经历以下三个阶段:</p>
<p><img src="https://images0.cnblogs.com/blog2015/697856/201504/080003152437715.png" alt="图片"></p>
<p>事件触发一次经历三个阶段，所以我们在一个元素上注册事件也就可以在对应阶段注册事件，移除事件一样。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准注册事件函数 target: 文档节点、document、window 或 XMLHttpRequest。type: 注册事件类型(不包含on)，listener: 事件的回调函数，useCapture:事件注册在捕获期间还是冒泡期间</span></span><br><span class="line">target.addEventListener(type, listener, useCapture); </span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：给button注册onclick事件，要是在捕获阶段注册</span></span><br><span class="line">button.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在某一个元素上撤销已注册的事件。 这里强调的是 这里的listener必须与已注册的listener是同一个</span></span><br><span class="line">target.removeEventListener(type, listener, useCapture);</span><br></pre></td></tr></table></figure>

<h4 id="2-IE中的事件流"><a href="#2-IE中的事件流" class="headerlink" title="2. IE中的事件流"></a>2. IE中的事件流</h4><p>IE中的事件是非标准的，总共分为两个阶段: <strong>处于目标阶段</strong>、<strong>冒泡阶段</strong>。</p>
<p>上面提到的例子在IE中执行时这样的:</p>
<p><img src="https://images0.cnblogs.com/blog2015/697856/201504/080003359931643.png" alt="图片"></p>
<p>IE中的事件注册与销毁事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IE注册事件函数 target: 文档节点、document、window 或 XMLHttpRequest。type: 注册事件类型(包含on) listener: 事件的回调函数 由于没有事件捕获阶段，所以没有useCapture参数</span></span><br><span class="line">target.attachEvent(type, listener);</span><br><span class="line"></span><br><span class="line">target.detachEvent(type,listener);   <span class="comment">//参数与注册参数相对应。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-事件的执行顺序"><a href="#3-事件的执行顺序" class="headerlink" title="3. 事件的执行顺序"></a>3. 事件的执行顺序</h4><p>一般事件的执行顺序： 事件的捕获阶段==&gt;处于目标阶段==&gt;事件的冒泡阶段==&gt;事件的默认行为</p>
<p>事件的默认行为是最后才执行的，所以我们可以阻止事件的默认行为。例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻止文本框获取焦点  </span></span><br><span class="line"><span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(<span class="string">"inputText"</span>);</span><br><span class="line">input.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event=event||<span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span>(event.preventDefault)&#123;  <span class="comment">//非IE浏览器阻止事件默认行为</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    event.returnValue=<span class="literal">false</span>; <span class="comment">//IE浏览器阻止事件默认行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-跨浏览器的注册事件"><a href="#4-跨浏览器的注册事件" class="headerlink" title="4. 跨浏览器的注册事件"></a>4. 跨浏览器的注册事件</h4><p>上面我们提到IE是非标准的事件流，所以要跨浏览器注册事件的话需要一些处理，下面是个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil =  &#123;</span><br><span class="line">  <span class="comment">//注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的冒泡阶段</span></span><br><span class="line">  addEventListener: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      <span class="comment">// 非IE</span></span><br><span class="line">      element.addEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      <span class="comment">// IE</span></span><br><span class="line">      element.attachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//撤销事件</span></span><br><span class="line">  removeEventListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-DOM事件"><a href="#5-DOM事件" class="headerlink" title="5. DOM事件"></a>5. DOM事件</h4><ul>
<li><p>DOM0级事件</p>
<p>javaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序的属性。这种为事件处理程序赋值的方法是在第四代Web浏览器中出现的，而且至今仍然为所有现在浏览器支持。原因主要有两点： <strong>简单</strong>、<strong>具有跨浏览器优势</strong>。 每个元素（window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如 onclick， onmousedown。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'click'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局限性: </p>
<p>1.某一个属性只能赋值给一个函数，也就导致在某一个元素上的某一个事件属性只能对应着一个函数。多次注册时，已最后一次注册为准。</p>
<p>2.DOM0级事件全部都是默认在冒泡阶段执行。</p>
</li>
<li><p>DOM2级事件</p>
<p>我们在上面定义的跨浏览注册事件函数，就是一个DOM2级注册事件。DOM2级注册事件相比于DOM0级的优势就在于其可以多次注册，并且执行顺序与注册顺序一致。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'mybtn'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"1"</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"2"</span>);&#125;</span><br><span class="line">EventUtil.addEventListener(btn,<span class="string">"click"</span>,fun1);  <span class="comment">//注册第一个事件</span></span><br><span class="line">EventUtil.addEventListener(btn,<span class="string">"click"</span>,fun1); <span class="comment">//注册第二个事件，触发事件的时候会先弹出1在弹出2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-事件对象"><a href="#6-事件对象" class="headerlink" title="6.  事件对象"></a>6.  事件对象</h4><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有事件有关的信息。例如，单击事件中会包含鼠标的位置信息，键盘触发的事件中会包含按下的键位有关的信息。所有的浏览器都支持event，但支持的方式却有不同。</p>
<ul>
<li>标准浏览器中的事件对象             </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th align="center">类型</th>
<th align="center">读写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bubbles</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作</td>
</tr>
<tr>
<td>currentTarget</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回其事件监听器触发该事件的元素</td>
</tr>
<tr>
<td>eventPhase</td>
<td align="center">Intenger</td>
<td align="center">只读</td>
<td>返回事件传播的当前阶段</td>
</tr>
<tr>
<td>target</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回触发此事件的元素（事件的目标节点）</td>
</tr>
<tr>
<td>timeStamp</td>
<td align="center">Date</td>
<td align="center">只读</td>
<td>返回事件生成的日期和时间</td>
</tr>
<tr>
<td>type</td>
<td align="center">String</td>
<td align="center">只读</td>
<td>返回当前 Event 对象表示的事件的名称</td>
</tr>
<tr>
<td>trusted</td>
<td align="center">boolean</td>
<td align="center">只读</td>
<td>该事件是否是浏览器生成(true代表是浏览器生成，false代表是开发人员创建)</td>
</tr>
<tr>
<td>preventDefault</td>
<td align="center">Function</td>
<td align="center">只读</td>
<td>取消事件的默认行为在<a href="http://www.w3school.com.cn/jsref/event_cancelable.asp" target="_blank" rel="noopener">cancelable</a>=true时有效</td>
</tr>
<tr>
<td>stopPropagation</td>
<td align="center">Function</td>
<td align="center">只读</td>
<td>取消事件的捕获或者冒泡行为在<a href="http://www.w3school.com.cn/jsref/event_bubbles.asp" target="_blank" rel="noopener">bubbles</a>=true时有效</td>
</tr>
</tbody></table>
<p>​        在事件处理程序内部，对象this始终指向currentTarget的值，而target则只包含事件的实际目标。</p>
<ul>
<li>IE中的事件对象           </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th align="center">类型</th>
<th align="center">读写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cancelBubble</td>
<td align="center">boolean</td>
<td align="center">读/写</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>returnValue</td>
<td align="center">boolean</td>
<td align="center">读/写</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作</td>
</tr>
<tr>
<td>srcElement</td>
<td align="center">Element</td>
<td align="center">只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>type</td>
<td align="center">String</td>
<td align="center">只读</td>
<td>被触发事件的类型</td>
</tr>
</tbody></table>
<p>  上面的这些属性，是任何一个事件均会具有的属性。</p>
<p>  在IE中有些srcElement对应着target;</p>
<p>  执行event.returnValue=false对应着event.preventDefault();</p>
<p>  执行event.cancelBubble=true对应着event.stopPropagation();</p>
<p>  同时对于一些相关属性IE 比如 relatedTarget属性对应IE中的fromElement和toElement.属性</p>
<ul>
<li><p>跨浏览器的事件对象</p>
<p>由于IE和标准的事件对象不一致，所以跨浏览器的事件对象需要做一些处理。例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil =  &#123;</span><br><span class="line">  <span class="comment">//注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的捕获阶段</span></span><br><span class="line">  addEventListener: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = callback;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//获取事件</span></span><br><span class="line">  getEvent:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event||<span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//获取事件的触发目标</span></span><br><span class="line">  getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target||event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//阻止事件的默认行为</span></span><br><span class="line">  preventDefault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.preventDefault?event.preventDefault():event.returnValue=<span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//阻止事件冒泡</span></span><br><span class="line">  stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.stopPropagation?event.stopPropagation:event.cancelBubble=<span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//撤销事件</span></span><br><span class="line">  removeEventListener: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">'on'</span> + type, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个事件在其被触发时，都有一些其特有的属性，比如键盘事件会有键位信息，鼠标事件会有会有位置信息。onmouseenter事件会有fromElement(IE)中，relatedTarget(非IE);onmouseover事件会有toElement(IE)中，relatedTarget(非IE).</p>
</li>
</ul>
<h4 id="7-自定义事件"><a href="#7-自定义事件" class="headerlink" title="7. 自定义事件"></a>7. 自定义事件</h4><ul>
<li><p>模拟鼠标事件</p>
<p>非IE浏览器</p>
<p>创建鼠标事件的方法是createEvent()传入字符串“MouseEvent”.返回的对象有initMouseEvent()方法,这个方法有15个参数，分别与鼠标事件中某个典型的属性一一对应。               </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”click”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>抽象视图：事件授予的视图，这个值几乎全是document.defaultView.</td>
</tr>
<tr>
<td>detail</td>
<td align="center">Intenger</td>
<td>附加的事件信息这个初始化时一般应该默认为0。</td>
</tr>
<tr>
<td>screenX</td>
<td align="center">Intenger</td>
<td>事件距离屏幕左边的X坐标</td>
</tr>
<tr>
<td>screenY</td>
<td align="center">Intenger</td>
<td>事件距离屏幕上边的y坐标</td>
</tr>
<tr>
<td>clientX</td>
<td align="center">Intenger</td>
<td>事件距离可视区域左边的X坐标</td>
</tr>
<tr>
<td>clientY</td>
<td align="center">Intenger</td>
<td>事件距离可视区域上边的y坐标</td>
</tr>
<tr>
<td>ctrlKey</td>
<td align="center">Boolean</td>
<td>代表ctrol键是否被按下，默认为false。</td>
</tr>
<tr>
<td>altKey</td>
<td align="center">Boolean</td>
<td>代表alt键是否被按下，默认为false。</td>
</tr>
<tr>
<td>shiftKey</td>
<td align="center">Boolean</td>
<td>Boolean类型 ： 代表shif键是否被按下，默认为false</td>
</tr>
<tr>
<td>metaKey</td>
<td align="center">Boolean</td>
<td>代表meta key 是否被按下，默认是false</td>
</tr>
<tr>
<td>button</td>
<td align="center">Intenger</td>
<td>表示被按下的鼠标键，默认是零</td>
</tr>
<tr>
<td>relatedTarget</td>
<td align="center">Elment</td>
<td>事件的关联对象只有在模拟mouseover 和 mouseout时用到</td>
</tr>
<tr>
<td>使用方法：</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEvent(<span class="string">"MouseEvent"</span>);</span><br><span class="line">    event.initMouseEvent(<span class="string">"click"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line">btn.dispatchEvent(event);  <span class="comment">//在这一步会设置event.target,以及触发事件类型</span></span><br></pre></td></tr></table></figure>

<p>  IE浏览器</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEventObject();</span><br><span class="line">event.screenX=<span class="number">100</span>;</span><br><span class="line">event.screenY=<span class="number">100</span>;</span><br><span class="line">event.clientX=<span class="number">100</span>;</span><br><span class="line">event.clientX=<span class="number">100</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">btn.fireEvent(<span class="string">"onclick"</span>,event);   <span class="comment">//在这一步会设置event.serElement,以及触发事件类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>模拟键盘事件</p>
<p> 键盘模拟事件是在DOM3规范中定义的。火狐浏览器根据草案定义了DOM2级中模拟键盘事件。在这里，我们讲述的是DOM3级规范，DOM3级不提倡使用oneypress事件。</p>
<p> DOM3标准</p>
<p> 创建键盘事件的方法是createEvent()传入字符串“KeyboardEvent”.返回的对象有initKeyEvent()方法,这个方法有以下参数：           </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>被授予事件的是图. 通常值为：document.defaultView.</td>
</tr>
<tr>
<td>key</td>
<td align="center">string</td>
<td>按下的键对应的code.</td>
</tr>
<tr>
<td>location</td>
<td align="center">integer</td>
<td>按下键所在的位置. 0 ：默认键盘, 1 左侧位置, 2 右侧位置, 3 数字键盘区, 4 虚拟键盘区, or 5 游戏手柄.</td>
</tr>
<tr>
<td>modifiers</td>
<td align="center">Boolean</td>
<td>一个有空格分开的修饰符列表.</td>
</tr>
<tr>
<td>repeat</td>
<td align="center">integer</td>
<td>一行中某个键被按下的次数</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox=<span class="built_in">document</span>.getElementById(<span class="string">"myTextBox"</span>),event;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"KeyboardEvent"</span>,<span class="number">3.0</span>))&#123;</span><br><span class="line">  event=<span class="built_in">document</span>.createEvent(<span class="string">"KeyboardEvent"</span>);</span><br><span class="line">  event.initKeyboardEvent(<span class="string">"keydown"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="string">"a"</span>,<span class="number">0</span>,<span class="string">"shift"</span>,<span class="number">0</span>);</span><br><span class="line">  textbox.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  并非所有的浏览器都实现了DOM3标准，下面看一下各个浏览器时怎么模拟鼠标事件。 </p>
<p>  <strong>FireFox浏览器</strong></p>
<pre><code>在FireFox中，调用createEvent()并传入KeyEvents就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接受以下10个参数：          </code></pre><table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>view</td>
<td align="center">AbstractView</td>
<td>被授予事件的是图. 通常值为：document.defaultView.</td>
</tr>
<tr>
<td>ctrlKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了ctrl键位，默认值 false.</td>
</tr>
<tr>
<td>altKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了altl键位，默认值 false</td>
</tr>
<tr>
<td>shiftKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了shift键位，默认值 false.</td>
</tr>
<tr>
<td>metaKey</td>
<td align="center">Boolean</td>
<td>表示是否按下了meta键位，默认值 false.</td>
</tr>
<tr>
<td>KeyCode</td>
<td align="center">Intenger</td>
<td>被按下或者被释放的键位. 这个参数对keydown和keyup有用</td>
</tr>
<tr>
<td>charCode</td>
<td align="center">Intenger</td>
<td>通过按键生成的ASCII编码. 这个参数对keypress有用</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只适用于FireFox浏览器，在火狐浏览器中会在文本框中显示A </span></span><br><span class="line"><span class="keyword">var</span> textbox=<span class="built_in">document</span>.getElementById(<span class="string">"myTextBox"</span>);</span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span>  event=<span class="built_in">document</span>.createEvent(<span class="string">"keyEvents"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initKeyEvent(<span class="string">"keypress"</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="built_in">document</span>.defaultView,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="number">65</span>,<span class="number">65</span>);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>  <strong>非火狐非IE浏览器</strong> 在其他浏览器中，则需要创建一个通用事件，然后再向通用事件中添加键盘事件的特有信息。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在其他浏览器中不能输入文本，这是因为非浏览器创建的事件并不能精确的模拟事件。</span></span><br><span class="line"><span class="comment">//创建事件对象</span></span><br><span class="line"><span class="keyword">var</span>  event=<span class="built_in">document</span>.createEvent(<span class="string">"Events"</span>);</span><br><span class="line"><span class="comment">//初始化事件对象</span></span><br><span class="line">event.initEvent(type,bubble,cancelable);</span><br><span class="line"><span class="comment">//初始化事件信息</span></span><br><span class="line">event.view=<span class="built_in">document</span>.defaultView;</span><br><span class="line">event.altKey=<span class="literal">false</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">event.keyCode=<span class="number">65</span>;</span><br><span class="line">event.charCode=<span class="number">65</span>;</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">textbox.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>  <strong>IE浏览器</strong>  IE浏览器创建键盘事件和创建鼠标事件有点类似。如下所示：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event=<span class="built_in">document</span>.createEventObject();</span><br><span class="line">event.altKey=<span class="literal">false</span>;</span><br><span class="line">event.ctrlKey=<span class="literal">false</span>;</span><br><span class="line">event.shiftKey=<span class="literal">false</span>;</span><br><span class="line">event.keyCode=<span class="number">65</span>;</span><br><span class="line">textbox.fireEvent(<span class="string">"onkeydown"</span>,event);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义DOM事件</p>
<p>DOM3级还定义了”自定义事件”。自定义事件不同时DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件；</p>
<p> <strong>非IE浏览器</strong> 可以调用createEvent(“CustomEvent”)返回的对象有一个名为initCustomEvent()方法，接受如下四个参数:          </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td align="center">String</td>
<td>要触发的事件类型,例如”keydown”.</td>
</tr>
<tr>
<td>bubbles</td>
<td align="center">Boolean</td>
<td>表示该事件是否能够被取消，针对鼠标事件模拟，该值应该被设置为true。</td>
</tr>
<tr>
<td>cancelable</td>
<td align="center">Boolean</td>
<td>表示该事件是被取消</td>
</tr>
<tr>
<td>detail</td>
<td align="center">Boolean</td>
<td>保存在event对象的detail属性中</td>
</tr>
</tbody></table>
<p>  使用方法:</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"inputText"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(<span class="string">"inputText"</span>);</span></span><br><span class="line"><span class="actionscript">      EventUtil.addEventListener(input,<span class="string">"myevent"</span>,<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line">        event=EventUtil.getEvent(event);</span><br><span class="line"><span class="actionscript">        alert(event.detail.message);   <span class="comment">//访问detail中的信息</span></span></span><br><span class="line"><span class="actionscript">      &#125;);<span class="comment">//注册时事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span>  button=<span class="built_in">document</span>.getElementById(<span class="string">"button"</span>);</span></span><br><span class="line"><span class="actionscript">      button.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CustomEvents"</span>,<span class="string">"3.0"</span>))&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> event=<span class="built_in">document</span>.createEvent(<span class="string">"CustomEvent"</span>);</span></span><br><span class="line"><span class="actionscript">          event.initCustomEvent(<span class="string">"myevent"</span>,<span class="literal">true</span>,<span class="literal">false</span>,&#123;message:<span class="string">"helloworld"</span>&#125;);</span></span><br><span class="line">          input.dispatchEvent(event);</span><br><span class="line"><span class="actionscript">        &#125; <span class="comment">//通过button按钮触发事件</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  IE浏览器自定义事件</p>
<p>   IE中document.createEventObject()方法不支持自定义的DOM事件。我们在有些前端框架中之所有能够实现自定义事件的各种浏览器兼容都是因为他们内部重写了一套事件机制来控制，才使得我们可以在各个浏览器上自定义事件。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的防抖和节流</title>
    <url>/code/JS%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html</url>
    <content><![CDATA[<h2 id="JS的防抖和节流"><a href="#JS的防抖和节流" class="headerlink" title="JS的防抖和节流"></a>JS的防抖和节流</h2><blockquote>
<p>前几天在面试的过程中有被问到在监听input输入事件向后台传递数据的时候要怎么优化，由于之前并没有关注性能这一块儿的问题(之前在学redis的时候有了解过使用redis做cache)于是就胡乱答了使用缓存。然后面试官前辈就提示我可以使用JS中的防抖(PS:面试全程非常nice，有回答不对的地方面试官都给我做了指正，感觉就像是在和前辈讨论技术问题)，之后我也有查阅相关资料，今天我们就来讨论一下防抖和节流</p>
</blockquote>
<a id="more"></a>
<h4 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a>1. 防抖</h4><ul>
<li><p>含义:</p>
<p>防抖，即在某一段时间内函数只执行一次，如果在这一段时间内又触发了该时间则会重新计算函数的执行时间</p>
</li>
<li><p>举个例子:</p>
<p>比如有个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要把这个函数绑定到window.onkeypress事件上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onkeypress = print</span><br></pre></td></tr></table></figure>

<p>现在每按一下键盘按键都会打印出”hello”，然后我们对其改装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; func() &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将shake这个函数绑定到window.onkeypress事件上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onkeypress = shake(print, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们再试试，发现在一个时间段内按压多个按键的时候只打印了一次”hello”，这就是一个简单的防抖实现</p>
</li>
<li><p>类型:</p>
<ul>
<li><p>延迟执行版</p>
<p>在上面的例子中我们简单实现了一个延迟执行的防抖函数，但还没有完全实现，我们还没有将事件的参数传进去，下面我们将其补充完整:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; func.apply(<span class="keyword">this</span>, args) &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用apply方法指定函数的执行上下文(this)和参数,该版本不会立即执行函数，而是在触发事件一段时间后再去执行该函数，如果在这段时间内又触发了时间则会重新计算时间</p>
</li>
<li><p>立即执行版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shake</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout)    </span><br><span class="line">    <span class="keyword">let</span> call = !timeout</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, time)</span><br><span class="line">    <span class="keyword">if</span> (call) func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该版本在事件触发后会立即执行，经过一段时间不触发事件后才能继续执行</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-节流"><a href="#2-节流" class="headerlink" title="2. 节流"></a>2. 节流</h4><ul>
<li><p>含义</p>
<p>连续触发事件但是在一段时间内只执行一次函数。节流会稀释函数的执行频率。</p>
</li>
<li><p>版本</p>
<ul>
<li><p>时间戳版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> then = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (now - then &gt; time) &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      then = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      	timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>以上我们就简单的实现了一下防抖和节流，又get到了一个点，在这里还是很感谢那位前辈的。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块</title>
    <url>/wiki/JavaScript%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的前世今生</title>
    <url>/wiki/JavaScript%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html</url>
    <content><![CDATA[<h2 id="JavaScript简史"><a href="#JavaScript简史" class="headerlink" title="JavaScript简史"></a>JavaScript简史</h2><ul>
<li>JavaScript由Brendan Eich发明，并首次应用于Netscape Navigator 2浏览器中。当时命名为LiveScript，为了赶Java的热度，后改名为JavaScript。当时它的主要目的用于验证表单数据(当时网速的限制了与服务端的交互速度)。</li>
<li>微软在IE3中加入了名为JScript的JavaScript实现。</li>
<li>由于当时并没有标准规定JavaScript的语法和特性，从而导致两个不同版本的JavaScript并存。于是在1997年，以JavasScript1.1为蓝本的建议被提交给了ECMA(欧洲计算机制造商协会)。该协会指定TC39(39号技术委员会)负责，于是出现了名为ECMAScript的语言标准(EMNA-262)，同年年底，ECMAScript1.0发布。</li>
<li>1998年6月ECMA发布ECMAScript2.0，该版主要是为了与ISO/IEC-16262保持严格一致，没有作任何新增、修改或删除处理。</li>
<li>1999年12月，ECMAScript发布ECMAScript3.0，修改的内容涉及字符串处理、错误定义和数值输出，新增了对正则表达式、新控制语句和try-catch异常处理的支持。ECMAScript3.0标志着ECMAScript成为了一门真正的编程语言。</li>
<li>2000年，ECMAScript4.0开始着手实现，但由于该版本改动幅度较大(包含强类型变量、新语句和新数据结构、真正的类和经典继承，还定义了与数据交互的新方式)，TC39下属的一个小组提出了一个名为ECMAScript3.1的替代性建议，ECMAScript3.1只进行小幅修订，能够在现有的JavaScript引擎基础上实现。最终ECMAScript4.0被放弃，ECMAScript3.1成为ECMAScript5.0并于2009年12月发布。ECMAScript5新增原生JSON对象(用于解析和序列化JSON数据)、继承的方法和高级属性定义，另外还包含一种严格模式。</li>
<li>2011年6月，ECMAScript5.1版发布，成为国际标准。</li>
<li>2015年6月，ECMAScript6版发布，成为国际标准。</li>
</ul>
<h2 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h2><p>虽然JavaScript和ECMAScript通常都被人们用来表达相同的含义，但JavaScript的含义要比ECMAScript多得多。一个完整的JavaScript应该有以下三个部分组成：</p>
<ul>
<li>语法和语义(ECMAScript)</li>
<li>文档对象模型(DOM)</li>
<li>浏览器对象模型(BOM)</li>
</ul>
<h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4><p>ECMAScript与web浏览器没有依赖关系，实际上ECMAScript定义的只是这门语言的基础，在此基础之上可以构建更完善的脚本语言。web浏览器只是ECMAScript实现可能的宿主环境之一。宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与环境之间进行交互。其他宿主环境包括Node和Adobe Flash。ECMAScript就是对实现该标准规定的各个方面内容的语言的描述。除了JavaScript，Adobe ActionScript也实现了ECMAScript。      </p>
<p>ECMA-262标准规定了这门语言的下列组成部分：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象</li>
</ul>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型(Document Object Model)是针对XML但经过扩展用于HTML的API。DOM把整个页面映射为一个多层节点结构。由于IE4和Netscape navigator4分别支持不同形式的DHTML(Dynamic HTML)导致web跨平台的天性受到影响，于是负责Web通信标准的W3C(World Wide Web Consortium,万维网联盟)开始着手规划DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在DOM中，上面的代码可以通过下面的分层节点图表示。</p>
<img src="https://code.aliyun.com/qingshanglishao/images/raw/master/节点图.png" alt="节点图" style="zoom:50%;" />

<h5 id="DOM1级"><a href="#DOM1级" class="headerlink" title="DOM1级"></a>DOM1级</h5><p>DOM1级(DOM Level 1)在1998年10月成为W3C的推荐标准，由DOM核心(DOM Core)和DOM HTML两个模块组成。DOM核心规定如何映射基于XML的文档结构，DOM HTML添加了针对HTML的对象和方法。</p>
<h4 id="DOM2级"><a href="#DOM2级" class="headerlink" title="DOM2级"></a>DOM2级</h4><p>DOM2级在原来的基础上有扩充了鼠标和用户界面事件、范围、遍历(迭代DOM文档的方法)等细分模块，同时增加了对CSS的支持。DOM2引入了下列新模块:</p>
<ul>
<li>DOM视图(DOM Views)：定义了跟踪不同文档视图的接口</li>
<li>DOM事件(DOM Events)：定义了事件和事件处理的接口</li>
<li>DOM样式(DOM Style)：定义了基于CSS为元素样式应用的接口</li>
<li>DOM遍历和范围(DOM Traversal and Range)：定义了遍历和操作文档树的接口</li>
</ul>
<h4 id="DOM3级"><a href="#DOM3级" class="headerlink" title="DOM3级"></a>DOM3级</h4><p>DOM3对DOM核心进行了扩展，开始支持XML1.0规范，涉及XML Infoset、XPath和XML Base，同时也级进一步扩展了DOM，引入了下列模块:</p>
<ul>
<li>DOM加载和保存(DOM Load and Save)：以同一方式加载和保存文档的方法</li>
<li>DOM验证(DOM Validation):：验证文档的方法</li>
</ul>
<h4 id="其他DOM标准"><a href="#其他DOM标准" class="headerlink" title="其他DOM标准"></a>其他DOM标准</h4><p>除了DOM核心和DOM HTML接口之外，另外几种语言还发布了只针对自己的DOM标准。如：</p>
<ul>
<li>SVG(Scalable Vector Graphic,可伸缩矢量图) 1.0</li>
<li>MathML(Mathematical Markup Language,数学标记语言) 1.0</li>
<li>SMIL(Synchronized Multimedia Integration Language,同步多媒体集成语言)</li>
</ul>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型(Browser Object Model)，开发人员使用BOM可以控制浏览器显示的页面以外的部分。在HTML5中吧很多BOM功能写入规范。BOM只处理浏览器窗口和框架，但人们也把一些针对浏览器的JavaScript扩展也作为BOM的一部分，下面就是这些扩展：</p>
<ul>
<li>弹出新浏览器窗口功能</li>
<li>移动、缩放和关闭浏览器窗口的功能</li>
<li>提供浏览器详细信息的navigator对象</li>
<li>提供浏览器所加载页面的详细信息的location对象</li>
<li>提供用户显示器分辨率详细信息的screen对象</li>
<li>对cookies的支持</li>
<li>像XMLHttpRequest和IE的ActiveXObject这样的自定义对象        </li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li>JavaScript高级程序设计(第3版)</li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置Vue前后端分离项目</title>
    <url>/code/Nginx%E9%85%8D%E7%BD%AEVue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE.html</url>
    <content><![CDATA[<h4 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h4><p>项目后端采用Node.js提供RESTful API服务，监听3000端口。项目前端采用Vue，打包好的dist文件夹路径为<strong>/root/vue/</strong>。使用Nginx做反向代理实现前后端分离。</p>
<a id="more"></a>
<h4 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h4><h5 id="1-配置后端"><a href="#1-配置后端" class="headerlink" title="1. 配置后端"></a>1. 配置后端</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">upstream</span> node.server &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:3000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api/ &#123;</span><br><span class="line">  <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">  <span class="attribute">proxy_pass_header</span> Server;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://node.server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-配置前端"><a href="#2-配置前端" class="headerlink" title="2. 配置前端"></a>2. 配置前端</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  <span class="attribute">alias</span> /root/project/register/app/views/;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrites</span>;    <span class="comment"># 尝试访问资源，若无资源则重定向至index.html</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="variable">@rewrites</span> &#123;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /index.html <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-配置HTTPS"><a href="#3-配置HTTPS" class="headerlink" title="3. 配置HTTPS"></a>3. 配置HTTPS</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> cert/****_bundle.crt;    <span class="comment"># bundle.crt路径</span></span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> cert/***<span class="regexp">*.key</span>;       <span class="comment"># ****.key路径</span></span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNUL$</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-配置HTTP跳转HTTPS"><a href="#4-配置HTTP跳转HTTPS" class="headerlink" title="4. 配置HTTP跳转HTTPS"></a>4. 配置HTTP跳转HTTPS</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> iot.musiiot.top;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Promises</title>
    <url>/wiki/Promises.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>也谈Unicode和UTF-8</title>
    <url>/code/%E4%B9%9F%E8%B0%88Unicode%E5%92%8CUTF-8.html</url>
    <content><![CDATA[<blockquote>
<p>最近在学习字符集相关的内容，遂以此文进行记录。</p>
</blockquote>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><ol>
<li><p>起源</p>
<p>大家都知道计算机起源于美国，而美国人一开始通信用的是<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a>字符，其包含所有大小写字母和常用的英文标点符号，足够美国人使用。后来计算机在其他国家普及，由于语种多样性ASCII字符不再满足需要。于是便有了欧洲的ISO 8859以及中文的GBK编码。但这样就有一个问题，美国的计算机接受到来自中国的电子邮件后无法正常显示内容。为了解决这种各国编码规范不统一的问题，<a href="https://en.wikipedia.org/wiki/The%20Unicode%20Consortium" target="_blank" rel="noopener">The Unicode Consortium</a>指定了Unicode(也叫国际码)标准。</p>
</li>
<li><p>编码方式</p>
<p>当前的Unicode使用16位的编码空间，每个字符占2字节，理论上最多可表示65536个字符。基本满足各种语言的使用。基本多文种平面的字符的编码为U+hhhh，每个h代表一个十六进制的数字。</p>
</li>
</ol>
<a id="more"></a>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><ol>
<li><p>起源</p>
<p>在实际传输过程中，由于不同系统平台的设计不确定性，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。Unicode 的实现方式称为 <strong>Unicode转换格式</strong>（Unicode Transformation Format，简称为 UTF）。而UTF-8就是8位的unicode转换格式。</p>
</li>
<li><p>编码方式</p>
<p>以8位为单元对UCS进行编码，每个使用UTF-8存储的字符，除了第一个自己外，其余字节的头两个比特都是以“10”开始，使文字处理器能够较快的找出每个字符的开始位置。为了兼容ASCII，UTF-8选择以可变长度存储Unicode。转换关系图如下：</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-22_19-25-08.jpg" alt=""></p>
</li>
<li><p>Unicode转UTF-8</p>
<p>已知“严”的unicode是4E25(100111000100101)， 根据上表，可以发现4E25处在第三行的<br>范围内(U+0800-U+FFFF), 因此“严”的UTF-8编码需要三个字节，即格式是<br>“1110xxxx 10xxxxxx 10xxxxxx”。 然后, 从“严”的最后一个二进制位开始，依次从后向前<br>填入格式中的x，多出的位补0。 这样就得到了“严”的UTF-8编码是”11100100 10111000<br>10100101”, 转换成十六进制就是E4B8A5。</p>
<p>附JavaScript实现代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeUTF8</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> code = <span class="built_in">parseInt</span>(str.codePointAt().toString(<span class="number">16</span>), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">let</span> bCodes = str.codePointAt().toString(<span class="number">2</span>).split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> byte, template, result = <span class="string">''</span>, temp;</span><br><span class="line">    <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'007F'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'0xxxxxxx'</span>;</span><br><span class="line">        byte = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'07FF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'110xxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'FFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1110xxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'1FFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1110xxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'1FFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'11110xxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">5</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'3FFFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'111110xx10xxxxxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">6</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code&lt;<span class="built_in">parseInt</span>(<span class="string">'7FFFFFFF'</span>, <span class="number">16</span>)) &#123;</span><br><span class="line">        template = <span class="string">'1111110x10xxxxxx10xxxxxx10xxxxxx10xxxxxx10xxxxxx'</span></span><br><span class="line">        byte = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    template = template.split(<span class="string">''</span>).reverse().map(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">'x'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bCodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bCodes.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    temp = <span class="built_in">parseInt</span>(template.reverse().join(<span class="string">''</span>), <span class="number">2</span>).toString(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">let</span> len = temp.length / byte</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=byte;i++) &#123;</span><br><span class="line">        result += <span class="string">'\\x'</span> + temp.slice((i<span class="number">-1</span>)*len, i*len)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> encoding = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="string">''</span>).map(<span class="function"><span class="params">s</span> =&gt;</span> encodeUTF8(s)).join(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(encoding(<span class="string">'严厉'</span>))</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>charset</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云oss部署Vue项目</title>
    <url>/code/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E9%83%A8%E7%BD%B2Vue%E9%A1%B9%E7%9B%AE.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么要用oss部署vue项目？使用oss部署前端项目可以利用oss的带宽以及cdn的加速来减少前端资源的加载速度。特别是当服务器的带宽小的情况下就显得更为重要，另外也可以使用oss配置免备案的域名。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>登陆阿里云控制台—&gt;对象存储oss—&gt;创建Bucket(设置区域把读写权限改为公共读就好了)</li>
<li>选中Bucket后点击基础设置—&gt;静态页面—&gt;设置默认首页为index.html—&gt;完成后保存</li>
<li>oss暂不支持vue的history路由，所以必须使用hash的路由，虽然可能不太美观，但由于我做的是微信H5页面所以基本上也看不到路由，也就不在意这些。</li>
</ol>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>目前使用的是手动上传的方式，后期可能会加上git hook 和 oss sdk来完成持续集成部分的东西，刚好我的毕设和这个相关可以花点时间研究一下。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title>代码里的后悔药——Git</title>
    <url>/code/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF%E2%80%94%E2%80%94Git.html</url>
    <content><![CDATA[<h2 id="代码里的后悔药—Git"><a href="#代码里的后悔药—Git" class="headerlink" title="代码里的后悔药—Git"></a>代码里的后悔药—Git</h2><h4 id="1-什么是Git"><a href="#1-什么是Git" class="headerlink" title="1. 什么是Git"></a>1. 什么是Git</h4><p>git是版本管理工具的一种，常见的版本管理工具还有<strong>CVS</strong>、<strong>SVN</strong>等等。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</p>
<h4 id="2-为什么要用Git"><a href="#2-为什么要用Git" class="headerlink" title="2. 为什么要用Git"></a>2. 为什么要用Git</h4><ul>
<li>分布式版本管理工具，容灾性较强</li>
<li>强大的分支和合并功能</li>
<li>支持多人协同开发<a id="more"></a>
<h4 id="3-Git和Github的关系"><a href="#3-Git和Github的关系" class="headerlink" title="3. Git和Github的关系"></a>3. Git和Github的关系</h4></li>
</ul>
<p>git是版本控制工具，而github则是一家以<strong>git</strong>作为唯一的版本库格式进行托管代码的托管平台，类似的托管平台还有<a href="https://about.gitlab.com" target="_blank" rel="noopener">gitlab</a>和<a href="https://gitee.com/" target="_blank" rel="noopener">码云gitee</a></p>
<h4 id="4-Git的安装"><a href="#4-Git的安装" class="headerlink" title="4. Git的安装"></a>4. Git的安装</h4><p>去<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>下载对应的版本(Linux和Mac用户可以使用自带的软件管理工具进行安装) </p>
<p>注：尽量不要使用git的GUI工具</p>
<h4 id="5-Git的基本概念"><a href="#5-Git的基本概念" class="headerlink" title="5. Git的基本概念"></a>5. Git的基本概念</h4><ul>
<li><h5 id="工作目录-Working-Directory"><a href="#工作目录-Working-Directory" class="headerlink" title="工作目录(Working Directory)"></a>工作目录(Working Directory)</h5><p>工作目录就是能在电脑上能看到的目录           </p>
</li>
<li><h5 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h5><p>暂存区又称缓存区，一般存放在项目文件夹的 <strong>.git</strong>目录下的<strong>index</strong>文件</p>
</li>
<li><h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><p>仓库又称版本库，git有本地仓库和远程仓库(即用来托管代码的服务器)之分。本地仓库一般存放在项目文件夹的<strong>.git</strong>目录中</p>
<p><img src="https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181008211557402-232838726.png" alt="工作区示意图"></p>
</li>
<li><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>一般项目中会有 <strong>主分支、开发分支、功能分支</strong> 等分支。Git非常鼓励使用分支。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14653704-1383d63bfa39e0bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/885/format/webp" alt="分支示意图"></p>
</li>
</ul>
<h4 id="6-Git的工作流程"><a href="#6-Git的工作流程" class="headerlink" title="6. Git的工作流程"></a>6. Git的工作流程</h4><blockquote>
<p>Git管理的文件有三种状态: 已修改(modified)、已暂存(staged)和已提交(commited)</p>
</blockquote>
<h5 id="1-在工作目录中添加修改文件"><a href="#1-在工作目录中添加修改文件" class="headerlink" title="1. 在工作目录中添加修改文件"></a>1. 在工作目录中添加修改文件</h5><h5 id="2-将需要进行版本管理的文件放入暂存区"><a href="#2-将需要进行版本管理的文件放入暂存区" class="headerlink" title="2. 将需要进行版本管理的文件放入暂存区"></a>2. 将需要进行版本管理的文件放入暂存区</h5><h5 id="3-将暂存区的文件提交到git仓库"><a href="#3-将暂存区的文件提交到git仓库" class="headerlink" title="3. 将暂存区的文件提交到git仓库"></a>3. 将暂存区的文件提交到git仓库</h5><h4 id="7-Git的基本命令"><a href="#7-Git的基本命令" class="headerlink" title="7. Git的基本命令"></a>7. Git的基本命令</h4><ul>
<li>初始化项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<ul>
<li>添加文件到暂存区</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add 文件路径</span><br></pre></td></tr></table></figure>

<ul>
<li>提交版本                 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "log"</span><br></pre></td></tr></table></figure>

<ul>
<li>版本回滚</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commitId     # 回退到指定版本，或者</span><br><span class="line">git reset --hard HEAD^        # 回退到上个版本</span><br><span class="line">git reset --hard HEAD~n       # 回退到前n个版本</span><br></pre></td></tr></table></figure>

<ul>
<li>查看仓库当前状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<ul>
<li>查看具体修改内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<ul>
<li>查看历史</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log      # 查看提交历史</span><br><span class="line">git reflog   # 查看命令历史</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- file      # 撤销工作区中的修改</span><br><span class="line">git reset HEAD file       # 撤销暂存区中的修改    HEAD表示最新的版本</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure>

<ul>
<li>远程仓库操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add 名字 &lt;repo address&gt;      # 添加远程仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如:</span></span><br><span class="line">git remote add origin https://github.com/musistudio/MusicBox</span><br><span class="line">git push name branch                   # 推送到远程仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：</span></span><br><span class="line">git push -u origin master # -u参数会将本地的分支与远程的分支关联起来，origin代表提交到哪个仓库, master代表master分支</span><br><span class="line">git clone &lt;repo address&gt;               # 从远程库克隆</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如:</span></span><br><span class="line">git clone https://github.com/musistudio/MusicBox</span><br><span class="line">git remote -v                          # 查看远程库信息</span><br><span class="line">git checkout -b name origin/name       # 在本地创建和远程分支对应的分支</span><br><span class="line">git branch --set-upstream name origin/name # 建立本地分支和远程分支的关联</span><br></pre></td></tr></table></figure>

<ul>
<li>分支操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch dev                 # 创建dev分支</span><br><span class="line">git checkout dev               # 切换到dev分支</span><br><span class="line"><span class="meta">#</span><span class="bash"> ==&gt; 上面两条命令等同于下面一条命令</span></span><br><span class="line">git branck checkout -b dev     # -b 参数表示创建并切换</span><br><span class="line">git branch                     # 查看分支</span><br><span class="line">git merge dev                  # 合并指定分支(dev)到当前分支</span><br><span class="line">git merge --no-ff -m "log" dev # 以普通模式合并分支，合并后有合并历史(禁用fast forward模式)</span><br><span class="line">git branch -d dev              # 删除指定分支(dev)</span><br><span class="line">git branch -D dev              # 丢弃没有合并的分支，使用-D强行删除</span><br><span class="line">git log --graph                # 查看分支合并图</span><br><span class="line">git rebase                     # 把本地未push的分叉提交历史整理成直线，使在查看历史提交的变化更容易</span><br></pre></td></tr></table></figure>

<ul>
<li>储存工作现场</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmitgit stash</span><br></pre></td></tr></table></figure>

<ul>
<li>标签操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0      # 给HEAD打一个v1,0的标签,也可以指定一个commit</span><br><span class="line">git tag           # 查看所有标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m "log"  # 创建带有说明的标签</span><br><span class="line">git show &lt;tagname&gt;             # 查看标签的说明文字</span><br><span class="line">git tag -d &lt;tagname&gt;           # 删除本地标签</span><br><span class="line">git push origin &lt;tagname&gt;      # 向远程推送本地标签</span><br><span class="line">git push origin --tags         # 向远程推送所有未推送过的标签</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;  # 删除远程标签</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云代码托管平台托管博客图床</title>
    <url>/%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A.html</url>
    <content><![CDATA[<blockquote>
<p>无折腾，不青春</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>博客的图床在试过QQ空间相册(防盗链)，百度网盘(时间限制)之后，发现还是需要一个稳定点的图床比较好。github够稳定但是网速是在不敢恭维，突然想起之前在做<a href="https://github.com/musistudio/wukong-robot-install-script" target="_blank" rel="noopener">wukong-robot-install-script</a>的时候我用用过<a href="https://code.aliyun.com/" target="_blank" rel="noopener">阿里云的代码托管平台</a>进行仓库加速，使用的时候速度的确挺快的。那能不能使用这个来托管博客的图床呢？</p>
<a id="more"></a>

<h4 id="折腾开始"><a href="#折腾开始" class="headerlink" title="折腾开始"></a>折腾开始</h4><ol>
<li><p>首先打开阿里云的代码托管平台，使用阿里云账号登录后新建一个项目。名称随意，描述随意，可见等级选Public。如下图所示:<br><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-09-52.jpg" alt="新建项目示意图"></p>
</li>
<li><p>项目建好后在首页点击设置进入账户设置页，然后点击SSH公钥选项将自己电脑的公钥粘贴到这里。如果不知道怎么操作网页上有操作指示</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-13-21.jpg" alt="上传公钥示意图"></p>
</li>
<li><p>公钥上传好后打开刚刚新建的项目，复制该链接clone到电脑本地，git的具体操作这里不再赘述。</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_11-16-03.jpg" alt=""></p>
</li>
<li><p>以后要上传图片的时候将图片复制到这里然后再提交一次Push就可以啦。为方便Typora食用，我写了个自动上传脚本，代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "------welcom to use upload-image programme------"</span><br><span class="line">echo "maked by musi"</span><br><span class="line">DIR="$( cd "$( dirname "$0"  )" &amp;&amp; pwd  )"</span><br><span class="line">cd $DIR</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    echo $i</span><br><span class="line">    cp $i ./</span><br><span class="line">done</span><br><span class="line">git add .</span><br><span class="line">git commit -m"auto upload by upload-image.sh"</span><br><span class="line">git push</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    array=(`echo $i | tr '/' ' '` )  </span><br><span class="line">    lens=$&#123;#array[*]&#125;</span><br><span class="line">    echo "https://code.aliyun.com/qingshanglishao/images/raw/master/"$&#123;array[$lens-1]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>再配置一下Typora就能很方便的食用啦</p>
<p><img src="https://code.aliyun.com/qingshanglishao/images/raw/master/Xnip2020-04-11_10-40-32.jpg" alt="Typora配置示意图"></p>
</li>
</ol>
<h4 id="折腾结束"><a href="#折腾结束" class="headerlink" title="折腾结束"></a>折腾结束</h4><p>正所谓工欲善其事必先利其器，有一套顺手的工具是写好博客的开始。如果你有什么食用顺手的工具欢迎在下方评论与我交流。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>元编程</title>
    <url>/wiki/%E5%85%83%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>处理对象</title>
    <url>/wiki/%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/wiki/%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数定义，也称为函数声明或函数语句，由<code>function</code>关键字组成。其后为：</p>
<ul>
<li>函数的名称</li>
<li>函数参数列表</li>
<li>定义函数的JavaScript语句，用大括号<code>{}</code>括起来</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">theObject</span>) </span>&#123;</span><br><span class="line">  theObject.make = <span class="string">'Toyota'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">'Honda'</span>, <span class="attr">model</span>: <span class="string">'Accord'</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line">x = mycar.make; <span class="comment">// Honda</span></span><br><span class="line">myFunc(mycar);</span><br><span class="line">y = mycar.make; <span class="comment">// Toyota</span></span><br></pre></td></tr></table></figure>

<p>原始类型的参数将值传给函数，非原始类型的参数(比如对象、数组)将引用传给函数。</p>
<p>除了上面的函数声明方式，还可以通过函数表达式来创建函数。使用这种方法创建的函数可以是匿名的(即不需要函数名)，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123; <span class="keyword">return</span> number * number; &#125;;</span><br></pre></td></tr></table></figure>

<p>当然，函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">fac</span>(<span class="params">n</span>) </span>&#123;<span class="keyword">return</span> n&lt;<span class="number">2</span> ? <span class="number">1</span> : n*fac(n<span class="number">-1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>还有第三种创建函数的方法，即使用<code>Function</code>构造函数来创建一个Function对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a + b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">6</span>));    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>当函数是一个对象的属性时，它也叫方法。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数被定义后不会被自动执行，函数定义仅仅是赋予函数以名称并明确函数被调用时该做什么。调用函数才会真正执行定义函数时的动作，可以使用函数名加小括号<code>()</code>的方式调用它，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>调用函数时，他们必须在作用域内(但会有函数声明提升，即声明在调用下方)。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'function test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用域指函数声明时所处的地方，当函数在顶层被声明时就是整个程序。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数内定义的变量不能再函数之外的任何地方访问，因为变量仅仅在该函数内部有定义。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> test = <span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test);    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域和函数堆栈"><a href="#作用域和函数堆栈" class="headerlink" title="作用域和函数堆栈"></a>作用域和函数堆栈</h4><ul>
<li><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>调用自身的函数称为<strong>递归函数</strong>，一个函数可以<strong>指向</strong>并<strong>调用</strong>自身。有三种方法可以达到这个目的：</p>
<ol>
<li>函数名</li>
<li>arguments.callee</li>
<li>作用域下的一个指向该函数的变量名</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数体内，下面语句是等价的</p>
<ol>
<li>bar()</li>
<li>arguments.callee()</li>
<li>foo()</li>
</ol>
<p>在某种意义上递归近似于循环：两者都重复执行相同的代码，并且两者都需要一个终止条件。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面循环可以转化成下面的递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">  loop(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套函数和闭包</p>
<p>你可以在一个函数里面嵌套另外一个函数，内部函数对内部函数来说是私有的。它自身也形成了一个闭包。闭包是一个表达式(最常见的是一个函数)，可以拥有自身变量以及绑定这些变量的环境。这意味着内部函数可以访问外部函数的参数和变量。</p>
<p>总结如下：</p>
<ul>
<li>内部函数只可以在外部函数中访问</li>
<li>内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的函数和变量</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn_inside = out(<span class="number">3</span>);    <span class="comment">// 返回一个函数</span></span><br><span class="line"><span class="keyword">let</span> result = fn_inside(<span class="number">5</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = out(<span class="number">3</span>)(<span class="number">5</span>);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>闭包必须在其引用的所有范围内保留参数和变量，由于每次调用都可能传入不同的参数，每一次外部函数的调用实际上重新创建了一遍这歌闭包。仅当返回的函数没有再被引用时，才释放内存。</p>
<p>函数可以被多层嵌套，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x + y +z);</span><br><span class="line">    &#125;</span><br><span class="line">    C(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  B(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>);    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>函数B和C都形成了闭包，所以B可以访问A，C可以访问B和A。所以闭包可以包含多个作用域，它们递归式的包含了所有包含它的作用域，这被称为作用域链。</p>
<p>当同一个闭包作用域下两个参数或者变量同名时会产生命名冲突，最近的作用域拥有更高的优先级，这就是作用域链。链的第一个元素就是最里面的元素，最后一个元素便是最外层的作用域。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line">outside()(<span class="number">10</span>);    <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是JavaScript最强大的特性之一，JavaScript允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是外部函数不能访问·定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生命周期大于外部函数时，外部函数中定义的变量和函数的生命周期将比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createPet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sex;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getSex: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      retuen sex;</span><br><span class="line">    &#125;,</span><br><span class="line">    setSex: <span class="function"><span class="keyword">function</span>(<span class="params">newSex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> newSex == <span class="string">'string'</span> &amp;&amp; (newSex.toLowerCase() == <span class="string">'male'</span> || newSex.toLowerCase() == <span class="string">'female'</span>)) sex = newSex; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = create(<span class="string">'Pet'</span>);</span><br><span class="line">pet.getName();    <span class="comment">// Pet</span></span><br><span class="line">pet.setName(<span class="string">'Ppet'</span>);</span><br><span class="line">pet.setSex(<span class="string">'male'</span>);</span><br><span class="line">pet.getName();    <span class="comment">// ppet</span></span><br><span class="line">pet.getSex();     <span class="comment">// male</span></span><br></pre></td></tr></table></figure>

<p>如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createPet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      name = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet = createPet(<span class="string">'Pet'</span>);</span><br><span class="line">pet.setName(<span class="string">'Ppet'</span>);</span><br><span class="line">pet.getName(<span class="string">');    // Pet</span></span><br></pre></td></tr></table></figure>

<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>函数的实际参数会被保存在一个类似数组的arguments对象中，在函数内，可以使用<code>arguments[i]</code>的形式获取传入的参数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">let</span> i;</span><br><span class="line">  <span class="comment">// 遍历获取所有参数</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i] + separator;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argumnets只是类数组对象，并不是一个数组，并不拥有全部的Array对象的操作方法。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>从ES6开始，有两个新类型的参数：<strong>默认参数</strong>、<strong>剩余参数</strong></p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>在JavaScript中，函数参数的默认值是<code>undefined</code>。在ES6之前，设置默认参数一般是在函数体中判断函数值是否为undefined，如果是则赋给这个参数一个默认值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ? b : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6中可以使用以下写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>);    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p><code>rest</code>语法允许将不确定数量的参数表示成一个数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="params">x</span> =&gt;</span> a * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数表达式相比函数表达式具有较短的语法并以词法的形式绑定<code>this</code>。箭头函数总是匿名的。</p>
<h5 id="更简洁的函数"><a href="#更简洁的函数" class="headerlink" title="更简洁的函数"></a>更简洁的函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [</span><br><span class="line">  <span class="string">"Hydrogen"</span>,</span><br><span class="line">  <span class="string">"Helium"</span>,</span><br><span class="line">  <span class="string">"Lithium"</span>,</span><br><span class="line">  <span class="string">"Beryllium"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arrs.map(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123; <span class="keyword">return</span> s.length &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// logs [ 8, 6, 7, 9 ]</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arrs.map( <span class="function"><span class="params">s</span> =&gt;</span> s.length );</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// logs [ 8, 6, 7, 9 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h4><p>在箭头函数之前，每一个函数都重新定义了自己的<code>this</code>值(在构造函数中是一个新的对象，在严格模式下是undefined，在作为对象方法调用的函数中指向这个对象)。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);    <span class="comment">// undefined</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>在ES3或ES5中，通过把<code>this</code>的值赋值给一个变量赋值给一个变量可以修复这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.age);    <span class="comment">// 0</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>使用箭头函数可以捕捉闭包上下文的this值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.age = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.age);    <span class="comment">// 0</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>


<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习的方法论一：知识溯源法</title>
    <url>/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA%E4%B8%80%EF%BC%9A%E7%9F%A5%E8%AF%86%E6%BA%AF%E6%BA%90%E6%B3%95.html</url>
    <content><![CDATA[<blockquote>
<p>有一千个读者，就有一千个哈姆雷特</p>
</blockquote>
<h4 id="什么是知识溯源法"><a href="#什么是知识溯源法" class="headerlink" title="什么是知识溯源法"></a>什么是知识溯源法</h4><p>在学习本方法之前我们先来看看百度百科的定义。</p>
<blockquote>
<p><em>溯源</em>法是一种追究根源的逆向思维方式，也是一种以倒推的方式追寻原因而达到解决问题的工作方式。</p>
</blockquote>
<p>我的理解就是对知识的起源做一个探寻。计算机的历史距今也不算太久，第一台图灵完备的电子计算机ENIAC诞生于1946年，所以计算机编程的相关知识大多都是可溯源的。</p>
<a id="more"></a>

<h4 id="为什么要对知识进行溯源"><a href="#为什么要对知识进行溯源" class="headerlink" title="为什么要对知识进行溯源"></a>为什么要对知识进行溯源</h4><p>可以帮助我们了解该知识出现的历史背景，为什么会出现以及该知识所带来的影响。虽然网上现在的资料多到数不胜数，其中也不乏有一些大佬们的总结，读这些文章固然可以帮我们理解该知识点（站在巨人的肩膀上），但如果我们能拿到第一手资料的话或许我们会有一些不一样的理解（有一千个读者就有一千个哈姆雷特）。</p>
<h4 id="怎么对知识进行溯源"><a href="#怎么对知识进行溯源" class="headerlink" title="怎么对知识进行溯源"></a>怎么对知识进行溯源</h4><p>下面我会以对<strong>面向对象编程(object-oriented programming)</strong>这个概念进行溯源为例：</p>
<ol>
<li><p>通过google查询object-oriented programming出现的历史，我在维基百科(wikipedia)中找到了这个词的History。摘抄部分如下：</p>
<blockquote>
<p>Terminology invoking “objects” and “oriented” in the modern sense of object-oriented programming made its first appearance at MIT in the late 1950s and early 1960s. In the environment of the artificial intelligence group, as early as 1960, “object” could refer to identified items (LISP) atoms) with properties (attributes);Alan Kay was later to cite a detailed understanding of LISP internals as a strong influence on his thinking in 1966</p>
</blockquote>
<p>大概意思就是面向对象这个术语最早出现在19世纪50年代末到60年代初，后来Alan Kay这个人详细的解释了这个术语的含义。</p>
</li>
<li><p>随后我在<a href="https://scholar.google.com" target="_blank" rel="noopener">谷歌学术</a>找到了Alan Kay发给别人的邮件阐述他对于object-oriented programming的理解。<a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en" target="_blank" rel="noopener">原文在这里</a>，摘抄部分如下:</p>
<blockquote>
<p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other<br>systems in which this is possible, but I’m not aware of them.</p>
</blockquote>
<p>大概意思就是面向对象操作仅意味着消息传递，本地保留和保护以及隐藏状态过程。</p>
<blockquote>
<p>I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning – it took a while to see how to do messaging in a programming language efficiently enough to be useful).</p>
</blockquote>
<p>正如Alan Kay说的，每个对象就像生物细胞那样，只负责消息传递，而代谢的任务则由细胞内部完成，外部不必介入。这不正是面向对象编程的三大特性之一的<strong>封装</strong>么。</p>
<blockquote>
<p>The term “polymorphism” was imposed much later (I think by Peter Wegner) and it isn’t quite valid.</p>
</blockquote>
</li>
<li><p>Alan Kay提到他认为多态性是由Peter Wegner提出的，所以接下来继续通过谷歌学术搜到了这个人的论文</p>
<p><a href="https://dl.acm.org/doi/abs/10.1145/382192.383004" target="_blank" rel="noopener">《Concepts and paradigms of object-oriented programming》</a>。论文中提到</p>
<blockquote>
<p> Inheritance is a mechanism for sharing and reusing behavior. It is distinguished from other behavior sharing mechanisms by delayed binding of self-reference so that<br>superclasses may merge their identity with the subclasses that inherit them. </p>
</blockquote>
<p>大概含义就是继承是共享和重用行为的一种机制，它与其他行为共享机制的区别在于延迟了对自我参照的绑定，所以父类可以将其与继承它们的子类合并。</p>
</li>
<li><p>而在他的论文<a href="https://dl.acm.org/doi/abs/10.1145/6041.6042" target="_blank" rel="noopener">《On understanding types, data abstraction, and polymorphism》</a>可以找到他对于多态性的解释，摘抄如下：</p>
<blockquote>
<p>Conventional typed languages, such as Pascal, are based on the idea that functions and procedures, and hence their operands, have a unique type. Such languages are said to be monomorphic, in the sense that every value and variable can be interpreted to be of one and only one type. Monomorphic programming languages may be contrasted with polymorphic languages in which some values and variables may have more than one type. Polymorphic functions are functions whose operands (actual parameters) can have more than one type. Polymorphic types may be defined as types whose operations are applicable to operands of more than one type. </p>
</blockquote>
<p>大概含义就是 多态与单态形成对比，传统类型的语言的函数和过程及其操作数具有唯一的类型，而多态是函数其操作数（实际参数）可以具有多种类型。</p>
</li>
</ol>
<p>到此为止，对面向对象编程的溯源就结束了，在这个过程中，我们了解了其历史，并且重新的认识了面向对象的三大特性。(由于英语比较渣，有些地方可能翻译的不对 欢迎与我反馈)</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>对象模型的细节</title>
    <url>/wiki/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>循环与迭代</title>
    <url>/wiki/%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3.html</url>
    <content><![CDATA[<p>JavaScript提供了以下循环语句：</p>
<ul>
<li><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><code>for</code>语句</h4><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>([initialExpression]; [condition]; [incrementExpression])</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>当一个<code>for</code>语句执行的时候，会发生以下过程：</p>
<ol>
<li>如果存在初始化表达式<code>initialExpression</code>则会被执行，该表达式通常会初始化一个或多个循环计数器，还可以声明变量。</li>
<li>计算<code>condition</code>表达式的值，如果<code>condition</code>的值是true，则执行循环中的语句，如果是false，则终止循环。如果<code>condition</code>表达式被忽略了，则值默认为true。</li>
<li>循环中的<code>statement</code>被执行，如果有多个<code>statement</code>，可以使用代码块<code>{}</code>包裹起来。</li>
<li>如果存在更新表达式<code>incrementExpression</code>则执行。</li>
<li>回到步骤2。</li>
</ol>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do...while语句"></a><code>do...while</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>

<p><code>statement</code>在检查<code>condition</code>之前会被执行一次，如果<code>condition</code>的值为true，则会再次执行<code>statement</code>，直到<code>condition</code>的值为false。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i++);</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>条件检测会在每次<code>statement</code>执行前发生，如果<code>condition</code>返回为true，<code>statement</code>会被再次执行并紧接着再次检测<code>condition</code>，如果<code>condition</code>为false，则退出循环。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  n++;</span><br><span class="line">  x += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="labeled语句"><a href="#labeled语句" class="headerlink" title="labeled语句"></a><code>labeled</code>语句</h3><p><code>label</code>提供了带有标识符的语句，可以在程序的其他位置引用它。可以使用<code>label</code>标识循环，然后使用<code>break</code>或者<code>continue</code>语句让程序在指定处中断或是继续循环。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label: </span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p><code>label</code>的值可以是非保留字的任意标识符，例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">markLoop:</span><br><span class="line"><span class="keyword">while</span> (theMark === <span class="literal">true</span>) &#123;</span><br><span class="line">   doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h3><p><code>break</code>语句可以用来终止循环和<code>switch</code>分支语句，或者链接到<code>label</code>语句。</p>
<ul>
<li>当<code>break</code>后不带<code>label</code>时，它会立即终止当前所在的循环或<code>switch</code>语句。</li>
<li>当<code>break</code>后带<code>label</code>时，它会终止指定的带<code>label</code>的语句。</li>
</ul>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> [label];</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">0</span></span><br><span class="line">labelCancelLoops: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"外部循环: "</span> + x);</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">  z = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"内部循环: "</span> + z);</span><br><span class="line">    z += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (z === <span class="number">10</span> &amp;&amp; x === <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> labelCancelLoops;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (z === <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h3><p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span> [label];</span><br></pre></td></tr></table></figure>

<p><code>continue</code>语句可以重新启动(跳过代码块的剩余部分并进入下一个循环)一个<code>while</code>、<code>do-while</code>、<code>for</code>或者<code>label</code>语句。</p>
<ul>
<li>当使用不带<code>label</code>的<code>continue</code>语句时，终止当前这次的循环并执行下一次循环。</li>
<li>当使用带<code>label</code>的<code>continue</code>语句时，它会应用于<code>lebel</code>标识的循环语句。</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n += i;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,3,7,12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> j = <span class="number">10</span>;</span><br><span class="line">checkiandj:</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    checkj:</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((j % <span class="number">2</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span> checkj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(j + <span class="string">' is odd.'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i = '</span> + i);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'j = '</span> + j);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for...in语句"></a><code>for...in</code>语句</h3><p><code>for...in</code>语句指定一个变量名来迭代对象上的所有可枚举属性的属性名。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dump_props</span>(<span class="params">obj, obj_name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    result += obj_name + <span class="string">'.'</span> + i + <span class="string">' = '</span> + obj[i] + <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">'&lt;hr&gt;'</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若使用<code>for...in</code>语句迭代数组，则有可能除了数字索引之外，还有其他自定义的属性。因此不建议使用<code>for...in</code>语句迭代数组。</p>
</li>
<li><h3 id="for-of语句"><a href="#for-of语句" class="headerlink" title="for...of语句"></a><code>for...of</code>语句</h3><p><code>for...of</code>语句在可迭代对象(<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>arguments</code>等)上创建一个循环，并为每个属性不同的值调用一次迭代(迭代的是属性值)。</p>
<p>形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">of</span> object)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_statement" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>带键集合</title>
    <url>/wiki/%E5%B8%A6%E9%94%AE%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数字与日期</title>
    <url>/wiki/%E6%95%B0%E5%AD%97%E4%B8%8E%E6%97%A5%E6%9C%9F.html</url>
    <content><![CDATA[<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>在JavaScript中，数字以双精度64位二进制格式IEEE 754实现(一个介于±2−1023和±2+1024之间的数字，或者大约为±10−308到±10+308，数字精度为53位)。整数数字在运算完毕后，其值在±(253 − 1)内 可以认为是准确的，超出此范围后，数据已无法保证准确性。除了能表示浮点数，还可以表示<code>+Infinity(正无穷)</code>和<code>-Infinity(负无穷)</code>和<code>NaN(不是一个数字)</code>。</p>
<ul>
<li><p>十进制数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123456</span>;    <span class="comment">// 123456</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0888</span>;      <span class="comment">// 888</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0777</span>;     <span class="comment">// 非严格模式下当做八进制处理 511</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制数</p>
<p>二进制数字语法是以0开头，后面接一个大写或小写的拉丁文字母<code>B</code>(即<code>0b</code>或<code>0B</code>)，加入<code>0b</code>后边的数字不是0或1，则会报语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> FLT_SIGNBIT  = <span class="number">0b10000000000000000000000000000000</span>; <span class="comment">// 2147483648</span></span><br><span class="line"><span class="keyword">let</span> FLT_EXPONENT = <span class="number">0b01111111100000000000000000000000</span>; <span class="comment">// 2139095040</span></span><br><span class="line"><span class="keyword">let</span> FLT_MANTISSA = <span class="number">0B00000000011111111111111111111111</span>; <span class="comment">// 8388607</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>b313242;    <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>八进制数</p>
<p>八进制数字语法是以0开头的，加入后面的数字不在0-7的范围内，则会被转成十进制数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0755</span>;    <span class="comment">// 493</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0911</span>;    <span class="comment">// 911</span></span><br></pre></td></tr></table></figure>

<p>在ES5的严格模式下禁止使用八进制语法，八进制语法并不是ES5规范的一部分，但在所有浏览器中都支持八进制语法。在ES6中使用八进制需要给数字添加前缀<code>0o</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0o10</span>;    <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制数</p>
<p>十六进制数字语法是以0开头，后接一个小写或大写的拉丁文字母X(即<code>0x</code>或<code>0X</code>)，如果<code>0x</code>后面的数字超过规定的范围，则会报语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0x123</span>;    <span class="comment">// 291</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0X456</span>;    <span class="comment">// 1110</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0</span>Xjhg;    <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1E3</span>;    <span class="comment">// 1000</span></span><br><span class="line"><span class="number">2e6</span>;    <span class="comment">// 2000000</span></span><br><span class="line"><span class="number">0.1e2</span>;  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="数字对象"><a href="#数字对象" class="headerlink" title="数字对象"></a>数字对象</h4><p>内置的<code>Number</code>对象有一些有关数字的常量属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Number.MAX_VALUE</td>
<td align="center">可表示的最大值</td>
</tr>
<tr>
<td align="center">Number.MIN_VALUE</td>
<td align="center">可表示的最小值</td>
</tr>
<tr>
<td align="center">Number.NaN</td>
<td align="center">特指“非数字”</td>
</tr>
<tr>
<td align="center">Number.NEGATIVE_INFINITY</td>
<td align="center">特指“负无穷”，在溢出时返回</td>
</tr>
<tr>
<td align="center">Number.POSITIVE_INFINITY</td>
<td align="center">特指“正无穷”，在溢出时返回</td>
</tr>
<tr>
<td align="center">Number.EPSILON</td>
<td align="center">表示1与可表示的大于的最小浮点数之间的差值</td>
</tr>
<tr>
<td align="center">Number.MIN_SAFE_INTEGER</td>
<td align="center">JavaScript最小安全整数</td>
</tr>
<tr>
<td align="center">Number.MAX_SAFE_INTEGER</td>
<td align="center">JavaScript最大安全整数</td>
</tr>
</tbody></table>
<p><code>Number</code>的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Number.parseFloat()</td>
<td align="center">把字符串参数解析成浮点数，和全局方法<code>parseFloat</code>作用一致</td>
</tr>
<tr>
<td align="center">Number.parseInt()</td>
<td align="center">把字符串参数解析成特定基数对应的整型数字，和全局方法<code>parseInt</code>作用一致</td>
</tr>
<tr>
<td align="center">Number.isFinite()</td>
<td align="center">判断传入的值是否为有限数字</td>
</tr>
<tr>
<td align="center">Number.isInteger()</td>
<td align="center">判断传入的值是否为整数</td>
</tr>
<tr>
<td align="center">Number.isNaN()</td>
<td align="center">判断传入的值是否为<code>NaN</code></td>
</tr>
<tr>
<td align="center">Number.isSafeInteger()</td>
<td align="center">判断传入的值是否为安全整数</td>
</tr>
</tbody></table>
<p><code>Number</code>原型上的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">toExponential()</td>
<td align="center">返回一个数字的指数形式字符串，如：1.23e+2</td>
</tr>
<tr>
<td align="center">toFixed()</td>
<td align="center">返回指定小数位数的表示形式</td>
</tr>
<tr>
<td align="center">toPrecision()</td>
<td align="center">返回一个指定精度的数字</td>
</tr>
</tbody></table>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>JavaScript中没有日期对象，但是可以使用<code>Date</code>对象和其提供的方法来处理日期和时间。</p>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>文本格式化</title>
    <url>/wiki/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript的String类型用于表示文本型的数据，它由无符号整数值(UTF-16)作为元素而组成的集合。字符串在中的每个元素在字符串中占据一个位置。</p>
<h4 id="String字面量"><a href="#String字面量" class="headerlink" title="String字面量"></a>String字面量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用单引号或双引号创建简单字符串</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'string'</span>;    <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"test"</span>;      <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用转义字符创建复杂字符串</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'\'test\''</span>;  <span class="comment">// 'test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制转义序列</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'\xA9'</span>;      <span class="comment">// ©</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unicode转移序列</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="string">'\u00A9'</span>;    <span class="comment">// ©</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unicode字元溢出</span></span><br><span class="line"><span class="comment">// 在ES6中，通过Unicode代码点转义，可以使用十六进制数对任意字符进行转义，这使得使用Unicode转义表示大于0x10FFFF的字符成为可能</span></span><br><span class="line"><span class="string">'\u&#123;2F804&#125;'</span></span><br><span class="line"><span class="string">'\uD874\uDc04'</span>    <span class="comment">// 简单的Unicode转义需要拆分为相应的两个小于0x10FFFF的部分</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p><code>String</code>对象是对原始string类型的封装。</p>
<p>String对象方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>charAt</code>、<code>charCodeAt</code>、<code>codePointAt</code></td>
<td>返回字符串指定位置的字符或者字符编码</td>
</tr>
<tr>
<td><code>indexOf</code>、<code>lastIndexOf</code></td>
<td>分别返回字符串中指定字串的位置或者最后位置</td>
</tr>
<tr>
<td><code>startsWith</code>、<code>endsWith</code>、<code>includes</code></td>
<td>返回字符串是否以指定字符开头、结束包含指定的字符串</td>
</tr>
<tr>
<td><code>concat</code></td>
<td>连接两个字符串并返回新的字符串</td>
</tr>
<tr>
<td><code>fromCharCode</code>、<code>fromCodePoint</code></td>
<td>从指定的Unicode值序列构造一个字符串，这是String类方法，不是实例方法</td>
</tr>
<tr>
<td><code>split</code></td>
<td>通过将字符串分离成一个个子串来把一个String对象分割到一个字符串数组中</td>
</tr>
<tr>
<td><code>slice</code></td>
<td>从一个字符串提取片段并作为新字符串返回</td>
</tr>
<tr>
<td><code>substring</code>、<code>substr</code></td>
<td>分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集</td>
</tr>
<tr>
<td><code>match</code>、<code>replace</code>、<code>search</code></td>
<td>通过正则表达式来工作</td>
</tr>
<tr>
<td><code>toLowerCase</code>、<code>toUpperCase</code></td>
<td>分别返回字符串的小写表示和大写表示</td>
</tr>
<tr>
<td><code>normalize</code></td>
<td>按照指定的一种Unicode正规形式将当前字符串正规化</td>
</tr>
<tr>
<td><code>repeat</code></td>
<td>将字符串内容重复指定次数后返回</td>
</tr>
<tr>
<td><code>trim</code></td>
<td>去掉字符串开头和结尾的空格</td>
</tr>
</tbody></table>
<h4 id="多行模板字符串"><a href="#多行模板字符串" class="headerlink" title="多行模板字符串"></a>多行模板字符串</h4><p>模板字符串是一种允许内嵌表达式的String字面量，其使用<strong>``</strong>符号表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`a is</span></span><br><span class="line"><span class="string">b`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);              <span class="comment">// a is \r\nb</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`a is <span class="subst">$&#123;x&#125;</span>`</span>);    <span class="comment">// a is b</span></span><br></pre></td></tr></table></figure>



<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p><code>Intl</code>对象是ECMAScript国际化API的命名空间，它提供了语言敏感的字符串比较、数字格式化和日期时间格式化功能。<code>Collator</code>、<code>NumberFormat</code>和<code>DateTimeFormat</code>对象的构造函数是<code>Intl</code>对象的属性。</p>
<h4 id="日期和时间格式化"><a href="#日期和时间格式化" class="headerlink" title="日期和时间格式化"></a>日期和时间格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// July 17, 2014 00:00:00 UTC</span></span><br><span class="line"><span class="keyword">let</span> july172014 = <span class="keyword">new</span> <span class="built_in">Date</span>(msPerDay * (<span class="number">44</span> * <span class="number">365</span> + <span class="number">11</span> + <span class="number">197</span>));</span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  year: <span class="string">'2-digit'</span>,</span><br><span class="line">  month: <span class="string">'2-digit'</span>,</span><br><span class="line">  day: <span class="string">'2-digit'</span>,</span><br><span class="line">  hour: <span class="string">'2-digit'</span>,</span><br><span class="line">  minute: <span class="string">'2-digit'</span>,</span><br><span class="line">  timeZoneName: <span class="string">'short'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> americanDateTime = <span class="keyword">new</span> <span class="built_in">Intl</span>.DateTimeFormat(<span class="string">'en-US'</span>, options).format;</span><br><span class="line"><span class="built_in">console</span>.log(americanDateTime(july172014));    <span class="comment">// 07/17/14, 08:00 AM GMT+8</span></span><br></pre></td></tr></table></figure>

<h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gasPrice = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(<span class="string">'en-US'</span>, &#123;</span><br><span class="line">  style: <span class="string">'currency'</span>,</span><br><span class="line">  currency: <span class="string">'USD'</span>,</span><br><span class="line">  minimunFractionDigits: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(gasPrice.format(<span class="number">5.259</span>));    <span class="comment">// $5.26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hanDecimalRMBInChina = <span class="keyword">new</span> <span class="built_in">Intl</span>.NumberFormat(<span class="string">'zh-CN-u-nu-hanidec'</span>, &#123;</span><br><span class="line">  style: <span class="string">'currency'</span>,</span><br><span class="line">  currency: <span class="string">'CNY'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(hanDecimalRMBInChina.format(<span class="string">'1314.52'</span>));    <span class="comment">// ¥一,三一四.五二</span></span><br></pre></td></tr></table></figure>

<h4 id="定序"><a href="#定序" class="headerlink" title="定序"></a>定序</h4><p><code>Collator</code>通常用于字符串比较和排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 德语中有两种不同的排序方式 电话本（phonebook） 和 字典（dictionary）. 电话本排序强调发音, 比如在排序前 “ä”, “ö”等被扩展为 “ae”, “oe”等发音</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Hochberg"</span>, <span class="string">"Hönigswald"</span>, <span class="string">"Holzman"</span>];</span><br><span class="line"><span class="keyword">let</span> germanPhonebook = <span class="keyword">new</span> <span class="built_in">Intl</span>.Collator(<span class="string">"de-DE-u-co-phonebk"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(names.sort(germanPhonebook.compare).join(<span class="string">", "</span>));    <span class="comment">// Hochberg, Hönigswald, Holzman</span></span><br></pre></td></tr></table></figure>



<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中正则表达式也是对象。</p>
</blockquote>
<h4 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JavaScript中创建正则表达式有两种方法：</span></span><br><span class="line"><span class="comment">// 1. 使用正则表达式字面量，如果表达式不变该方法拥有较好的性能</span></span><br><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用RegExp的构造函数</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h4><p>一个正则表达式的模式是由简单字符所构成的<code>/abc/</code>，或是简单和特殊字符的组合<code>/ab*c/</code>。</p>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Text_formatting" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制与错误处理</title>
    <url>/wiki/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在JavaScript中，分号<code>;</code>用于分割代码中的语句，任何表达式(expression)也是语句(statement)。</p>
<h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>最基本的语句是块语句，用于对语句进行分组，该块有一对大括号<code>{}</code>进行定界:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句块通常和流程控制语句(<code>if</code>、<code>for</code>、<code>while</code>)一起使用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(x++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ES6之前，JavaScript没有块级作用域，在块中引入的变量的作用域是包含函数或者脚本，并且设置他们的效果将持续到块本身之外，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在ES6之后，可以使用<code>let</code>或<code>const</code>声明块级作用域变量。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件语句是一组在指定条件为<code>true</code>时执行的语句，JavaScript支持两个条件语句：<code>if...else</code>和<code>switch</code></p>
<ul>
<li><h6 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if...else语句"></a><code>if...else</code>语句</h6><p>如果条件为真，则使用<code>if</code>语句执行一条语句，如果条件为假，则使用可选的<code>else</code>子句执行一条语句。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的条件可以是任何计算结果为布尔值的表达式，如果结果为<code>true</code>则执行语句1，如果条件为<code>false</code>则执行语句2，语句1和语句2可以是任何语句，包括进一步嵌套<code>if</code>语句。JavaScript中的<code>else if</code>是<code>else</code>语句和<code>if</code>语句嵌套的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">  语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">  语句<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">3</span>) &#123;</span><br><span class="line">  语句<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要在条件表达式中使用赋值，通常的做法是在赋值周围加上其他括号，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((x = y)) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Boolean转换为false的值:</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>NaN</li>
<li>空字符串<code>&quot; &quot;</code></li>
</ul>
<p>其他值包括所有对象都或被转为<code>true</code>。注意原始的布尔类型和布尔对象的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(b)             <span class="comment">// =&gt; true，b是一个对象</span></span><br><span class="line"><span class="keyword">if</span>(b === <span class="literal">true</span>)    <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h4><p><code>switch</code>语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个<code>case</code>标签，如果匹配成功，则执行相关语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> label_1:</span><br><span class="line">    statements_1</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> label_2:</span><br><span class="line">    statements_2</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">    …</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    statements_def</span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序会首先查找一个与<code>expression</code>匹配的<code>case</code>语句，然后将控制权转移到该子句并执行相关的语句。如果没有匹配值，则程序会去查找<code>default</code>字句，如果找到了<code>default</code>字句则执行相关的语句，如果没有找到，程序会执行<code>switch</code>后面的语句，<code>default</code>语句通常出现在<code>switch</code>语句的最后面，当然这不是必须的。</p>
<p>每个<code>case</code>语句会关联一个可选的<code>break</code>语句，保证在匹配的语句被执行完成后可以跳出<code>switch</code>语句并继续执行后面的语句，如果<code>break</code>被忽略，则程序将继续执行<code>switch</code>语句中的下一个<code>case</code>语句</p>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在JavaScript中可以使用<code>throw</code>语句引发异常，并使用<code>try...catch</code>语句捕获处理它。</p>
<h4 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h4><p>JavaScript可以抛出任意对象作为异常，但不是所有对象都能产生相同结果。尽管抛出数字或字符串作为异常信息非常常见，但是用下列其中一种异常类型来创建将更加高效：</p>
<ul>
<li>ECMAScript exceptions</li>
<li>DOMException and DOMError</li>
</ul>
<h3 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a><code>throw</code>语句</h3><p>使用<code>throw</code>语句引发异常，并制定要抛出的异常的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'Error'</span></span><br></pre></td></tr></table></figure>

<h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try...catch语句"></a><code>try...catch</code>语句</h3><p><code>try...catch</code>语句标记一块待尝试的语句，并制定一个或多个引发异常的响应，如果引发一个异常，那么就可以使用<code>try...catch</code>语句捕获它。</p>
<p><code>try...catch</code>语句包含一个<code>try</code>代码块，可以有一个或多个语句。零个或一个<code>catch</code>代码块，包含<code>try</code>语句块中引发异常时需要执行的语句。如果<code>try</code>中的代码块没有抛出异常，则<code>catch</code>代码块被跳过。<code>finally</code>代码块总会在<code>try</code>和<code>catch</code>代码块之后执行。</p>
<ul>
<li><code>catch</code>代码块：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (catchID) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code>块指定了一个标识符(catchID)来存放抛出语句指定的值，可以用这个标识符来获取抛出的异常信息。在插入<code>trrow</code>块中创建这个标识符，标识符只存在与<code>catch</code>块的存续期间内，当<code>catch</code>块执行完成时，标识符不在可用。</p>
<ul>
<li><p><code>finally</code>代码块</p>
<p><code>finally</code>语句块无论是否抛出异常都会执行，如果抛出了一个异常，就算没有异常处理也会执行。如果<code>finally</code>块返回一个值，则这个值将会成为整个<code>try...catch...finally</code>流程的返回值，不管在<code>try</code>或<code>catch</code>中是否有任何的return语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在<code>try</code>或者<code>catch</code>里使用return语句，其会作为整个<code>try...catch...finally</code>流程的返回值，而不会中断流程的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果在<code>finally</code>块中有定义return，则会覆盖其他的返回值。</p>
</li>
</ul>
<ul>
<li><p>使用<code>Error</code>对象</p>
<p>根据错误类型，可以使用<code>name</code>和<code>message</code>获取更精炼的信息。<code>name</code>提供了常规的错误类(如<code>DOMException</code>或<code>Error</code>)，<code>message</code>提供了一条从错误对象转换成从字符串的简明信息。如果要抛出自己的异常，可以利用这些属性，使用<code>Error</code>的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingErrorProne</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ourCodeMakesAMistake()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The message'</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doSomethingToGetAJavascriptError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  doSomethingErrorProne();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;               </span><br><span class="line">  <span class="built_in">console</span>.error(e.name);    <span class="comment">// 'Error'</span></span><br><span class="line">  <span class="built_in">console</span>.error(e.message); <span class="comment">// 'The message', or a JavaScript error message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式与运算符</title>
    <url>/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content><![CDATA[<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>一个赋值运算符将它右边操作数的值赋值给它左边的操作数。JavaScript包含的赋值表达式如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">简写的操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">赋值操作符</td>
<td align="center"><code>x = y</code></td>
<td align="center"><code>x = y</code></td>
</tr>
<tr>
<td align="center">加法赋值操作符</td>
<td align="center"><code>x += y</code></td>
<td align="center"><code>x = x + y</code></td>
</tr>
<tr>
<td align="center">减法赋值操作符</td>
<td align="center"><code>x -= y</code></td>
<td align="center"><code>x = x - y</code></td>
</tr>
<tr>
<td align="center">乘法赋值操作符</td>
<td align="center"><code>x *= y</code></td>
<td align="center"><code>x = x * y</code></td>
</tr>
<tr>
<td align="center">除法赋值操作符</td>
<td align="center"><code>x /= y</code></td>
<td align="center"><code>x = x / y</code></td>
</tr>
<tr>
<td align="center">求余赋值操作符</td>
<td align="center"><code>x %= y</code></td>
<td align="center"><code>x = x % y</code></td>
</tr>
<tr>
<td align="center">求幂赋值操作符</td>
<td align="center"><code>x **= y</code></td>
<td align="center"><code>x = x ** y</code></td>
</tr>
<tr>
<td align="center">左移位赋值操作符</td>
<td align="center"><code>x &lt;&lt;= y</code></td>
<td align="center"><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td align="center">右移位赋值操作符</td>
<td align="center"><code>x &gt;&gt;= y</code></td>
<td align="center"><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td align="center">无符号右移位赋值操作符</td>
<td align="center"><code>x &gt;&gt;&gt;= y</code></td>
<td align="center"><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td align="center">按位与赋值操作符</td>
<td align="center"><code>x &amp;= y</code></td>
<td align="center"><code>x = x &amp; y</code></td>
</tr>
<tr>
<td align="center">按位异或赋值操作符</td>
<td align="center"><code>x ^= y</code></td>
<td align="center"><code>x = x ^ y</code></td>
</tr>
<tr>
<td align="center">按位或赋值操作符</td>
<td align="center"><code>x |= y</code></td>
<td align="center"><code>x = x | y</code></td>
</tr>
</tbody></table>
<h5 id="解构运算符"><a href="#解构运算符" class="headerlink" title="解构运算符"></a>解构运算符</h5><p>对于更复杂的赋值，解构赋值语法可以将属性或值从对象或数组中取出，赋值给其他变量。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, rest;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">[a, b, ...rest] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [30, 40, 50]</span></span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stage 4（已完成）提案中的特性</span></span><br><span class="line">(&#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>解构数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量声明并赋值时的解构</span></span><br><span class="line"><span class="keyword">let</span> foo = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br><span class="line"><span class="keyword">let</span> [one, two, three] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(one, two, three);    <span class="comment">// 'one', 'two', 'three'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量先声明后赋值时的解构</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">3</span>, b=<span class="number">5</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 3, 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析一个从函数返回的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);   <span class="comment">// 1, 3, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);   <span class="comment">// 1, 3</span></span><br><span class="line">[,,] = f();          <span class="comment">// 忽略全部返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用正则表达式匹配提取值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseProtocol</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parsedUrl = <span class="regexp">/^(\w+)\:\/\/([^\/]+)\/(.*)$/</span>.exec(url);</span><br><span class="line">  <span class="keyword">if</span>(!parsedUrl) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(parsedUrl);</span><br><span class="line">  <span class="keyword">let</span> [, protocol, fullhost, fullpath] = parsedUrl;</span><br><span class="line">  <span class="keyword">return</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(parseProtocol(<span class="string">'https://developer.mozilla.org/en-US/Web/JavaScript'</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(p, q);    <span class="comment">// 42, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无声明赋值</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">(&#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);    <span class="comment">// 括号()在使用对象字面量无声明结构赋值时是必须的</span></span><br><span class="line">                            <span class="comment">// &#123;a, b&#125; = &#123;a: 1, b: 2&#125; 左边会被认为是一个代码块而不是对象字面量</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b);    <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给新的变量名赋值</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: foo, <span class="attr">q</span>: bar&#125; = o;</span><br><span class="line"><span class="built_in">console</span>.log(foo, bar);    <span class="comment">// 42, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;a=<span class="number">10</span>, b=<span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">cosole.log(a, b);    <span class="comment">// 1, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给新的变量命名并提供默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:aa=<span class="number">5</span>, <span class="attr">b</span>:bb=<span class="number">10</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb);    <span class="comment">// 1, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="comment">// ES5版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES5Chart</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options === <span class="literal">undefined</span> ? &#123;&#125; : options;</span><br><span class="line">  <span class="keyword">let</span> size = options.size === <span class="literal">undefined</span> ? <span class="string">'big'</span> : options.size;</span><br><span class="line">  <span class="keyword">let</span> cords = options.cords === <span class="literal">undefined</span> ? &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125; : options.cords;</span><br><span class="line">  <span class="keyword">let</span> radius = options.size === <span class="literal">undefined</span> ? <span class="number">25</span> : options.radius;</span><br><span class="line">  <span class="built_in">console</span>.log(size, cords, radius);</span><br><span class="line">&#125;</span><br><span class="line">drawES5Chart(&#123;</span><br><span class="line">  cords: &#123;<span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;,</span><br><span class="line">  radius: <span class="number">30</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ES6版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawES6Chart</span>(<span class="params">&#123;size = <span class="string">'big'</span>, cords = &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, radius = <span class="number">25</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(size, cords, radius);</span><br><span class="line">&#125;</span><br><span class="line">drawES6Chart(&#123;</span><br><span class="line">  cords: &#123;<span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;,</span><br><span class="line">  radius: <span class="number">30</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构嵌套对象和数组</span></span><br><span class="line"><span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  title: <span class="string">'test'</span>,</span><br><span class="line">  translations: [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">'JavaScript'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  title: englishTitle,</span><br><span class="line">  translations: &#123;</span><br><span class="line">    title: localeTitle</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = metadata;</span><br><span class="line"><span class="built_in">console</span>.log(englishTitle, localeTitle);     <span class="comment">// test, JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of迭代和解构</span></span><br><span class="line"><span class="keyword">let</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Mike'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    family: &#123;</span><br><span class="line">      mother: <span class="string">'Jane'</span>,</span><br><span class="line">      father: <span class="string">'Harry'</span>,</span><br><span class="line">      brother: <span class="string">'Samantha'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    family: &#123;</span><br><span class="line">      mother: <span class="string">'Norah'</span>,</span><br><span class="line">      father: <span class="string">'Richard'</span>,</span><br><span class="line">      brother: <span class="string">'Howard'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> &#123;<span class="attr">name</span>: n, <span class="attr">family</span>: &#123;<span class="attr">father</span>: f&#125;, <span class="attr">age</span>: a&#125; <span class="keyword">of</span> people) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;n&#125;</span>, age: <span class="subst">$&#123;a&#125;</span>, father: <span class="subst">$&#123;f&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name: Mike, age: 18, father: Harry</span></span><br><span class="line"><span class="comment">// name: Tom, age: 20, father: Richard</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从作为函数实参的对象中提取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userId</span>(<span class="params">&#123;id&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whois</span>(<span class="params">&#123;displayName: displayName, fullName: &#123; firstName: name &#125;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;displayName&#125;</span> is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  displayName: <span class="string">'jdoe'</span>,</span><br><span class="line">  fullname: &#123;</span><br><span class="line">    firstName: <span class="string">'John'</span>,</span><br><span class="line">    lastName: <span class="string">'Doe'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cosole.log(<span class="string">`userId: <span class="subst">$&#123;userId(user)&#125;</span>`</span>)    <span class="comment">// userId: 42</span></span><br><span class="line">whois(user);    <span class="comment">// jdoe is John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性计算名和解构</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'z'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;[key]: foo&#125; = &#123;<span class="attr">z</span>: <span class="string">'bar'</span>&#125;;</span><br><span class="line">cosnole.log(foo);    <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构中的Rest</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest);    <span class="comment">// a, 2, &#123;c: 3, d: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效的JavaScript标识符作为属性名称</span></span><br><span class="line"><span class="keyword">const</span> foo = &#123;<span class="string">'fizz-buzz'</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="string">'fizz-buzz'</span>: fizzBuzz&#125; = foo;</span><br><span class="line"><span class="built_in">console</span>.log(fizzBuzz);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构对象时查找原型链</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">self</span>: <span class="string">'123'</span>&#125;;</span><br><span class="line">obj.__proto__.port = <span class="string">'456'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;self, port&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(self, port);    <span class="comment">// 123, 456</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符比较它的操作数并返回一个基于表达式是否为真的逻辑值，操作数可以是数字、字符串、逻辑、对象值。字符串比较是基于标准的字典顺序，使用Unicode值。在多数情况下，如果两个操作数不是相同类型，JavaScript会尝试转换它们为恰当的类型来比较。类型转换的例外使用<code>===</code>和<code>!==</code>操作符，它们不会在检查相等之前转换操作数的类型。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等于<code>==</code></td>
<td align="center">当两边操作数相等时返回true</td>
<td align="center"><code>1 == &#39;1&#39;</code></td>
</tr>
<tr>
<td align="center">不等于<code>!=</code></td>
<td align="center">当两边操作数不相等时返回true</td>
<td align="center"><code>1 != 2</code></td>
</tr>
<tr>
<td align="center">严格等于<code>===</code></td>
<td align="center">两边操作数相等且类型相同时返回true</td>
<td align="center"><code>1 === 1</code></td>
</tr>
<tr>
<td align="center">严格不等于<code>!==</code></td>
<td align="center">当两边操作数不相等或类型不相同时返回true</td>
<td align="center"><code>1 !== &#39;1&#39;</code></td>
</tr>
<tr>
<td align="center">大于<code>&gt;</code></td>
<td align="center">当左边的操作数大于右边的操作数是返回true</td>
<td align="center"><code>2 &gt; 1</code></td>
</tr>
<tr>
<td align="center">小于<code>&lt;</code></td>
<td align="center">当左边的操作数小于右边的操作数是返回true</td>
<td align="center"><code>1 &lt; 2</code></td>
</tr>
<tr>
<td align="center">大于等于<code>&gt;=</code></td>
<td align="center">当左边的操作数大于或等于右边的操作数是返回true</td>
<td align="center"><code>2 &gt;= 2</code></td>
</tr>
<tr>
<td align="center">小于等于<code>&lt;=</code></td>
<td align="center">当左边的操作数小于或等于右边的操作数是返回true</td>
<td align="center"><code>2 &lt;= 2</code></td>
</tr>
</tbody></table>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符使用数值作为操作数并返回一个数值。注：除<code>0</code>会返回<code>Infinity</code>，除<code>-0</code>会返回<code>-Infinity</code>。除了标准的算数运算符(<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>)，JavaScript还提供了一下算数运算符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求余<code>%</code></td>
<td align="center">二元运算符，返回相除之后的余数</td>
<td align="center"><code>12 % 5 // 2</code></td>
</tr>
<tr>
<td align="center">自增<code>++</code></td>
<td align="center">一元运算符，将操作数的值加1。如果放在操作数的前面则返回加1后的值，如果放在操作数后面则返回操作数原值，再将操作数加1。</td>
<td align="center"><code>let x = 3</code><br /><code>x++ //3</code><br /><code>++x  // 4</code></td>
</tr>
<tr>
<td align="center">自减<code>--</code></td>
<td align="center">一元运算符，将操作数的值减1。前后规则和则增相同</td>
<td align="center"><code>let x = 3</code><br /><code>x-- //3</code><br /><code>--x  // 2</code></td>
</tr>
<tr>
<td align="center">一元负值符<code>-</code></td>
<td align="center">一元运算符，返回操作数的负值</td>
<td align="center"><code>-x</code></td>
</tr>
<tr>
<td align="center">一元正操作符<code>+</code></td>
<td align="center">一元运算符，返回操作数的正值</td>
<td align="center"><code>+x</code></td>
</tr>
<tr>
<td align="center">指数运算符<code>**</code></td>
<td align="center">计算底数的指数次方</td>
<td align="center"><code>x**y //x的y次方</code></td>
</tr>
</tbody></table>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符将它的操作数当做32位元的二进制串。位运算符在二进制上执行运算，返回标准的JavaScript数值。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">用法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按位与<code>&amp;</code></td>
<td align="center"><code>a &amp; b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位都是1则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位或<code>|</code></td>
<td align="center"><code>a | b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位只要有1个是1则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位异或<code>^</code></td>
<td align="center"><code>a ^ b</code></td>
<td align="center">在a和b的位表示中，每一个对应的位两个不相同则返回1，否则返回0</td>
</tr>
<tr>
<td align="center">按位非<code>~</code></td>
<td align="center"><code>~ a</code></td>
<td align="center">翻转操作数的位</td>
</tr>
<tr>
<td align="center">左移<code>&lt;&lt;</code></td>
<td align="center"><code>a &lt;&lt; b</code></td>
<td align="center">将a的二进制串想左移动b位，右边加入0</td>
</tr>
<tr>
<td align="center">算数右移<code>&gt;&gt;</code></td>
<td align="center"><code>a &gt;&gt; b</code></td>
<td align="center">将a的二进制串向右移动b位，丢弃被移除的所有位</td>
</tr>
<tr>
<td align="center">无符号右移<code>&gt;&gt;&gt;</code></td>
<td align="center"><code>a &gt;&gt;&gt; b</code></td>
<td align="center">将a的二进制串向右移动b位，丢弃被移除的所有位，将左边空出的位都补0</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符常用于布尔值之间</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">范例</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑与<code>&amp;&amp;</code></td>
<td align="center"><code>a &amp;&amp; b</code></td>
<td align="center">如果a能被转成false，则返回a，否则返回b。当<code>&amp;&amp;</code>用于布尔值时，当操作数都为true时返回true，否则返回false</td>
</tr>
<tr>
<td align="center">逻辑或<code>||</code></td>
<td align="center"><code>a || b</code></td>
<td align="center">如果a能被转成true，则返回a，否则返回b。当<code>||</code>用于布尔值时，当操作数有一个为true时返回true，否则返回false</td>
</tr>
<tr>
<td align="center">逻辑非<code>!</code></td>
<td align="center"><code>!a</code></td>
<td align="center">如果操作数能转换true则返回false，否则返回true</td>
</tr>
</tbody></table>
<h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><ul>
<li><p><code>delete</code></p>
<p><code>delete</code>删除一个对象或一个对象的属性或者一个数组中的键值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> o.b;</span><br><span class="line"><span class="built_in">console</span>.log(o);    <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> arrs[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arrs);    <span class="comment">// [empty , 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>typeof</code></p>
<p><code>typeof</code>返回一个表示操作数类型的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'string'</span>);    <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);           <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);          <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);          <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);        <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);   <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>void</code></p>
<p><code>void</code>表明一个运算没有返回值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript: void(0)"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><ul>
<li><p><code>in</code></p>
<p><code>in</code>操作符如果所制定得属性确实存在于所制定的对象中，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> arrs);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">in</span> arrs);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> arrs);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">in</span> o);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">in</span> o);       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code></p>
<p><code>instanceof</code>操作符如果所判断的对象是所指定的对象类型，则返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.log(theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="基本表达式"><a href="#基本表达式" class="headerlink" title="基本表达式"></a>基本表达式</h4><ul>
<li><p><code>this</code></p>
<p><code>this</code>关键字被用于指代方法中正在被调用的对象，</p>
</li>
</ul>
<h4 id="左值表达式"><a href="#左值表达式" class="headerlink" title="左值表达式"></a>左值表达式</h4><ul>
<li><p><code>new</code></p>
<p><code>new</code>可以创建一个自定义类型或者是预置类型的对象实例。</p>
</li>
<li><p><code>super</code></p>
<p><code>super</code>可以用来调用一个对象父类的函数</p>
</li>
<li><p>扩展语句</p>
<p>扩展语句允许一个表达式在原地展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);    <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>语法和数据类型</title>
    <url>/wiki/%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h2><h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>JavaScript区分大小写，并使用Unicode字符集。即变量<code>test</code>和<code>TEXT</code>是两个不同的变量，并且可以使用中文作为变量名，如：<code>var 中文;</code></p>
<h3 id="分号可省略"><a href="#分号可省略" class="headerlink" title="分号可省略"></a>分号可省略</h3><p>每行代码结尾的分号可以省略，因为ECMAScript规定了在语句的末尾自动插入分号(ASI机制)。如果一行中有多条语句，那么这些语句必须以分号隔开。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JavaScript源码从左往右被扫描并转换成一系列由token、控制字符、行终止符、注释和空白字符组成的输入元素。</p>
<ul>
<li>控制字符<ul>
<li>零宽非连字符(&lt;ZWNJ&gt;, U+200C)，放置在一些经常会被当成连字的字符之间，用于将它们分别以独立形式显示。</li>
<li>零宽连字符(&lt;ZWJ&gt;, U+200D)，放置在一些通常不会被标记为连接字的字符之间，用于将这些字符以连字形式显示。</li>
<li>字节顺序标记(&lt;BOM&gt;, U+FEFF)，在脚本开头使用，除了将脚本标记为Unicode格式以外，还用来标记文本的字节流方向。</li>
</ul>
</li>
<li>空白符<ul>
<li>制表符(&lt;HT&gt;, U+0009)，水平制表符，<code>\t</code></li>
<li>垂直制表符(&lt;VT&gt;, U+000B)，垂直制表符，<code>\v</code></li>
<li>分页符(&lt;FF&gt;, U+000C)，分页符，<code>\f</code></li>
<li>空格(&lt;SP&gt;, U+0020)，空格</li>
<li>无间断空格(&lt;NBSP&gt;, U+00A0)，在该空格处不会换行</li>
</ul>
</li>
<li>行终止符<ul>
<li>换行符(&lt;LF&gt;, U+000A)，在UNIX系统中起新行，<code>\n</code></li>
<li>回车符(&lt;CR&gt;, U+000D)，在Commodore和早期的Mac系统中起新行，<code>\r</code></li>
<li>行分隔符(&lt;LS&gt;, U+2028)</li>
<li>段分隔符(&lt;PSs&gt;, U+2029)</li>
</ul>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>JavaScript的注释语法类似于C++，有两种注释方式：单行和多行。两种注释方式不能混用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量又叫标识符，需要遵循一定的规则：必须以字母、下划线(_)或者美元符($)开头，后续的字符也可以是数字(0-9)，可以使用ISO 8859-1或Unicode编码的字符作为标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> \u4e25 = <span class="number">1</span>;     <span class="comment">// 严的unicode编码为\u4e25</span></span><br><span class="line"><span class="built_in">console</span>.log(严);    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量声明</p>
<ul>
<li>使用关键词<code>var</code>，例如<code>var test = 1;</code>。该语法可以声明局部变量和全局变量。</li>
<li>直接赋值，例如<code>test = 1;</code>。在函数外使用这种形式赋值会产生一个全局变量，在严格模式下会产生错误。</li>
<li>使用关键词<code>let</code>，例如<code>let test = 1;</code>。该语法可以用来声明块作用域的局部变量</li>
</ul>
</li>
<li><p>变量求值</p>
<p>用<code>var</code>或<code>let</code>声明的变量如果没有赋初始值，则其值为<code>undefined</code>。如果访问一个未声明的变量会抛出一个·<code>ReferenceError</code>异常。</p>
<p>可以使用<code>undefined</code>来判断一个变量是否已经赋值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span>(test === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量未赋值'</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量已赋值'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>undefined</code>在布尔类型环境中会被当做<code>false</code>，所以上面的代码可以简化成下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span>(test) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量未赋值'</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test变量已赋值'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数值类型中<code>undefined</code>会被转成<code>NaN</code>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a+<span class="number">2</span>);    <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>空值<code>null</code>在数值类型中会被转换成0，在布尔类型中会准换成false，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">if</span>(!a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的作用域</p>
<p>在函数之外生声明的变量叫做全局变量，它可被当前文档中的任何其他代码访问。在函数内部声明的变量称为局部变量，只能在当前函数内部访问。    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;    <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> test;  <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ECMAScript6之前没有块级作用域(即大括号之间的代码块)，语句块中声明的变量会称为语句块所在的作用域中的变量。如果使用ES6中的<code>let</code>声明，就会变为块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test);    <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量提升</p>
<p>在JavaScript中可以先使用变量再进行声明，这被称为变量提升。感觉上提升是被移到了文档的最前面，但提升后的变量将返回<code>undefined</code>值，因此即便是在声明时赋值了初始值，也会返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>在ECMAScript6中，使用<code>let</code>或<code>const</code>声明会将变量提升但不会被初始化，因此在变量声明之前就使用这个变量，将会抛出引用错误(RefenceError)。这个变量将从代码块一开始的时候就处在一个<strong>暂时性死区</strong>(temporal dead zone)，直到这个变量被声明为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数提升</p>
<p>对于函数来说，只有函数声明会被提升，而函数表达式不会被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test();    <span class="comment">// test!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">test2();  <span class="comment">// TypeError: test2 is not a function</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test2!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局变量</p>
<p>全局变量实际上是全局对象的属性，在浏览器中默认的全局变量为<code>window</code>，可以使用<code>window.variable</code>的语法来设置和访问变量。</p>
</li>
<li><p>常量</p>
<p>在ECMAScript6中，可以使用<code>const</code>关键字声明常量，常量不可以重新赋值，所以在声明时就需要赋值。常量作用域与<code>let</code>一样，在同一作用域中，不能使用变量名或函数名相同的名字来命名常量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的ECMAScript定义了8中数据类型，分别为：</p>
<ul>
<li>原始类型<ul>
<li>Boolean，有且只有两个值: <code>true</code>和<code>false</code></li>
<li>Null，一个表明null值得特殊关键字，</li>
<li>undefined，一个表示值未定义的顶级属性</li>
<li>Number，整数或浮点数</li>
<li>String，代表文本值的一系列字符</li>
<li>Symbol，实例是唯一且不可变的数据类型</li>
<li>BigInt，具有任意精度的整数</li>
</ul>
</li>
<li>Object</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>JavaScript是一门动态类型的语言，在声明变量时可以不必指定数据类型，数据类型会在代码执行时根据需要自动转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;    <span class="comment">// 此时a的类型为number</span></span><br><span class="line">a = <span class="string">'1234'</span>;    <span class="comment">// 此时a的类型为string</span></span><br></pre></td></tr></table></figure>

<p>在包含数字和字符串的表达式中使用<code>+</code>运算，JavaScript会将数字隐式转换成字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'37'</span> + <span class="number">1</span>);    <span class="comment">// 371，类型为字符串，使用字符串的拼接操作</span></span><br></pre></td></tr></table></figure>

<p>在涉及其他运算符时，JavaScript会将字符串隐式转换成数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'37'</span> - <span class="number">1</span>);    <span class="comment">// 36，类型为数字</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量是在脚本中实际提供的固定值而不是变量，通常有以下类型的字面量：</p>
<ul>
<li><h5 id="数组字面量-Array-Literals"><a href="#数组字面量-Array-Literals" class="headerlink" title="数组字面量(Array Literals)"></a>数组字面量(Array Literals)</h5><p>数组字面量是0个或多个表达式的列表，每个表达式代表一个数组元素，并使用方括号<code>[]</code>括起来。使用数组字面量创建数组时，将使用指定的值作为其元素进行初始化，并且将其长度设置为指定的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, ,<span class="number">3</span>];</span><br><span class="line">nums[<span class="number">0</span>];    <span class="comment">// 1</span></span><br><span class="line">nums[<span class="number">1</span>];    <span class="comment">// undefined</span></span><br><span class="line">nums[<span class="number">2</span>];    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="布尔字面量-Boolean-Literals"><a href="#布尔字面量-Boolean-Literals" class="headerlink" title="布尔字面量(Boolean Literals)"></a>布尔字面量(Boolean Literals)</h4><p>有且仅有两个值：<code>true</code>和<code>false</code>。</p>
</li>
<li><h4 id="浮点数字面量-Float-point-Literals"><a href="#浮点数字面量-Float-point-Literals" class="headerlink" title="浮点数字面量(Float-point Literals)"></a>浮点数字面量(Float-point Literals)</h4><p>浮点数字面量可以有以下部分组成:</p>
<ul>
<li>一个带正负号(<code>+</code>、<code>-</code>)的十进制整数</li>
<li>小数点<code>.</code></li>
<li>小数部分(由一串十进制数表示)</li>
<li>指数部分，即<code>e</code>或<code>E</code>后跟一个整数，该整数可以带正负号。</li>
</ul>
<p>浮点数字面量必须至少包含一位数字，并带有小数点或<code>e</code>。语法类似:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(+|-)][digits].[digits][(E|e)[(+|-)]digits]</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="数字字面量-Numeric-Literals"><a href="#数字字面量-Numeric-Literals" class="headerlink" title="数字字面量(Numeric Literals)"></a>数字字面量(Numeric Literals)</h4><p>Number和BigInt类型可以使用十进制、十六进制、八进制和二进制表示。</p>
<ul>
<li>十进制的数字字面量是由前缀不为0的一串数字序列组成</li>
<li>八进制的数字字面量是由前缀为<code>0</code>或者前缀为<code>0O</code>的只包含0-7的数字组成</li>
<li>十六进制的数字字面量是由前缀为<code>0x</code>并且包含0-9和a-f的序列组成</li>
<li>二进制的数字字面量是由前缀为<code>0b</code>并且只包含0-1的数字序列组成</li>
</ul>
</li>
<li><h4 id="对象字面量-Object-Literals"><a href="#对象字面量-Object-Literals" class="headerlink" title="对象字面量(Object Literals)"></a>对象字面量(Object Literals)</h4><p>对象字面量是使用花括号<code>{}</code>括起来的0或多对<strong>属性名：属性值</strong>对的元素列表。不要在语句的开头使用对象字面量语法，这位被认为是一个块的开始</p>
<h6 id="增强的对象字面量-Enhanced-Object-literals"><a href="#增强的对象字面量-Enhanced-Object-literals" class="headerlink" title="增强的对象字面量(Enhanced Object literals)"></a>增强的对象字面量(Enhanced Object literals)</h6><p>在ES2015中，对象字面量扩展了支持在创建时设置原型，简写了<code>foo: foo</code>形式的属性赋值和方法定义，支持父方法调用，以及使用表达式动态计算属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  __proto__: theProtoObj,</span><br><span class="line">  handler, <span class="comment">// =&gt; handler: handler</span></span><br><span class="line">  toString() &#123;&#125;, <span class="comment">// =&gt; toString: function() &#123;&#125;</span></span><br><span class="line">  [<span class="string">'prop_'</span> + <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="number">42</span>)()]: <span class="number">42</span> <span class="comment">// 动态计算属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="正则表达式字面量-RegExp-Literals"><a href="#正则表达式字面量-RegExp-Literals" class="headerlink" title="正则表达式字面量(RegExp Literals)"></a>正则表达式字面量(RegExp Literals)</h4><p>正则表达式字面量是被斜杠<code>/</code>围成的表达式，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="字符串字面量-String-Literals"><a href="#字符串字面量-String-Literals" class="headerlink" title="字符串字面量(String Literals)"></a>字符串字面量(String Literals)</h4><p>字符串字面量是由双引号<code>&quot;</code>或单引号<code>&#39;</code>括起来的0个或多个字符，字符被限制在相同类型的引号之间。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure>

<p>ES2015还提供了一种模板字面量(template literals)，模板字面量使用反引号(<strong>`</strong>)，其为构造字符串提供了语法糖，还可以在模板字符串前添加一个tag来自定义模板字符串的解析过程，以预防注入攻击或建立基于字符串的高级数据抽象。例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'bob'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>);    <span class="comment">// Hello, bob</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料"></a>本文参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noopener">MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>索引集合</title>
    <url>/wiki/%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>数组是一个有序的数据集合，可以通过数组名称和索引进行访问。JavaScript中没有明确的数组数据类型，但可以使用内置的Array对象和其方法对数组进行操作。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数组有以下三种方法：</span></span><br><span class="line"><span class="comment">// 1. 使用Array构造函数</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用Array函数</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用数组字面量</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h4 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过给元素赋值进行填充数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr [<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr [<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);    <span class="comment">// [1, 2, empty, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length);    <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果索引是一个非整型数值，则将会被作为数组对象的属性存储，而非数组元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr[<span class="number">3.14</span>] = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);        <span class="comment">// [3.14: 3.14]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3.14</span>]);  <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty(<span class="number">3.14</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数组元素"><a href="#引用数组元素" class="headerlink" title="引用数组元素"></a>引用数组元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组名加索引的方式引用</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><p>在实施层面，JavaScript实际上是将元素作为标准的对象属性来存储。把索引作为属性名。<strong>length</strong>属性是特殊的，它总是返回最后一个元素的索引值+1，也可以通过改写<strong>length</strong>来修改数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [];</span><br><span class="line">arrs[<span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrs.length);  <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">arrs.length = <span class="number">0</span>;    <span class="comment">// 将length属性改为0会清空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(arrs);  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的操作是遍历数组的值，并以某种方式进行处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrs[i]);    <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果确定数组中的元素没有一个false，例如只包含dom节点的数组，可以使用下面的方法</span></span><br><span class="line"><span class="comment">// 该方法可以避免检测数组长度的开销，并确保每次循环时都将div变量重新分配给当前项</span></span><br><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, div; div = divs[i]; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(div)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用forEach方法</span></span><br><span class="line"><span class="comment">// 被传递给forEach的回调函数会在数组的每个元素上执行一次，元素作为参数传递给回调函数，未赋值的值不会在forEach循环迭代</span></span><br><span class="line">arrs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在数组定义时省略的元素不会在forEach遍历中列出，但手动赋值的undefined会被列出</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [,,<span class="literal">undefined</span>,<span class="number">1</span>];</span><br><span class="line">arr1.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);    <span class="comment">// undefined, 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4>]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>w-JavaScript</tag>
      </tags>
  </entry>
</search>
